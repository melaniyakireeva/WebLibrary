{
  "version": 3,
  "sources": ["../../../../../../node_modules/@taiga-ui/cdk/fesm2022/taiga-ui-cdk-utils-math.mjs", "../../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs", "../../../../../../node_modules/@taiga-ui/cdk/fesm2022/taiga-ui-cdk-utils-miscellaneous.mjs"],
  "sourcesContent": ["/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\n/**\n * Clamps a value between two inclusive limits\n *\n * @param value\n * @param min lower limit\n * @param max upper limit\n */\nfunction tuiClamp(value, min, max) {\n  ngDevMode && console.assert(!Number.isNaN(value));\n  ngDevMode && console.assert(!Number.isNaN(min));\n  ngDevMode && console.assert(!Number.isNaN(max));\n  ngDevMode && console.assert(max >= min);\n  return Math.min(max, Math.max(min, value));\n}\n\n/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\nfunction tuiInRange(value, fromInclude, toExclude) {\n  ngDevMode && console.assert(!Number.isNaN(value));\n  ngDevMode && console.assert(!Number.isNaN(fromInclude));\n  ngDevMode && console.assert(!Number.isNaN(toExclude));\n  ngDevMode && console.assert(fromInclude < toExclude);\n  return value >= fromInclude && value < toExclude;\n}\n\n/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\n/**\n * Normalizes any number to an integer within inclusive range\n *\n * @param value\n * @param min lower inclusive integer\n * @param max upper inclusive integer\n * @return an integer between min and max inclusive\n */\nfunction tuiNormalizeToIntNumber(value, min, max) {\n  ngDevMode && console.assert(Number.isInteger(min));\n  ngDevMode && console.assert(Number.isInteger(max));\n  ngDevMode && console.assert(min <= max);\n  if (Number.isNaN(value) || value <= min) {\n    return min;\n  }\n  if (value >= max) {\n    return max;\n  }\n  return Math.round(value);\n}\n\n/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\n/**\n * Rounds a number to the closest value in a fixed discrete series\n *\n * @param value\n * @param quantum series step\n */\nfunction tuiQuantize(value, quantum) {\n  ngDevMode && console.assert(Number.isFinite(value));\n  ngDevMode && console.assert(Number.isFinite(quantum));\n  ngDevMode && console.assert(quantum > 0);\n  const remainder = value % quantum;\n  return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;\n}\n\n/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\nconst MAX_PRECISION = 292;\n/**\n * Rounding number to the set precision\n *\n * @param value\n * @param precision number of digits in a float part\n * @param func rounding function (round, floor, ceil)\n */\nfunction calculate(value, precision, func) {\n  if (value === Infinity) {\n    return value;\n  }\n  ngDevMode && console.assert(!Number.isNaN(value), 'Value must be number');\n  ngDevMode && console.assert(Number.isInteger(precision), 'Precision must be integer');\n  precision = Math.min(precision, MAX_PRECISION);\n  const pair = `${value}e`.split('e');\n  const tempValue = func(Number(`${pair[0]}e${Number(pair[1]) + precision}`));\n  const processedPair = `${tempValue}e`.split('e');\n  return Number(`${processedPair[0]}e${Number(processedPair[1]) - precision}`);\n}\nfunction tuiRound(value, precision = 0) {\n  return calculate(value, precision, Math.round);\n}\nfunction tuiCeil(value, precision = 0) {\n  return calculate(value, precision, Math.ceil);\n}\nfunction tuiFloor(value, precision = 0) {\n  return calculate(value, precision, Math.floor);\n}\nfunction tuiTrunc(value, precision = 0) {\n  return calculate(value, precision, Math.trunc);\n}\nfunction tuiRoundWith({\n  value,\n  precision,\n  method\n}) {\n  switch (method) {\n    case 'ceil':\n      return tuiCeil(value, precision);\n    case 'floor':\n      return tuiFloor(value, precision);\n    case 'round':\n      return tuiRound(value, precision);\n    default:\n      return tuiTrunc(value, precision);\n  }\n}\n\n/**\n * Calculates sum of any number of passed arguments\n */\nfunction tuiSum(...args) {\n  return args.reduce((a, b) => a + b, 0);\n}\nfunction tuiToInt(bool) {\n  return bool ? 1 : 0;\n}\nfunction tuiToInteger(value) {\n  return parseInt(value, 10);\n}\n\n/**\n * Converts angle in degrees to radians\n */\nfunction tuiToRadians(deg) {\n  return deg * Math.PI / 180;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCeil, tuiClamp, tuiFloor, tuiInRange, tuiNormalizeToIntNumber, tuiQuantize, tuiRound, tuiRoundWith, tuiSum, tuiToInt, tuiToInteger, tuiToRadians, tuiTrunc };\n", "/**\n * @license Angular v18.2.9\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n  constructor(source) {\n    this.source = source;\n    this.destroyed = false;\n    this.destroyRef = inject(DestroyRef);\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  subscribe(callbackFn) {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: value => callbackFn(value)\n    });\n    return {\n      unsubscribe: () => subscription.unsubscribe()\n    };\n  }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n  const destroyRef = ɵgetOutputDestroyRef(ref);\n  return new Observable(observer => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n    const subscription = ref.subscribe(v => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n  ngDevMode && assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  const equal = makeToSignalEqual(options?.equal);\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({\n      kind: 0 /* StateKind.NoValue */\n    }, {\n      equal\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    }, {\n      equal\n    });\n  }\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({\n        kind: 2 /* StateKind.Error */,\n        error\n      });\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n    throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  }, {\n    equal: options?.equal\n  });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n  return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n", "import { FormArray, FormGroup } from '@angular/forms';\nimport { tuiToInt } from '@taiga-ui/cdk/utils/math';\nimport { InjectionToken, isSignal, signal, inject, effect, DestroyRef, EnvironmentInjector, createComponent } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nfunction tuiArrayRemove(array, index) {\n  return array.slice(0, Math.max(index, 0)).concat(array.slice(Math.max(index + 1, 0)));\n}\nfunction tuiArrayShallowEquals(a, b) {\n  return a.length === b.length && a.every((item, index) => item === b[index]);\n}\nfunction tuiArrayToggle(array, item) {\n  const index = array.indexOf(item);\n  return index === -1 ? [...array, item] : tuiArrayRemove(array, index);\n}\n\n/* internal */\nconst changeDateSeparator = (dateString, newDateSeparator) => dateString.replaceAll(/[^0-9A-Za-zА-Яа-я]/gi, newDateSeparator);\nfunction tuiIsControlEmpty({\n  value = null\n}) {\n  return value === null || value === '' || Array.isArray(value) && !value.length;\n}\nfunction tuiCountFilledControls(control) {\n  if (control instanceof FormArray) {\n    return control.controls.reduce((acc, nestedControl) => acc + tuiCountFilledControls(nestedControl), 0);\n  }\n  if (control instanceof FormGroup) {\n    return Object.values(control.controls).reduce((acc, nestedControl) => acc + tuiCountFilledControls(nestedControl), 0);\n  }\n  return tuiToInt(!tuiIsControlEmpty(control));\n}\nfunction tuiCreateToken(defaults) {\n  return tuiCreateTokenFromFactory(() => defaults);\n}\nfunction tuiCreateTokenFromFactory(factory) {\n  return factory ? new InjectionToken('', {\n    factory\n  }) : new InjectionToken('');\n}\nfunction tuiIsString(value) {\n  return typeof value === 'string';\n}\nfunction tuiDefaultSort(x, y) {\n  if (x === y) {\n    return 0;\n  }\n  if (tuiIsString(x) && tuiIsString(y)) {\n    return x.localeCompare(y);\n  }\n  return x > y ? 1 : -1;\n}\nfunction tuiDirectiveBinding(token, key, initial, options = {\n  self: true\n}) {\n  const result = isSignal(initial) ? initial : signal(initial);\n  const directive = inject(token, options);\n  const output = directive[`${key.toString()}Change`];\n  // TODO: Figure out why effects are executed all the time and not just when result changes (check with Angular 18)\n  let previous;\n  effect(() => {\n    const value = result();\n    if (previous === value) {\n      return;\n    }\n    if (isSignal(directive[key])) {\n      directive[key].set(value);\n    } else {\n      directive[key] = value;\n    }\n    directive.ngOnChanges?.({});\n    output?.emit?.(value);\n    previous = value;\n  }, {\n    allowSignalWrites: true\n  });\n  return result;\n}\nfunction tuiDirectiveListener(token, key, options = {\n  self: true\n}) {\n  const prop = inject(token, options)?.[key];\n  return isSignal(prop) ? prop : toSignal(prop);\n}\nfunction tuiDistanceBetweenTouches({\n  touches\n}) {\n  return Math.hypot((touches[0]?.clientX ?? 0) - (touches[1]?.clientX ?? 0), (touches[0]?.clientY ?? 0) - (touches[1]?.clientY ?? 0));\n}\n\n/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\nfunction tuiEaseInOutQuad(t) {\n  ngDevMode && console.assert(t >= 0 && t <= 1, 'Input must be between 0 and 1 inclusive but received ', t);\n  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\n\n/**\n * Flattens two-dimensional array and calculates resulting length\n *\n * @param array twi dimensional array\n */\nfunction tuiFlatLength(array) {\n  return array.reduce((count, section) => count + section.length, 0);\n}\n\n/**\n * Extracts original array from {@link QueryList} rather than\n * creating a copy like {@link QueryList.toArray} does.\n * @param queryList\n * @returns original array from {@link QueryList}.\n */\nfunction tuiGetOriginalArrayFromQueryList(queryList) {\n  let array = [];\n  queryList.find((_item, _index, originalArray) => {\n    array = originalArray;\n    return true;\n  });\n  return array;\n}\nfunction tuiIsFalsy(value) {\n  return !value;\n}\nfunction tuiIsNumber(value) {\n  return typeof value === 'number';\n}\nfunction tuiIsObject(value) {\n  return typeof value === 'object' && !!value;\n}\nfunction tuiIsPresent(value) {\n  return value !== null && value !== undefined;\n}\n\n/**\n * @deprecated: drop in v5.0\n */\nfunction tuiIsValidUrl(url) {\n  return new RegExp(String.raw`^([a-zA-Z]+:\\/\\/)?` +\n  // protocol\n  String.raw`((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|localhost|` +\n  // domain name\n  String.raw`((\\d{1,3}\\.){3}\\d{1,3}))` +\n  // OR IP (v4) address\n  String.raw`(\\:\\d+)?(\\/[-a-z\\d%_.~+\\:]*)*` +\n  // port and path\n  String.raw`(\\?[)(;&a-z\\d%_.~+=-]*)?` +\n  // query string\n  String.raw`(\\#[-a-z\\d_]*)?$`,\n  // fragment locator\n  'i').test(url);\n}\nfunction tuiMarkControlAsTouchedAndValidate(control) {\n  if (control instanceof FormArray) {\n    control.controls.forEach(nestedControl => {\n      tuiMarkControlAsTouchedAndValidate(nestedControl);\n    });\n  }\n  if (control instanceof FormGroup) {\n    Object.values(control.controls).forEach(nestedControl => {\n      tuiMarkControlAsTouchedAndValidate(nestedControl);\n    });\n  }\n  control.markAsTouched();\n  control.updateValueAndValidity();\n}\n\n/**\n * Checks identity for nullable elements.\n *\n * @param a element a\n * @param b element b\n * @param handler called if both elements are not null\n * @return true if either both are null or they pass identity handler\n */\nfunction tuiNullableSame(a, b, handler) {\n  if (a === null) {\n    return b === null;\n  }\n  if (b === null) {\n    return false;\n  }\n  return handler(a, b);\n}\nfunction tuiProvide(provide, useExisting, multi = false) {\n  return {\n    provide,\n    useExisting,\n    multi\n  };\n}\nfunction tuiProvideOptions(provide, options, fallback) {\n  return {\n    provide,\n    useFactory: () => ({\n      ...(inject(provide, {\n        optional: true,\n        skipSelf: true\n      }) || fallback),\n      ...options\n    })\n  };\n}\n\n/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\nfunction decorateMethod(originalMethod) {\n  let previousArgs = [];\n  let originalFnWasCalledLeastAtOnce = false;\n  let pureValue;\n  return function tuiPureMethodPatched(...args) {\n    const isPure = originalFnWasCalledLeastAtOnce && previousArgs.length === args.length && args.every((arg, index) => arg === previousArgs[index]);\n    if (isPure) {\n      return pureValue;\n    }\n    previousArgs = args;\n    pureValue = originalMethod.apply(this, args);\n    originalFnWasCalledLeastAtOnce = true;\n    return pureValue;\n  };\n}\nfunction decorateGetter(originalGetter, propertyKey, enumerable = true) {\n  return function tuiPureGetterPatched() {\n    const value = originalGetter.call(this);\n    Object.defineProperty(this, propertyKey, {\n      enumerable,\n      value\n    });\n    return value;\n  };\n}\nfunction tuiPure(target, propertyKeyOrContext, descriptor) {\n  if (typeof target === 'function') {\n    const context = propertyKeyOrContext;\n    if (context.kind === 'getter') {\n      return decorateGetter(target, context.name);\n    }\n    if (context.kind === 'method') {\n      return decorateMethod(target);\n    }\n    throw new TuiPureException();\n  }\n  const {\n    get,\n    enumerable,\n    value\n  } = descriptor;\n  const propertyKey = propertyKeyOrContext;\n  if (get) {\n    return {\n      configurable: true,\n      enumerable,\n      get: decorateGetter(get, propertyKey, enumerable)\n    };\n  }\n  if (typeof value !== 'function') {\n    throw new TuiPureException();\n  }\n  const original = value;\n  return {\n    configurable: true,\n    enumerable,\n    get() {\n      let previousArgs = [];\n      let originalFnWasCalledLeastAtOnce = false;\n      let pureValue;\n      const patched = (...args) => {\n        const isPure = originalFnWasCalledLeastAtOnce && previousArgs.length === args.length && args.every((arg, index) => arg === previousArgs[index]);\n        if (isPure) {\n          return pureValue;\n        }\n        previousArgs = args;\n        pureValue = original.apply(this, args);\n        originalFnWasCalledLeastAtOnce = true;\n        return pureValue;\n      };\n      Object.defineProperty(this, propertyKey, {\n        configurable: true,\n        value: patched\n      });\n      return patched;\n    }\n  };\n}\nclass TuiPureException extends Error {\n  constructor() {\n    super(ngDevMode ? 'tuiPure can only be used with functions or getters' : '');\n  }\n}\n\n/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\n/**\n * Adds 'px' to the number and turns it into a string\n */\nfunction tuiPx(value) {\n  ngDevMode && console.assert(Number.isFinite(value), 'Value must be finite number');\n  return `${value}px`;\n}\nfunction tuiUniqBy(array, key) {\n  return Array.from(array.reduce((map, item) => map.has(item[key]) ? map : map.set(item[key], item), new Map()).values());\n}\nconst MAP = tuiCreateTokenFromFactory(() => {\n  const map = new Map();\n  inject(DestroyRef).onDestroy(() => map.forEach(component => component.destroy()));\n  return map;\n});\nfunction tuiWithStyles(component) {\n  const map = inject(MAP);\n  const environmentInjector = inject(EnvironmentInjector);\n  if (!map.has(component)) {\n    map.set(component, createComponent(component, {\n      environmentInjector\n    }));\n  }\n  return undefined;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TuiPureException, changeDateSeparator, tuiArrayRemove, tuiArrayShallowEquals, tuiArrayToggle, tuiCountFilledControls, tuiCreateToken, tuiCreateTokenFromFactory, tuiDefaultSort, tuiDirectiveBinding, tuiDirectiveListener, tuiDistanceBetweenTouches, tuiEaseInOutQuad, tuiFlatLength, tuiGetOriginalArrayFromQueryList, tuiIsControlEmpty, tuiIsFalsy, tuiIsNumber, tuiIsObject, tuiIsPresent, tuiIsString, tuiIsValidUrl, tuiMarkControlAsTouchedAndValidate, tuiNullableSame, tuiProvide, tuiProvideOptions, tuiPure, tuiPx, tuiUniqBy, tuiWithStyles };\n"],
  "mappings": "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",
  "names": []
}
