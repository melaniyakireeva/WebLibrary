{"ast":null,"code":"import { maskitoUpdateElement, MASKITO_DEFAULT_OPTIONS, maskitoTransform } from '@maskito/core';\n\n/**\n * Clamps a value between two inclusive limits\n *\n * @param value\n * @param min lower limit\n * @param max upper limit\n */\nfunction clamp(value, min, max) {\n  const clampedValue = Math.min(Number(max), Math.max(Number(min), Number(value)));\n  return value instanceof Date ? new Date(clampedValue) : clampedValue;\n}\nfunction countDigits(str) {\n  return str.replaceAll(/\\W/g, '').length;\n}\nfunction appendDate(initialDate, {\n  day,\n  month,\n  year\n} = {}) {\n  const date = new Date(initialDate);\n  if (day) {\n    date.setDate(date.getDate() + day);\n  }\n  if (month) {\n    date.setMonth(date.getMonth() + month);\n  }\n  if (year) {\n    date.setFullYear(date.getFullYear() + year);\n  }\n  return date;\n}\nconst getDateSegmentValueLength = dateString => {\n  var _a, _b, _c, _d, _e, _f;\n  return {\n    day: (_b = (_a = dateString.match(/d/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,\n    month: (_d = (_c = dateString.match(/m/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,\n    year: (_f = (_e = dateString.match(/y/g)) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0\n  };\n};\nfunction dateToSegments(date) {\n  return {\n    day: String(date.getDate()).padStart(2, '0'),\n    month: String(date.getMonth() + 1).padStart(2, '0'),\n    year: String(date.getFullYear()).padStart(4, '0'),\n    hours: String(date.getHours()).padStart(2, '0'),\n    minutes: String(date.getMinutes()).padStart(2, '0'),\n    seconds: String(date.getSeconds()).padStart(2, '0'),\n    milliseconds: String(date.getMilliseconds()).padStart(3, '0')\n  };\n}\nfunction getFirstCompleteDate(dateString, dateModeTemplate) {\n  const digitsInDate = countDigits(dateModeTemplate);\n  const [completeDate = ''] = new RegExp(`(\\\\D*\\\\d){${digitsInDate}}`).exec(dateString) || [];\n  return completeDate;\n}\nfunction isDateStringComplete(dateString, dateModeTemplate) {\n  if (dateString.length < dateModeTemplate.length) {\n    return false;\n  }\n  return dateString.split(/\\D/).every(segment => !/^0+$/.exec(segment));\n}\nfunction parseDateRangeString(dateRange, dateModeTemplate, rangeSeparator) {\n  const digitsInDate = countDigits(dateModeTemplate);\n  return dateRange.replace(rangeSeparator, '').match(new RegExp(`(\\\\D*\\\\d[^\\\\d\\\\s]*){1,${digitsInDate}}`, 'g')) || [];\n}\nfunction parseDateString(dateString, fullMode) {\n  const cleanMode = fullMode.replaceAll(/[^dmy]/g, '');\n  const onlyDigitsDate = dateString.replaceAll(/\\D+/g, '');\n  const dateSegments = {\n    day: onlyDigitsDate.slice(cleanMode.indexOf('d'), cleanMode.lastIndexOf('d') + 1),\n    month: onlyDigitsDate.slice(cleanMode.indexOf('m'), cleanMode.lastIndexOf('m') + 1),\n    year: onlyDigitsDate.slice(cleanMode.indexOf('y'), cleanMode.lastIndexOf('y') + 1)\n  };\n  return Object.fromEntries(Object.entries(dateSegments).filter(([_, value]) => Boolean(value)).sort(([a], [b]) => fullMode.toLowerCase().indexOf(a.slice(0, 1)) > fullMode.toLowerCase().indexOf(b.slice(0, 1)) ? 1 : -1));\n}\nfunction segmentsToDate(parsedDate, parsedTime) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const year = ((_a = parsedDate.year) === null || _a === void 0 ? void 0 : _a.length) === 2 ? `20${parsedDate.year}` : parsedDate.year;\n  const date = new Date(Number(year !== null && year !== void 0 ? year : '0'), Number((_b = parsedDate.month) !== null && _b !== void 0 ? _b : '1') - 1, Number((_c = parsedDate.day) !== null && _c !== void 0 ? _c : '1'), Number((_d = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.hours) !== null && _d !== void 0 ? _d : '0'), Number((_e = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.minutes) !== null && _e !== void 0 ? _e : '0'), Number((_f = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.seconds) !== null && _f !== void 0 ? _f : '0'), Number((_g = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.milliseconds) !== null && _g !== void 0 ? _g : '0'));\n  // needed for years less than 1900\n  date.setFullYear(Number(year !== null && year !== void 0 ? year : '0'));\n  return date;\n}\nconst DATE_TIME_SEPARATOR = ', ';\nfunction toDateString({\n  day,\n  month,\n  year,\n  hours,\n  minutes,\n  seconds,\n  milliseconds\n}, {\n  dateMode,\n  dateTimeSeparator = DATE_TIME_SEPARATOR,\n  timeMode\n}) {\n  var _a;\n  const safeYear = ((_a = dateMode.match(/y/g)) === null || _a === void 0 ? void 0 : _a.length) === 2 ? year === null || year === void 0 ? void 0 : year.slice(-2) : year;\n  const fullMode = dateMode + (timeMode ? dateTimeSeparator + timeMode : '');\n  return fullMode.replaceAll(/d+/g, day !== null && day !== void 0 ? day : '').replaceAll(/m+/g, month !== null && month !== void 0 ? month : '').replaceAll(/y+/g, safeYear !== null && safeYear !== void 0 ? safeYear : '').replaceAll(/H+/g, hours !== null && hours !== void 0 ? hours : '').replaceAll('MSS', milliseconds !== null && milliseconds !== void 0 ? milliseconds : '').replaceAll(/M+/g, minutes !== null && minutes !== void 0 ? minutes : '').replaceAll(/S+/g, seconds !== null && seconds !== void 0 ? seconds : '').replaceAll(/^\\D+/g, '').replaceAll(/\\D+$/g, '');\n}\nconst DATE_SEGMENTS_MAX_VALUES = {\n  day: 31,\n  month: 12,\n  year: 9999\n};\nconst DEFAULT_DECIMAL_PSEUDO_SEPARATORS = ['.', ',', 'б', 'ю'];\nconst DEFAULT_MIN_DATE = new Date('0001-01-01');\nconst DEFAULT_MAX_DATE = new Date('9999-12-31');\nconst DEFAULT_TIME_SEGMENT_MAX_VALUES = {\n  hours: 23,\n  minutes: 59,\n  seconds: 59,\n  milliseconds: 999\n};\nconst DEFAULT_TIME_SEGMENT_MIN_VALUES = {\n  hours: 0,\n  minutes: 0,\n  seconds: 0,\n  milliseconds: 0\n};\n\n/**\n * {@link https://unicode-table.com/en/00A0/ Non-breaking space}.\n */\nconst CHAR_NO_BREAK_SPACE = '\\u00A0';\n/**\n * {@link https://symbl.cc/en/200B/ Zero width space}.\n */\nconst CHAR_ZERO_WIDTH_SPACE = '\\u200B';\n/**\n * {@link https://unicode-table.com/en/2013/ EN dash}\n * is used to indicate a range of numbers or a span of time.\n * @example 2006–2022\n */\nconst CHAR_EN_DASH = '\\u2013';\n/**\n * {@link https://unicode-table.com/en/2014/ EM dash}\n * is used to mark a break in a sentence.\n * @example Taiga UI — powerful set of open source components for Angular\n * ___\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_HYPHEN}!\n */\nconst CHAR_EM_DASH = '\\u2014';\n/**\n * {@link https://unicode-table.com/en/002D/ Hyphen (minus sign)}\n * is used to combine words.\n * @example well-behaved\n * ___\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_EM_DASH}!\n */\nconst CHAR_HYPHEN = '\\u002D';\n/**\n * {@link https://unicode-table.com/en/2212/ Minus}\n * is used as math operator symbol or before negative digits.\n * ---\n * Can be used as `&minus;`. Don't confuse with {@link CHAR_HYPHEN}\n */\nconst CHAR_MINUS = '\\u2212';\n/**\n * {@link https://symbl.cc/en/30FC/ Katakana-Hiragana Prolonged Sound Mark}\n * is used as prolonged sounds in Japanese.\n */\nconst CHAR_JP_HYPHEN = '\\u30FC';\n/**\n * {@link https://symbl.cc/en/003A/ Colon}\n * is a punctuation mark that connects parts of a text logically.\n * ---\n * is also used as separator in time.\n */\nconst CHAR_COLON = '\\u003A';\n/**\n * {@link https://symbl.cc/en/FF1A/ Full-width colon}\n * is a full-width punctuation mark used to separate parts of a text commonly in Japanese.\n */\nconst CHAR_JP_COLON = '\\uFF1A';\nconst ANY_MERIDIEM_CHARACTER_RE = new RegExp(`[${CHAR_NO_BREAK_SPACE}APM]+$`, 'g');\nconst ALL_MERIDIEM_CHARACTERS_RE = new RegExp(`${CHAR_NO_BREAK_SPACE}[AP]M$`, 'g');\nconst TIME_FIXED_CHARACTERS = [':', '.'];\nconst TIME_SEGMENT_VALUE_LENGTHS = {\n  hours: 2,\n  minutes: 2,\n  seconds: 2,\n  milliseconds: 3\n};\nfunction validateDateString({\n  dateString,\n  dateModeTemplate,\n  dateSegmentsSeparator,\n  offset,\n  selection: [from, to]\n}) {\n  const parsedDate = parseDateString(dateString, dateModeTemplate);\n  const dateSegments = Object.entries(parsedDate);\n  const validatedDateSegments = {};\n  for (const [segmentName, segmentValue] of dateSegments) {\n    const validatedDate = toDateString(validatedDateSegments, {\n      dateMode: dateModeTemplate\n    });\n    const maxSegmentValue = DATE_SEGMENTS_MAX_VALUES[segmentName];\n    const fantomSeparator = validatedDate.length && dateSegmentsSeparator.length;\n    const lastSegmentDigitIndex = offset + validatedDate.length + fantomSeparator + getDateSegmentValueLength(dateModeTemplate)[segmentName];\n    const isLastSegmentDigitAdded = lastSegmentDigitIndex >= from && lastSegmentDigitIndex === to;\n    if (isLastSegmentDigitAdded && Number(segmentValue) > Number(maxSegmentValue)) {\n      // 3|1.10.2010 => Type 9 => 3|1.10.2010\n      return {\n        validatedDateString: '',\n        updatedSelection: [from, to]\n      }; // prevent changes\n    }\n    if (isLastSegmentDigitAdded && Number(segmentValue) < 1) {\n      // 31.0|1.2010 => Type 0 => 31.0|1.2010\n      return {\n        validatedDateString: '',\n        updatedSelection: [from, to]\n      }; // prevent changes\n    }\n    validatedDateSegments[segmentName] = segmentValue;\n  }\n  const validatedDateString = toDateString(validatedDateSegments, {\n    dateMode: dateModeTemplate\n  });\n  const addedDateSegmentSeparators = validatedDateString.length - dateString.length;\n  return {\n    validatedDateString,\n    updatedSelection: [from + addedDateSegmentSeparators, to + addedDateSegmentSeparators]\n  };\n}\n\n/**\n * Copy-pasted solution from lodash\n * @see https://lodash.com/docs/4.17.15#escapeRegExp\n */\nconst reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nconst reHasRegExpChar = new RegExp(reRegExpChar.source);\nfunction escapeRegExp(str) {\n  return str && reHasRegExpChar.test(str) ? str.replaceAll(reRegExpChar, String.raw`\\$&`) : str;\n}\nfunction extractAffixes(value, {\n  prefix,\n  postfix\n}) {\n  var _a, _b;\n  const prefixRegExp = new RegExp(`^${escapeRegExp(prefix)}`);\n  const postfixRegExp = new RegExp(`${escapeRegExp(postfix)}$`);\n  const [extractedPrefix = ''] = (_a = value.match(prefixRegExp)) !== null && _a !== void 0 ? _a : [];\n  const [extractedPostfix = ''] = (_b = value.match(postfixRegExp)) !== null && _b !== void 0 ? _b : [];\n  const cleanValue = value.replace(prefixRegExp, '').replace(postfixRegExp, '');\n  return {\n    extractedPrefix,\n    extractedPostfix,\n    cleanValue\n  };\n}\nfunction findCommonBeginningSubstr(a, b) {\n  let res = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return res;\n    }\n    res += a[i];\n  }\n  return res;\n}\nfunction identity(x) {\n  return x;\n}\nfunction isEmpty(entity) {\n  return !entity || typeof entity === 'object' && Object.keys(entity).length === 0;\n}\nconst ALL_ZEROES_RE = /^0+$/;\nfunction padWithZeroesUntilValid(segmentValue, paddedMaxValue, prefixedZeroesCount = 0) {\n  const paddedSegmentValue = segmentValue.padEnd(paddedMaxValue.length, '0');\n  if (Number(paddedSegmentValue) <= Number(paddedMaxValue)) {\n    return {\n      validatedSegmentValue: segmentValue,\n      prefixedZeroesCount\n    };\n  }\n  if (paddedSegmentValue.endsWith('0')) {\n    // 00:|00 => Type 9 => 00:09|\n    return padWithZeroesUntilValid(`0${segmentValue.slice(0, paddedMaxValue.length - 1)}`, paddedMaxValue, prefixedZeroesCount + 1);\n  }\n  const valueWithoutLastChar = segmentValue.slice(0, paddedMaxValue.length - 1);\n  if (ALL_ZEROES_RE.exec(valueWithoutLastChar)) {\n    return {\n      validatedSegmentValue: '',\n      prefixedZeroesCount\n    };\n  }\n  // |19:00 => Type 2 => 2|0:00\n  return padWithZeroesUntilValid(`${valueWithoutLastChar}0`, paddedMaxValue, prefixedZeroesCount);\n}\n\n/**\n * Replace fullwidth colon with half width colon\n * @param fullWidthColon full width colon\n * @returns processed half width colon\n */\nfunction toHalfWidthColon(fullWidthColon) {\n  return fullWidthColon.replaceAll(new RegExp(CHAR_JP_COLON, 'g'), CHAR_COLON);\n}\n\n/**\n * Replace fullwidth numbers with half width number\n * @param fullWidthNumber full width number\n * @returns processed half width number\n */\nfunction toHalfWidthNumber(fullWidthNumber) {\n  return fullWidthNumber.replaceAll(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xfee0));\n}\n\n/**\n * Convert full width colon (：) to half width one (:)\n */\nfunction createColonConvertPreprocessor() {\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    return {\n      elementState: {\n        selection,\n        value: toHalfWidthColon(value)\n      },\n      data: toHalfWidthColon(data)\n    };\n  };\n}\nfunction createDateSegmentsZeroPaddingPostprocessor({\n  dateModeTemplate,\n  dateSegmentSeparator,\n  splitFn,\n  uniteFn\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    var _a;\n    const [from, to] = selection;\n    const {\n      dateStrings,\n      restPart = ''\n    } = splitFn(value);\n    const validatedDateStrings = [];\n    let caretShift = 0;\n    dateStrings.forEach(dateString => {\n      const parsedDate = parseDateString(dateString, dateModeTemplate);\n      const dateSegments = Object.entries(parsedDate);\n      const validatedDateSegments = dateSegments.reduce((acc, [segmentName, segmentValue]) => {\n        const {\n          validatedSegmentValue,\n          prefixedZeroesCount\n        } = padWithZeroesUntilValid(segmentValue, `${DATE_SEGMENTS_MAX_VALUES[segmentName]}`);\n        caretShift += prefixedZeroesCount;\n        return Object.assign(Object.assign({}, acc), {\n          [segmentName]: validatedSegmentValue\n        });\n      }, {});\n      validatedDateStrings.push(toDateString(validatedDateSegments, {\n        dateMode: dateModeTemplate\n      }));\n    });\n    const validatedValue = uniteFn(validatedDateStrings, value) + (((_a = dateStrings[dateStrings.length - 1]) === null || _a === void 0 ? void 0 : _a.endsWith(dateSegmentSeparator)) ? dateSegmentSeparator : '') + restPart;\n    if (caretShift && validatedValue.slice(to + caretShift, to + caretShift + dateSegmentSeparator.length) === dateSegmentSeparator) {\n      /**\n       * If `caretShift` > 0, it means that time segment was padded with zero.\n       * It is only possible if any character insertion happens.\n       * If caret is before `dateSegmentSeparator` => it should be moved after `dateSegmentSeparator`.\n       */\n      caretShift += dateSegmentSeparator.length;\n    }\n    return {\n      selection: [from + caretShift, to + caretShift],\n      value: validatedValue\n    };\n  };\n}\n\n/**\n * It replaces pseudo range separators with valid one.\n * @example '01.01.2000_11.11.2000' -> '01.01.2000 - 01.01.2000'\n * @example '01.01.2000_23:59' -> '01.01.2000, 23:59'\n */\nfunction createFirstDateEndSeparatorPreprocessor({\n  dateModeTemplate,\n  firstDateEndSeparator,\n  dateSegmentSeparator,\n  pseudoFirstDateEndSeparators\n}) {\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const [from, to] = selection;\n    const firstCompleteDate = getFirstCompleteDate(value, dateModeTemplate);\n    const pseudoSeparators = pseudoFirstDateEndSeparators.filter(x => !firstDateEndSeparator.includes(x) && x !== dateSegmentSeparator);\n    const pseudoSeparatorsRE = new RegExp(`[${pseudoSeparators.join('')}]`, 'gi');\n    const newValue = firstCompleteDate && value.length > firstCompleteDate.length ? firstCompleteDate + value.slice(firstCompleteDate.length).replace(/^[\\D\\s]*/, firstDateEndSeparator) : value;\n    const caretShift = newValue.length - value.length;\n    return {\n      elementState: {\n        selection: [from + caretShift, to + caretShift],\n        value: newValue\n      },\n      data: data.replace(pseudoSeparatorsRE, firstDateEndSeparator)\n    };\n  };\n}\n\n/**\n * Convert full width numbers like １, ２ to half width numbers 1, 2\n */\nfunction createFullWidthToHalfWidthPreprocessor() {\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    return {\n      elementState: {\n        selection,\n        value: toHalfWidthNumber(value)\n      },\n      data: toHalfWidthNumber(data)\n    };\n  };\n}\nfunction createTimeMaskExpression(mode) {\n  return Array.from(mode.replace(' AA', '')).map(char => TIME_FIXED_CHARACTERS.includes(char) ? char : /\\d/).concat(mode.includes('AA') ? [CHAR_NO_BREAK_SPACE, /[AP]/i, /M/i] : []);\n}\nfunction padTimeSegments(timeSegments, pad) {\n  return Object.fromEntries(Object.entries(timeSegments).map(([segmentName, segmentValue]) => [segmentName, pad(String(segmentValue), TIME_SEGMENT_VALUE_LENGTHS[segmentName])]));\n}\nfunction padStartTimeSegments(timeSegments) {\n  return padTimeSegments(timeSegments, (value, length) => value.padStart(length, '0'));\n}\nconst SEGMENT_FULL_NAME = {\n  HH: 'hours',\n  MM: 'minutes',\n  SS: 'seconds',\n  MSS: 'milliseconds'\n};\n/**\n * @param timeString can be with/without fixed characters\n */\nfunction parseTimeString(timeString, timeMode) {\n  const onlyDigits = timeString.replaceAll(/\\D+/g, '');\n  let offset = 0;\n  return Object.fromEntries(timeMode.split(/\\W/).filter(segmentAbbr => SEGMENT_FULL_NAME[segmentAbbr]).map(segmentAbbr => {\n    const segmentValue = onlyDigits.slice(offset, offset + segmentAbbr.length);\n    offset += segmentAbbr.length;\n    return [SEGMENT_FULL_NAME[segmentAbbr], segmentValue];\n  }));\n}\nconst LEADING_NON_DIGITS = /^\\D*/;\nconst TRAILING_NON_DIGITS = /\\D*$/;\nfunction toTimeString({\n  hours = '',\n  minutes = '',\n  seconds = '',\n  milliseconds = ''\n}) {\n  return `${hours}:${minutes}:${seconds}.${milliseconds}`.replace(LEADING_NON_DIGITS, '').replace(TRAILING_NON_DIGITS, '');\n}\nconst TRAILING_TIME_SEGMENT_SEPARATOR_REG = new RegExp(`[${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]$`);\n/**\n * Pads invalid time segment with zero to make it valid.\n * @example 00:|00 => Type 9 (too much for the first digit of minutes) => 00:09|\n * @example |19:00 => Type 2 (29 - invalid value for hours) => 2|0:00\n */\nfunction enrichTimeSegmentsWithZeroes({\n  value,\n  selection\n}, {\n  mode,\n  timeSegmentMaxValues = DEFAULT_TIME_SEGMENT_MAX_VALUES\n}) {\n  const [from, to] = selection;\n  const parsedTime = parseTimeString(value, mode);\n  const possibleTimeSegments = Object.entries(parsedTime);\n  const paddedMaxValues = padStartTimeSegments(timeSegmentMaxValues);\n  const validatedTimeSegments = {};\n  let paddedZeroes = 0;\n  for (const [segmentName, segmentValue] of possibleTimeSegments) {\n    const maxSegmentValue = paddedMaxValues[segmentName];\n    const {\n      validatedSegmentValue,\n      prefixedZeroesCount\n    } = padWithZeroesUntilValid(segmentValue, String(maxSegmentValue));\n    paddedZeroes += prefixedZeroesCount;\n    validatedTimeSegments[segmentName] = validatedSegmentValue;\n  }\n  // trailing segment separators or meridiem characters\n  const [trailingNonDigitCharacters = ''] = value.match(/\\D+$/g) || [];\n  const validatedTimeString = toTimeString(validatedTimeSegments) + trailingNonDigitCharacters;\n  const addedDateSegmentSeparators = Math.max(validatedTimeString.length - value.length, 0);\n  let newFrom = from + paddedZeroes + addedDateSegmentSeparators;\n  let newTo = to + paddedZeroes + addedDateSegmentSeparators;\n  if (newFrom === newTo && paddedZeroes &&\n  // if next character after cursor is time segment separator\n  validatedTimeString.slice(0, newTo + 1).match(TRAILING_TIME_SEGMENT_SEPARATOR_REG)) {\n    newFrom++;\n    newTo++;\n  }\n  return {\n    value: validatedTimeString,\n    selection: [newFrom, newTo]\n  };\n}\nfunction padEndTimeSegments(timeSegments) {\n  return padTimeSegments(timeSegments, (value, length) => value.padEnd(length, '0'));\n}\n\n/**\n * Prevent insertion if any time segment will become invalid\n * (and even zero padding won't help with it).\n * @example 2|0:00 => Type 9 => 2|0:00\n */\nfunction createInvalidTimeSegmentInsertionPreprocessor({\n  timeMode,\n  timeSegmentMinValues = DEFAULT_TIME_SEGMENT_MIN_VALUES,\n  timeSegmentMaxValues = DEFAULT_TIME_SEGMENT_MAX_VALUES,\n  parseValue = x => ({\n    timeString: x\n  })\n}) {\n  const invalidCharsRegExp = new RegExp(`[^\\\\d${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]+`);\n  return ({\n    elementState,\n    data\n  }, actionType) => {\n    if (actionType !== 'insert') {\n      return {\n        elementState,\n        data\n      };\n    }\n    const {\n      value,\n      selection\n    } = elementState;\n    const [from, rawTo] = selection;\n    const newCharacters = data.replace(invalidCharsRegExp, '');\n    const to = rawTo + newCharacters.length; // to be conformed with `overwriteMode: replace`\n    const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n    const {\n      timeString,\n      restValue = ''\n    } = parseValue(newPossibleValue);\n    const timeSegments = Object.entries(parseTimeString(timeString, timeMode));\n    let offset = restValue.length;\n    for (const [segmentName, stringifiedSegmentValue] of timeSegments) {\n      const minSegmentValue = timeSegmentMinValues[segmentName];\n      const maxSegmentValue = timeSegmentMaxValues[segmentName];\n      const segmentValue = Number(stringifiedSegmentValue);\n      const lastSegmentDigitIndex = offset + TIME_SEGMENT_VALUE_LENGTHS[segmentName];\n      if (lastSegmentDigitIndex >= from && lastSegmentDigitIndex <= to && segmentValue !== clamp(segmentValue, minSegmentValue, maxSegmentValue)) {\n        return {\n          elementState,\n          data: ''\n        }; // prevent insertion\n      }\n      offset += stringifiedSegmentValue.length +\n      // any time segment separator\n      1;\n    }\n    return {\n      elementState,\n      data\n    };\n  };\n}\nfunction createMeridiemPreprocessor(timeMode) {\n  if (!timeMode.includes('AA')) {\n    return identity;\n  }\n  const mainMeridiemCharRE = /^[AP]$/gi;\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const newValue = value.toUpperCase();\n    const newData = data.toUpperCase();\n    if (newValue.match(ALL_MERIDIEM_CHARACTERS_RE) && newData.match(mainMeridiemCharRE)) {\n      return {\n        elementState: {\n          value: newValue.replaceAll(ALL_MERIDIEM_CHARACTERS_RE, ''),\n          selection\n        },\n        data: `${newData}M`\n      };\n    }\n    return {\n      elementState: {\n        selection,\n        value: newValue\n      },\n      data: newData\n    };\n  };\n}\nfunction createMeridiemPostprocessor(timeMode) {\n  if (!timeMode.includes('AA')) {\n    return identity;\n  }\n  return ({\n    value,\n    selection\n  }, initialElementState) => {\n    if (!value.match(ANY_MERIDIEM_CHARACTER_RE) || value.match(ALL_MERIDIEM_CHARACTERS_RE)) {\n      return {\n        value,\n        selection\n      };\n    }\n    const [from, to] = selection;\n    // any meridiem character was deleted\n    if (initialElementState.value.match(ALL_MERIDIEM_CHARACTERS_RE)) {\n      const newValue = value.replace(ANY_MERIDIEM_CHARACTER_RE, '');\n      return {\n        value: newValue,\n        selection: [Math.min(from, newValue.length), Math.min(to, newValue.length)]\n      };\n    }\n    const fullMeridiem = `${CHAR_NO_BREAK_SPACE}${value.includes('P') ? 'P' : 'A'}M`;\n    const newValue = value.replace(ANY_MERIDIEM_CHARACTER_RE, x => x !== CHAR_NO_BREAK_SPACE ? fullMeridiem : x);\n    return {\n      value: newValue,\n      selection: to >= newValue.indexOf(fullMeridiem) ? [newValue.length, newValue.length] : selection\n    };\n  };\n}\nfunction raiseSegmentValueToMin(segments, fullMode) {\n  const segmentsLength = getDateSegmentValueLength(fullMode);\n  return Object.fromEntries(Object.entries(segments).map(([key, value]) => {\n    const segmentLength = segmentsLength[key];\n    return [key, value.length === segmentLength && /^0+$/.exec(value) ? '1'.padStart(segmentLength, '0') : value];\n  }));\n}\nfunction createMinMaxDatePostprocessor({\n  dateModeTemplate,\n  min = DEFAULT_MIN_DATE,\n  max = DEFAULT_MAX_DATE,\n  rangeSeparator = '',\n  dateSegmentSeparator = '.'\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    const endsWithRangeSeparator = rangeSeparator && value.endsWith(rangeSeparator);\n    const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n    let validatedValue = '';\n    for (const dateString of dateStrings) {\n      validatedValue += validatedValue ? rangeSeparator : '';\n      const parsedDate = parseDateString(dateString, dateModeTemplate);\n      if (!isDateStringComplete(dateString, dateModeTemplate)) {\n        const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n        const fixedValue = toDateString(fixedDate, {\n          dateMode: dateModeTemplate\n        });\n        const tail = dateString.endsWith(dateSegmentSeparator) ? dateSegmentSeparator : '';\n        validatedValue += fixedValue + tail;\n        continue;\n      }\n      const date = segmentsToDate(parsedDate);\n      const clampedDate = clamp(date, min, max);\n      validatedValue += toDateString(dateToSegments(clampedDate), {\n        dateMode: dateModeTemplate\n      });\n    }\n    return {\n      selection,\n      value: validatedValue + (endsWithRangeSeparator ? rangeSeparator : '')\n    };\n  };\n}\nfunction normalizeDatePreprocessor({\n  dateModeTemplate,\n  dateSegmentsSeparator,\n  rangeSeparator = '',\n  dateTimeSeparator = DATE_TIME_SEPARATOR\n}) {\n  return ({\n    elementState,\n    data\n  }) => {\n    var _a;\n    const separator = rangeSeparator ? new RegExp(`${rangeSeparator}|-`) : dateTimeSeparator;\n    const possibleDates = data.split(separator);\n    const dates = data.includes(dateTimeSeparator) ? [(_a = possibleDates[0]) !== null && _a !== void 0 ? _a : ''] : possibleDates;\n    if (dates.every(date => date.trim().split(/\\D/).filter(Boolean).length === dateModeTemplate.split(dateSegmentsSeparator).length)) {\n      const newData = dates.map(date => normalizeDateString(date, dateModeTemplate, dateSegmentsSeparator)).join(rangeSeparator);\n      return {\n        elementState,\n        data: `${newData}${data.includes(dateTimeSeparator) ? dateTimeSeparator + possibleDates[1] || '' : ''}`\n      };\n    }\n    return {\n      elementState,\n      data\n    };\n  };\n}\nfunction normalizeDateString(dateString, template, separator) {\n  const dateSegments = dateString.split(/\\D/).filter(Boolean);\n  const templateSegments = template.split(separator);\n  const normalizedSegments = dateSegments.map((segment, index) => {\n    var _a, _b;\n    return index === templateSegments.length - 1 ? segment : segment.padStart((_b = (_a = templateSegments[index]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0, '0');\n  });\n  return normalizedSegments.join(separator);\n}\nfunction maskitoPostfixPostprocessorGenerator(postfix) {\n  const postfixRE = new RegExp(`${escapeRegExp(postfix)}$`);\n  return postfix ? ({\n    value,\n    selection\n  }, initialElementState) => {\n    if (!value && !initialElementState.value.endsWith(postfix)) {\n      // cases when developer wants input to be empty (programmatically)\n      return {\n        value,\n        selection\n      };\n    }\n    if (!value.endsWith(postfix) && !initialElementState.value.endsWith(postfix)) {\n      return {\n        selection,\n        value: value + postfix\n      };\n    }\n    const initialValueBeforePostfix = initialElementState.value.replace(postfixRE, '');\n    const postfixWasModified = initialElementState.selection[1] >= initialValueBeforePostfix.length;\n    const alreadyExistedValueBeforePostfix = findCommonBeginningSubstr(initialValueBeforePostfix, value);\n    return {\n      selection,\n      value: Array.from(postfix).reverse().reduce((newValue, char, index) => {\n        const i = newValue.length - 1 - index;\n        const isInitiallyMirroredChar = alreadyExistedValueBeforePostfix[i] === char && postfixWasModified;\n        return newValue[i] !== char || isInitiallyMirroredChar ? newValue.slice(0, i + 1) + char + newValue.slice(i + 1) : newValue;\n      }, value)\n    };\n  } : identity;\n}\nfunction maskitoPrefixPostprocessorGenerator(prefix) {\n  return prefix ? ({\n    value,\n    selection\n  }, initialElementState) => {\n    if (value.startsWith(prefix) ||\n    // already valid\n    !value && !initialElementState.value.startsWith(prefix) // cases when developer wants input to be empty\n    ) {\n      return {\n        value,\n        selection\n      };\n    }\n    const [from, to] = selection;\n    const prefixedValue = Array.from(prefix).reduce((modifiedValue, char, i) => modifiedValue[i] === char ? modifiedValue : modifiedValue.slice(0, i) + char + modifiedValue.slice(i), value);\n    const addedCharsCount = prefixedValue.length - value.length;\n    return {\n      selection: [from + addedCharsCount, to + addedCharsCount],\n      value: prefixedValue\n    };\n  } : identity;\n}\nfunction createValidDatePreprocessor({\n  dateModeTemplate,\n  dateSegmentsSeparator,\n  rangeSeparator = ''\n}) {\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    if (data === dateSegmentsSeparator) {\n      return {\n        elementState,\n        data: selection[0] === value.length ? data : ''\n      };\n    }\n    const newCharacters = data.replaceAll(new RegExp(`[^\\\\d${escapeRegExp(dateSegmentsSeparator)}${rangeSeparator}]`, 'g'), '');\n    if (!newCharacters) {\n      return {\n        elementState,\n        data: ''\n      };\n    }\n    const [from, rawTo] = selection;\n    let to = rawTo + data.length;\n    const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n    const dateStrings = parseDateRangeString(newPossibleValue, dateModeTemplate, rangeSeparator);\n    let validatedValue = '';\n    const hasRangeSeparator = Boolean(rangeSeparator) && newPossibleValue.includes(rangeSeparator);\n    for (const dateString of dateStrings) {\n      const {\n        validatedDateString,\n        updatedSelection\n      } = validateDateString({\n        dateString,\n        dateModeTemplate,\n        dateSegmentsSeparator,\n        offset: validatedValue.length,\n        selection: [from, to]\n      });\n      if (dateString && !validatedDateString) {\n        return {\n          elementState,\n          data: ''\n        }; // prevent changes\n      }\n      to = updatedSelection[1];\n      validatedValue += hasRangeSeparator && !validatedValue ? validatedDateString + rangeSeparator : validatedDateString;\n    }\n    const newData = validatedValue.slice(from, to);\n    return {\n      elementState: {\n        selection,\n        value: validatedValue.slice(0, from) + newData.split(dateSegmentsSeparator).map(segment => '0'.repeat(segment.length)).join(dateSegmentsSeparator) + validatedValue.slice(to)\n      },\n      data: newData\n    };\n  };\n}\nfunction maskitoEventHandler(name, handler, eventListenerOptions) {\n  return (element, maskitoOptions) => {\n    const listener = () => handler(element, maskitoOptions);\n    element.addEventListener(name, listener, eventListenerOptions);\n    return () => element.removeEventListener(name, listener, eventListenerOptions);\n  };\n}\nfunction maskitoAddOnFocusPlugin(value) {\n  return maskitoEventHandler('focus', element => {\n    if (!element.value) {\n      maskitoUpdateElement(element, value);\n    }\n  });\n}\nfunction maskitoCaretGuard(guard) {\n  return element => {\n    const document = element.ownerDocument;\n    let isPointerDown = 0;\n    const onPointerDown = () => isPointerDown++;\n    const onPointerUp = () => {\n      isPointerDown = Math.max(--isPointerDown, 0);\n    };\n    const listener = () => {\n      var _a, _b;\n      if (!element.matches(':focus')) {\n        return;\n      }\n      if (isPointerDown) {\n        return document.addEventListener('mouseup', listener, {\n          once: true,\n          passive: true\n        });\n      }\n      const start = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n      const end = (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0;\n      const [fromLimit, toLimit] = guard(element.value, [start, end]);\n      if (fromLimit > start || toLimit < end) {\n        element.setSelectionRange(clamp(start, fromLimit, toLimit), clamp(end, fromLimit, toLimit));\n      }\n    };\n    document.addEventListener('selectionchange', listener, {\n      passive: true\n    });\n    element.addEventListener('mousedown', onPointerDown, {\n      passive: true\n    });\n    document.addEventListener('mouseup', onPointerUp, {\n      passive: true\n    });\n    return () => {\n      document.removeEventListener('selectionchange', listener);\n      document.removeEventListener('mousedown', onPointerDown);\n      document.removeEventListener('mouseup', onPointerUp);\n    };\n  };\n}\nconst maskitoRejectEvent = element => {\n  const listener = () => {\n    const value = element.value;\n    element.addEventListener('beforeinput', event => {\n      if (event.defaultPrevented && value === element.value) {\n        element.dispatchEvent(new CustomEvent('maskitoReject', {\n          bubbles: true\n        }));\n      }\n    }, {\n      once: true\n    });\n  };\n  element.addEventListener('beforeinput', listener, true);\n  return () => element.removeEventListener('beforeinput', listener, true);\n};\nfunction maskitoRemoveOnBlurPlugin(value) {\n  return maskitoEventHandler('blur', element => {\n    if (element.value === value) {\n      maskitoUpdateElement(element, '');\n    }\n  });\n}\nfunction createMeridiemSteppingPlugin(meridiemStartIndex) {\n  if (meridiemStartIndex < 0) {\n    return () => {};\n  }\n  return element => {\n    const listener = event => {\n      const caretIndex = Number(element.selectionStart);\n      const value = element.value.toUpperCase();\n      if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown' || caretIndex < meridiemStartIndex) {\n        return;\n      }\n      event.preventDefault();\n      // eslint-disable-next-line no-nested-ternary\n      const meridiemMainCharacter = value.includes('A') ? 'P' : value.includes('P') || event.key === 'ArrowUp' ? 'A' : 'P';\n      const newMeridiem = `${CHAR_NO_BREAK_SPACE}${meridiemMainCharacter}M`;\n      maskitoUpdateElement(element, {\n        value: value.length === meridiemStartIndex ? value + newMeridiem : value.replace(ANY_MERIDIEM_CHARACTER_RE, newMeridiem),\n        selection: [caretIndex, caretIndex]\n      });\n    };\n    element.addEventListener('keydown', listener);\n    return () => element.removeEventListener('keydown', listener);\n  };\n}\nconst noop = () => {};\nfunction createTimeSegmentsSteppingPlugin({\n  step,\n  fullMode,\n  timeSegmentMaxValues\n}) {\n  const segmentsIndexes = createTimeSegmentsIndexes(fullMode);\n  return step <= 0 ? noop : element => {\n    const listener = event => {\n      var _a;\n      if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {\n        return;\n      }\n      event.preventDefault();\n      const selectionStart = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n      const activeSegment = getActiveSegment({\n        segmentsIndexes,\n        selectionStart\n      });\n      if (!activeSegment) {\n        return;\n      }\n      const updatedValue = updateSegmentValue({\n        selection: segmentsIndexes.get(activeSegment),\n        value: element.value,\n        toAdd: event.key === 'ArrowUp' ? step : -step,\n        max: timeSegmentMaxValues[activeSegment]\n      });\n      maskitoUpdateElement(element, {\n        value: updatedValue,\n        selection: [selectionStart, selectionStart]\n      });\n    };\n    element.addEventListener('keydown', listener);\n    return () => element.removeEventListener('keydown', listener);\n  };\n}\nfunction createTimeSegmentsIndexes(fullMode) {\n  return new Map([['hours', getSegmentRange(fullMode, 'HH')], ['milliseconds', getSegmentRange(fullMode, 'MSS')], ['minutes', getSegmentRange(fullMode, 'MM')], ['seconds', getSegmentRange(fullMode, 'SS')]]);\n}\nfunction getSegmentRange(mode, segment) {\n  const index = mode.indexOf(segment);\n  return index === -1 ? [-1, -1] : [index, index + segment.length];\n}\nfunction getActiveSegment({\n  segmentsIndexes,\n  selectionStart\n}) {\n  for (const [segmentName, segmentRange] of segmentsIndexes.entries()) {\n    const [from, to] = segmentRange;\n    if (from <= selectionStart && selectionStart <= to) {\n      return segmentName;\n    }\n  }\n  return null;\n}\nfunction updateSegmentValue({\n  selection,\n  value,\n  toAdd,\n  max\n}) {\n  const [from, to] = selection;\n  const segmentValue = Number(value.slice(from, to).padEnd(to - from, '0'));\n  const newSegmentValue = mod(segmentValue + toAdd, max + 1);\n  return value.slice(0, from) + String(newSegmentValue).padStart(to - from, '0') + value.slice(to, value.length);\n}\nfunction mod(value, max) {\n  if (value < 0) {\n    value += Math.floor(Math.abs(value) / max + 1) * max;\n  }\n  return value % max;\n}\nfunction maskitoWithPlaceholder(placeholder, focusedOnly = false) {\n  let lastClearValue = '';\n  let action = 'validation';\n  const removePlaceholder = value => {\n    for (let i = value.length - 1; i >= lastClearValue.length; i--) {\n      if (value[i] !== placeholder[i]) {\n        return value.slice(0, i + 1);\n      }\n    }\n    return value.slice(0, lastClearValue.length);\n  };\n  const plugins = [maskitoCaretGuard(value => [0, removePlaceholder(value).length])];\n  let focused = false;\n  if (focusedOnly) {\n    const focus = maskitoEventHandler('focus', element => {\n      focused = true;\n      maskitoUpdateElement(element, element.value + placeholder.slice(element.value.length));\n    }, {\n      capture: true\n    });\n    const blur = maskitoEventHandler('blur', element => {\n      focused = false;\n      maskitoUpdateElement(element, removePlaceholder(element.value));\n    }, {\n      capture: true\n    });\n    plugins.push(focus, blur);\n  }\n  return {\n    plugins,\n    removePlaceholder,\n    preprocessors: [({\n      elementState,\n      data\n    }, actionType) => {\n      action = actionType;\n      const {\n        value,\n        selection\n      } = elementState;\n      return {\n        elementState: {\n          selection,\n          value: removePlaceholder(value)\n        },\n        data\n      };\n    }],\n    postprocessors: [({\n      value,\n      selection\n    }, initialElementState) => {\n      lastClearValue = value;\n      const justPlaceholderRemoval = value + placeholder.slice(value.length, initialElementState.value.length) === initialElementState.value;\n      if (action === 'validation' && justPlaceholderRemoval) {\n        /**\n         * If `value` still equals to `initialElementState.value`,\n         * then it means that value is patched programmatically (from Maskito's plugin or externally).\n         * In this case, we don't want to mutate value and automatically add/remove placeholder.\n         * ___\n         * For example, developer wants to remove manually placeholder (+ do something else with value) on blur.\n         * Without this condition, placeholder will be unexpectedly added again.\n         */\n        return {\n          selection,\n          value: initialElementState.value\n        };\n      }\n      const newValue = focused || !focusedOnly ? value + placeholder.slice(value.length) : value;\n      if (newValue === initialElementState.value && action === 'deleteBackward') {\n        const [caretIndex] = initialElementState.selection;\n        return {\n          value: newValue,\n          selection: [caretIndex, caretIndex]\n        };\n      }\n      return {\n        value: newValue,\n        selection\n      };\n    }]\n  };\n}\nfunction createZeroPlaceholdersPreprocessor() {\n  return ({\n    elementState\n  }, actionType) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    if (!value || isLastChar(value, selection)) {\n      return {\n        elementState\n      };\n    }\n    const [from, to] = selection;\n    const zeroes = value.slice(from, to).replaceAll(/\\d/g, '0');\n    const newValue = value.slice(0, from) + zeroes + value.slice(to);\n    if (!zeroes.replaceAll(/\\D/g, '')) {\n      return {\n        elementState\n      };\n    }\n    if (actionType === 'validation' || actionType === 'insert' && from === to) {\n      return {\n        elementState: {\n          selection,\n          value: newValue\n        }\n      };\n    }\n    return {\n      elementState: {\n        selection: actionType === 'deleteBackward' || actionType === 'insert' ? [from, from] : [to, to],\n        value: newValue\n      }\n    };\n  };\n}\nfunction isLastChar(value, [_, to]) {\n  return to === value.length;\n}\nfunction maskitoDateOptionsGenerator({\n  mode,\n  separator = '.',\n  max,\n  min\n}) {\n  const dateModeTemplate = mode.split('/').join(separator);\n  return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), {\n    mask: Array.from(dateModeTemplate).map(char => separator.includes(char) ? char : /\\d/),\n    overwriteMode: 'replace',\n    preprocessors: [createFullWidthToHalfWidthPreprocessor(), createZeroPlaceholdersPreprocessor(), normalizeDatePreprocessor({\n      dateModeTemplate,\n      dateSegmentsSeparator: separator\n    }), createValidDatePreprocessor({\n      dateModeTemplate,\n      dateSegmentsSeparator: separator\n    })],\n    postprocessors: [createDateSegmentsZeroPaddingPostprocessor({\n      dateModeTemplate,\n      dateSegmentSeparator: separator,\n      splitFn: value => ({\n        dateStrings: [value]\n      }),\n      uniteFn: ([dateString = '']) => dateString\n    }), createMinMaxDatePostprocessor({\n      min,\n      max,\n      dateModeTemplate,\n      dateSegmentSeparator: separator\n    })]\n  });\n}\nconst POSSIBLE_DATE_RANGE_SEPARATOR = [CHAR_HYPHEN, CHAR_EN_DASH, CHAR_EM_DASH, CHAR_MINUS, CHAR_JP_HYPHEN];\nfunction createMinMaxRangeLengthPostprocessor({\n  dateModeTemplate,\n  rangeSeparator,\n  minLength,\n  maxLength,\n  max = DEFAULT_MAX_DATE\n}) {\n  if (isEmpty(minLength) && isEmpty(maxLength)) {\n    return identity;\n  }\n  return ({\n    value,\n    selection\n  }) => {\n    const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n    if (dateStrings.length !== 2 || dateStrings.some(date => !isDateStringComplete(date, dateModeTemplate))) {\n      return {\n        value,\n        selection\n      };\n    }\n    const [fromDate, toDate] = dateStrings.map(dateString => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n    if (!fromDate || !toDate) {\n      return {\n        value,\n        selection\n      };\n    }\n    const minDistantToDate = appendDate(fromDate, Object.assign(Object.assign({}, minLength), {\n      // 06.02.2023 - 07.02.2023 => {minLength: {day: 3}} => 06.02.2023 - 08.02.2023\n      // \"from\"-day is included in the range\n      day: (minLength === null || minLength === void 0 ? void 0 : minLength.day) && minLength.day - 1\n    }));\n    const maxDistantToDate = !isEmpty(maxLength) ? appendDate(fromDate, Object.assign(Object.assign({}, maxLength), {\n      day: (maxLength === null || maxLength === void 0 ? void 0 : maxLength.day) && maxLength.day - 1\n    })) : max;\n    const minLengthClampedToDate = clamp(toDate, minDistantToDate, max);\n    const minMaxLengthClampedToDate = minLengthClampedToDate > maxDistantToDate ? maxDistantToDate : minLengthClampedToDate;\n    return {\n      selection,\n      value: dateStrings[0] + rangeSeparator + toDateString(dateToSegments(minMaxLengthClampedToDate), {\n        dateMode: dateModeTemplate\n      })\n    };\n  };\n}\nfunction createSwapDatesPostprocessor({\n  dateModeTemplate,\n  rangeSeparator\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n    const isDateRangeComplete = dateStrings.length === 2 && dateStrings.every(date => isDateStringComplete(date, dateModeTemplate));\n    const [from, to] = selection;\n    const caretAtTheEnd = from >= value.length;\n    const allValueSelected = from === 0 && to >= value.length; // dropping text inside with a pointer\n    if (!(caretAtTheEnd || allValueSelected) || !isDateRangeComplete) {\n      return {\n        value,\n        selection\n      };\n    }\n    const [fromDate, toDate] = dateStrings.map(dateString => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n    return {\n      selection,\n      value: fromDate && toDate && fromDate > toDate ? dateStrings.reverse().join(rangeSeparator) : value\n    };\n  };\n}\nfunction maskitoDateRangeOptionsGenerator({\n  mode,\n  min,\n  max,\n  minLength,\n  maxLength,\n  dateSeparator = '.',\n  rangeSeparator = `${CHAR_NO_BREAK_SPACE}${CHAR_EN_DASH}${CHAR_NO_BREAK_SPACE}`\n}) {\n  const dateModeTemplate = mode.split('/').join(dateSeparator);\n  const dateMask = Array.from(dateModeTemplate).map(char => dateSeparator.includes(char) ? char : /\\d/);\n  return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), {\n    mask: [...dateMask, ...Array.from(rangeSeparator), ...dateMask],\n    overwriteMode: 'replace',\n    preprocessors: [createFullWidthToHalfWidthPreprocessor(), createFirstDateEndSeparatorPreprocessor({\n      dateModeTemplate,\n      dateSegmentSeparator: dateSeparator,\n      firstDateEndSeparator: rangeSeparator,\n      pseudoFirstDateEndSeparators: POSSIBLE_DATE_RANGE_SEPARATOR\n    }), createZeroPlaceholdersPreprocessor(), normalizeDatePreprocessor({\n      dateModeTemplate,\n      rangeSeparator,\n      dateSegmentsSeparator: dateSeparator\n    }), createValidDatePreprocessor({\n      dateModeTemplate,\n      rangeSeparator,\n      dateSegmentsSeparator: dateSeparator\n    })],\n    postprocessors: [createDateSegmentsZeroPaddingPostprocessor({\n      dateModeTemplate,\n      dateSegmentSeparator: dateSeparator,\n      splitFn: value => ({\n        dateStrings: parseDateRangeString(value, dateModeTemplate, rangeSeparator)\n      }),\n      uniteFn: (validatedDateStrings, initialValue) => validatedDateStrings.reduce((acc, dateString, dateIndex) => acc + dateString + (!dateIndex && initialValue.includes(rangeSeparator) ? rangeSeparator : ''), '')\n    }), createMinMaxDatePostprocessor({\n      min,\n      max,\n      dateModeTemplate,\n      rangeSeparator,\n      dateSegmentSeparator: dateSeparator\n    }), createMinMaxRangeLengthPostprocessor({\n      dateModeTemplate,\n      minLength,\n      maxLength,\n      max,\n      rangeSeparator\n    }), createSwapDatesPostprocessor({\n      dateModeTemplate,\n      rangeSeparator\n    })]\n  });\n}\nfunction isDateTimeStringComplete(dateTimeString, {\n  dateMode,\n  timeMode,\n  dateTimeSeparator = DATE_TIME_SEPARATOR\n}) {\n  var _a;\n  return dateTimeString.length >= dateMode.length + timeMode.length + dateTimeSeparator.length && ((_a = dateTimeString.split(dateTimeSeparator)[0]) !== null && _a !== void 0 ? _a : '').split(/\\D/).every(segment => !/^0+$/.exec(segment));\n}\nconst NON_DIGIT_PLACEHOLDER_RE = /[^dmy]/g;\nconst LEADING_NON_DIGIT_RE = /^\\D*/;\nfunction parseDateTimeString(dateTime, dateModeTemplate) {\n  const dateDigitsCount = dateModeTemplate.replaceAll(NON_DIGIT_PLACEHOLDER_RE, '').length;\n  const [date = ''] = new RegExp(`(\\\\d[^\\\\d]*){0,${dateDigitsCount - 1}}\\\\d?`).exec(dateTime) || [];\n  const [dateTimeSeparator = ''] = LEADING_NON_DIGIT_RE.exec(dateTime.slice(date.length)) || [];\n  return [date, dateTime.slice(date.length + dateTimeSeparator.length)];\n}\nfunction createMinMaxDateTimePostprocessor({\n  dateModeTemplate,\n  timeMode,\n  min = DEFAULT_MIN_DATE,\n  max = DEFAULT_MAX_DATE,\n  dateTimeSeparator\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    const [dateString, timeString] = parseDateTimeString(value, dateModeTemplate);\n    const parsedDate = parseDateString(dateString, dateModeTemplate);\n    const parsedTime = parseTimeString(timeString, timeMode);\n    if (!isDateTimeStringComplete(value, {\n      dateMode: dateModeTemplate,\n      timeMode,\n      dateTimeSeparator\n    })) {\n      const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n      const {\n        year,\n        month,\n        day\n      } = isDateStringComplete(dateString, dateModeTemplate) ? dateToSegments(clamp(segmentsToDate(fixedDate), min, max)) : fixedDate;\n      const fixedValue = toDateString(Object.assign({\n        year,\n        month,\n        day\n      }, parsedTime), {\n        dateMode: dateModeTemplate,\n        dateTimeSeparator,\n        timeMode\n      });\n      const tail = value.slice(fixedValue.length);\n      return {\n        selection,\n        value: fixedValue + tail\n      };\n    }\n    const date = segmentsToDate(parsedDate, parsedTime);\n    const clampedDate = clamp(date, min, max);\n    // trailing segment separators or meridiem characters\n    const [trailingNonDigitCharacters = ''] = value.match(/\\D+$/g) || [];\n    const validatedValue = toDateString(dateToSegments(clampedDate), {\n      dateMode: dateModeTemplate,\n      dateTimeSeparator,\n      timeMode\n    }) + trailingNonDigitCharacters;\n    return {\n      selection,\n      value: validatedValue\n    };\n  };\n}\nfunction createValidDateTimePreprocessor({\n  dateModeTemplate,\n  dateSegmentsSeparator,\n  dateTimeSeparator,\n  timeMode,\n  timeSegmentMaxValues\n}) {\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    if (data === dateSegmentsSeparator) {\n      return {\n        elementState,\n        data: selection[0] === value.length ? data : ''\n      };\n    }\n    const newCharacters = data.replaceAll(/\\D/g, '');\n    if (!newCharacters) {\n      return {\n        elementState,\n        data\n      };\n    }\n    const [from, rawTo] = selection;\n    let to = rawTo + data.length;\n    const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n    const [dateString, timeString] = parseDateTimeString(newPossibleValue, dateModeTemplate);\n    let validatedValue = '';\n    const hasDateTimeSeparator = newPossibleValue.includes(dateTimeSeparator);\n    const {\n      validatedDateString,\n      updatedSelection\n    } = validateDateString({\n      dateString,\n      dateSegmentsSeparator,\n      dateModeTemplate,\n      offset: 0,\n      selection: [from, to]\n    });\n    if (dateString && !validatedDateString) {\n      return {\n        elementState,\n        data: ''\n      }; // prevent changes\n    }\n    to = updatedSelection[1];\n    validatedValue += validatedDateString;\n    const updatedTimeState = enrichTimeSegmentsWithZeroes({\n      value: timeString,\n      selection: [from, to]\n    }, {\n      mode: timeMode,\n      timeSegmentMaxValues\n    });\n    to = updatedTimeState.selection[1];\n    validatedValue += hasDateTimeSeparator ? dateTimeSeparator + updatedTimeState.value : updatedTimeState.value;\n    const newData = validatedValue.slice(from, to);\n    return {\n      elementState: {\n        selection,\n        value: validatedValue.slice(0, from) + newData.split(dateSegmentsSeparator).map(segment => '0'.repeat(segment.length)).join(dateSegmentsSeparator) + validatedValue.slice(to)\n      },\n      data: newData\n    };\n  };\n}\nfunction maskitoDateTimeOptionsGenerator({\n  dateMode,\n  timeMode,\n  dateSeparator = '.',\n  min,\n  max,\n  dateTimeSeparator = DATE_TIME_SEPARATOR,\n  timeStep = 0\n}) {\n  const hasMeridiem = timeMode.includes('AA');\n  const dateModeTemplate = dateMode.split('/').join(dateSeparator);\n  const timeSegmentMaxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), hasMeridiem ? {\n    hours: 12\n  } : {});\n  const timeSegmentMinValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MIN_VALUES), hasMeridiem ? {\n    hours: 1\n  } : {});\n  const fullMode = `${dateModeTemplate}${dateTimeSeparator}${timeMode}`;\n  return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), {\n    mask: [...Array.from(dateModeTemplate).map(char => dateSeparator.includes(char) ? char : /\\d/), ...dateTimeSeparator.split(''), ...createTimeMaskExpression(timeMode)],\n    overwriteMode: 'replace',\n    preprocessors: [createFullWidthToHalfWidthPreprocessor(), createColonConvertPreprocessor(), createFirstDateEndSeparatorPreprocessor({\n      dateModeTemplate,\n      dateSegmentSeparator: dateSeparator,\n      firstDateEndSeparator: dateTimeSeparator,\n      pseudoFirstDateEndSeparators: dateTimeSeparator.split('')\n    }), createZeroPlaceholdersPreprocessor(), createMeridiemPreprocessor(timeMode), normalizeDatePreprocessor({\n      dateModeTemplate,\n      dateSegmentsSeparator: dateSeparator,\n      dateTimeSeparator\n    }), createInvalidTimeSegmentInsertionPreprocessor({\n      timeMode,\n      timeSegmentMinValues,\n      timeSegmentMaxValues,\n      parseValue: x => {\n        const [dateString, timeString] = parseDateTimeString(x, dateModeTemplate);\n        return {\n          timeString,\n          restValue: dateString + dateTimeSeparator\n        };\n      }\n    }), createValidDateTimePreprocessor({\n      dateModeTemplate,\n      dateSegmentsSeparator: dateSeparator,\n      dateTimeSeparator,\n      timeMode,\n      timeSegmentMaxValues\n    })],\n    postprocessors: [createMeridiemPostprocessor(timeMode), createDateSegmentsZeroPaddingPostprocessor({\n      dateModeTemplate,\n      dateSegmentSeparator: dateSeparator,\n      splitFn: value => {\n        const [dateString, timeString] = parseDateTimeString(value, dateModeTemplate);\n        return {\n          dateStrings: [dateString],\n          restPart: timeString\n        };\n      },\n      uniteFn: ([validatedDateString], initialValue) => validatedDateString + (initialValue.includes(dateTimeSeparator) ? dateTimeSeparator : '')\n    }), createMinMaxDateTimePostprocessor({\n      min,\n      max,\n      dateModeTemplate,\n      timeMode,\n      dateTimeSeparator\n    })],\n    plugins: [createTimeSegmentsSteppingPlugin({\n      step: timeStep,\n      fullMode,\n      timeSegmentMaxValues: DEFAULT_TIME_SEGMENT_MAX_VALUES\n    }), createMeridiemSteppingPlugin(fullMode.indexOf('AA'))]\n  });\n}\n\n/**\n * It drops prefix and postfix from data\n * Needed for case, when prefix or postfix contain decimalSeparator, to ignore it in resulting number\n * @example User pastes '{prefix}123.45{postfix}' => 123.45\n */\nfunction createAffixesFilterPreprocessor({\n  prefix,\n  postfix\n}) {\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      cleanValue: cleanData\n    } = extractAffixes(data, {\n      prefix,\n      postfix\n    });\n    return {\n      elementState,\n      data: cleanData\n    };\n  };\n}\nfunction generateMaskExpression({\n  decimalSeparator,\n  isNegativeAllowed,\n  precision,\n  thousandSeparator,\n  prefix,\n  postfix,\n  decimalPseudoSeparators = [],\n  pseudoMinuses = [],\n  minusSign\n}) {\n  const computedPrefix = computeAllOptionalCharsRegExp(prefix);\n  const digit = String.raw`\\d`;\n  const optionalMinus = isNegativeAllowed ? `[${minusSign}${pseudoMinuses.map(x => `\\\\${x}`).join('')}]?` : '';\n  const integerPart = thousandSeparator ? `[${digit}${escapeRegExp(thousandSeparator).replaceAll(/\\s/g, String.raw`\\s`)}]*` : `[${digit}]*`;\n  const precisionPart = Number.isFinite(precision) ? precision : '';\n  const decimalPart = precision > 0 ? `([${escapeRegExp(decimalSeparator)}${decimalPseudoSeparators.map(escapeRegExp).join('')}]${digit}{0,${precisionPart}})?` : '';\n  const computedPostfix = computeAllOptionalCharsRegExp(postfix);\n  return new RegExp(`^${computedPrefix}${optionalMinus}${integerPart}${decimalPart}${computedPostfix}$`);\n}\nfunction computeAllOptionalCharsRegExp(str) {\n  return str ? `${str.split('').map(char => `${escapeRegExp(char)}?`).join('')}` : '';\n}\nfunction maskitoParseNumber(maskedNumber, decimalSeparator = '.') {\n  const hasNegativeSign = !!new RegExp(`^\\\\D*[${CHAR_MINUS}\\\\${CHAR_HYPHEN}${CHAR_EN_DASH}${CHAR_EM_DASH}${CHAR_JP_HYPHEN}]`).exec(maskedNumber);\n  const escapedDecimalSeparator = escapeRegExp(decimalSeparator);\n  const unmaskedNumber = maskedNumber\n  // drop all decimal separators not followed by a digit\n  .replaceAll(new RegExp(`${escapedDecimalSeparator}(?!\\\\d)`, 'g'), '')\n  // drop all non-digit characters except decimal separator\n  .replaceAll(new RegExp(`[^\\\\d${escapedDecimalSeparator}]`, 'g'), '').replace(decimalSeparator, '.');\n  if (unmaskedNumber) {\n    const sign = hasNegativeSign ? CHAR_HYPHEN : '';\n    return Number(`${sign}${unmaskedNumber}`);\n  }\n  return NaN;\n}\n\n/**\n * Convert number to string with replacing exponent part on decimals\n *\n * @param value the number\n * @return string representation of a number\n */\nfunction stringifyNumberWithoutExp(value) {\n  var _a;\n  const valueAsString = String(value);\n  const [numberPart = '', expPart] = valueAsString.split('e-');\n  let valueWithoutExp = valueAsString;\n  if (expPart) {\n    const [, fractionalPart] = numberPart.split('.');\n    const decimalDigits = Number(expPart) + ((_a = fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) !== null && _a !== void 0 ? _a : 0);\n    valueWithoutExp = value.toFixed(decimalDigits);\n  }\n  return valueWithoutExp;\n}\nfunction toNumberParts(value, {\n  decimalSeparator,\n  minusSign\n}) {\n  const [integerWithMinus = '', decimalPart = ''] = value.split(decimalSeparator);\n  const escapedMinus = escapeRegExp(minusSign);\n  const [, minus = '', integerPart = ''] = new RegExp(`^(?:[^\\\\d${escapedMinus}])?(${escapedMinus})?(.*)`).exec(integerWithMinus) || [];\n  return {\n    minus,\n    integerPart,\n    decimalPart\n  };\n}\nfunction validateDecimalPseudoSeparators({\n  decimalSeparator,\n  thousandSeparator,\n  decimalPseudoSeparators = DEFAULT_DECIMAL_PSEUDO_SEPARATORS\n}) {\n  return decimalPseudoSeparators.filter(char => char !== thousandSeparator && char !== decimalSeparator);\n}\n\n/**\n * If `decimalZeroPadding` is `true`, it pads decimal part with zeroes\n * (until number of digits after decimalSeparator is equal to the `precision`).\n * @example 1,42 => (`precision` is equal to 4) => 1,4200.\n */\nfunction createDecimalZeroPaddingPostprocessor({\n  decimalSeparator,\n  precision,\n  decimalZeroPadding,\n  prefix,\n  postfix\n}) {\n  if (precision <= 0 || !decimalZeroPadding) {\n    return identity;\n  }\n  return ({\n    value,\n    selection\n  }) => {\n    const {\n      cleanValue,\n      extractedPrefix,\n      extractedPostfix\n    } = extractAffixes(value, {\n      prefix,\n      postfix\n    });\n    if (Number.isNaN(maskitoParseNumber(cleanValue, decimalSeparator))) {\n      return {\n        value,\n        selection\n      };\n    }\n    const [integerPart, decimalPart = ''] = cleanValue.split(decimalSeparator);\n    return {\n      value: extractedPrefix + integerPart + decimalSeparator + decimalPart.padEnd(precision, '0') + extractedPostfix,\n      selection\n    };\n  };\n}\n\n/**\n * Make textfield empty if there is no integer part and all decimal digits are zeroes.\n * @example 0|,00 => Backspace => Empty.\n * @example -0|,00 => Backspace => -.\n * @example ,42| => Backspace x2 => ,|00 => Backspace => Empty\n */\nfunction emptyPostprocessor({\n  prefix,\n  postfix,\n  decimalSeparator,\n  minusSign\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    const [caretIndex] = selection;\n    const {\n      cleanValue,\n      extractedPrefix,\n      extractedPostfix\n    } = extractAffixes(value, {\n      prefix,\n      postfix\n    });\n    const {\n      minus,\n      integerPart,\n      decimalPart\n    } = toNumberParts(cleanValue, {\n      decimalSeparator,\n      minusSign\n    });\n    const aloneDecimalSeparator = !integerPart && !decimalPart && cleanValue.includes(decimalSeparator);\n    if (!integerPart && !Number(decimalPart) && caretIndex === (minus + extractedPrefix).length || aloneDecimalSeparator) {\n      return {\n        selection,\n        value: extractedPrefix + minus + extractedPostfix\n      };\n    }\n    return {\n      value,\n      selection\n    };\n  };\n}\n\n/**\n * This preprocessor works only once at initialization phase (when `new Maskito(...)` is executed).\n * This preprocessor helps to avoid conflicts during transition from one mask to another (for the same input).\n * For example, the developer changes postfix (or other mask's props) during run-time.\n * ```\n * let maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' year'});\n * // [3 seconds later]\n * maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' years'});\n * ```\n */\nfunction createInitializationOnlyPreprocessor({\n  decimalSeparator,\n  decimalPseudoSeparators,\n  pseudoMinuses,\n  prefix,\n  postfix,\n  minusSign\n}) {\n  let isInitializationPhase = true;\n  const cleanNumberMask = generateMaskExpression({\n    decimalSeparator,\n    decimalPseudoSeparators,\n    pseudoMinuses,\n    prefix: '',\n    postfix: '',\n    thousandSeparator: '',\n    precision: Infinity,\n    isNegativeAllowed: true,\n    minusSign\n  });\n  return ({\n    elementState,\n    data\n  }) => {\n    if (!isInitializationPhase) {\n      return {\n        elementState,\n        data\n      };\n    }\n    isInitializationPhase = false;\n    const {\n      value,\n      selection\n    } = elementState;\n    const [from, to] = selection;\n    const {\n      extractedPrefix,\n      cleanValue,\n      extractedPostfix\n    } = extractAffixes(value, {\n      prefix,\n      postfix\n    });\n    const cleanState = maskitoTransform({\n      selection: [Math.max(from - extractedPrefix.length, 0), clamp(to - extractedPrefix.length, 0, cleanValue.length)],\n      value: cleanValue\n    }, {\n      mask: cleanNumberMask\n    });\n    const [cleanFrom, cleanTo] = cleanState.selection;\n    return {\n      elementState: {\n        selection: [cleanFrom + extractedPrefix.length, cleanTo + extractedPrefix.length],\n        value: extractedPrefix + cleanState.value + extractedPostfix\n      },\n      data\n    };\n  };\n}\n\n/**\n * It removes repeated leading zeroes for integer part.\n * @example 0,|00005 => Backspace => |5\n * @example -0,|00005 => Backspace => -|5\n * @example User types \"000000\" => 0|\n * @example 0| => User types \"5\" => 5|\n */\nfunction createLeadingZeroesValidationPostprocessor({\n  decimalSeparator,\n  thousandSeparator,\n  prefix,\n  postfix\n}) {\n  const trimLeadingZeroes = value => {\n    const escapedThousandSeparator = escapeRegExp(thousandSeparator);\n    return value.replace(\n    // all leading zeroes followed by another zero\n    new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=0)`), '$1').replace(\n    // zero followed by not-zero digit\n    new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=[1-9])`), '$1');\n  };\n  const countTrimmedZeroesBefore = (value, index) => {\n    const valueBefore = value.slice(0, index);\n    const followedByZero = value.slice(index).startsWith('0');\n    return valueBefore.length - trimLeadingZeroes(valueBefore).length + (followedByZero ? 1 : 0);\n  };\n  return ({\n    value,\n    selection\n  }) => {\n    const [from, to] = selection;\n    const {\n      cleanValue,\n      extractedPrefix,\n      extractedPostfix\n    } = extractAffixes(value, {\n      prefix,\n      postfix\n    });\n    const hasDecimalSeparator = cleanValue.includes(decimalSeparator);\n    const [integerPart = '', decimalPart = ''] = cleanValue.split(decimalSeparator);\n    const zeroTrimmedIntegerPart = trimLeadingZeroes(integerPart);\n    if (integerPart === zeroTrimmedIntegerPart) {\n      return {\n        value,\n        selection\n      };\n    }\n    const newFrom = from - countTrimmedZeroesBefore(value, from);\n    const newTo = to - countTrimmedZeroesBefore(value, to);\n    return {\n      value: extractedPrefix + zeroTrimmedIntegerPart + (hasDecimalSeparator ? decimalSeparator : '') + decimalPart + extractedPostfix,\n      selection: [Math.max(newFrom, 0), Math.max(newTo, 0)]\n    };\n  };\n}\n\n/**\n * This postprocessor is connected with {@link createMinMaxPlugin}:\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\n */\nfunction createMinMaxPostprocessor({\n  min,\n  max,\n  decimalSeparator,\n  minusSign\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    const parsedNumber = maskitoParseNumber(value, decimalSeparator);\n    const limitedValue =\n    /**\n     * We cannot limit lower bound if user enters positive number.\n     * The same for upper bound and negative number.\n     * ___\n     * @example (min = 5)\n     * Empty input => Without this condition user cannot type 42 (the first digit will be rejected)\n     * ___\n     * @example (max = -10)\n     * Value is -10 => Without this condition user cannot delete 0 to enter another digit\n     */\n    parsedNumber > 0 ? Math.min(parsedNumber, max) : Math.max(parsedNumber, min);\n    if (parsedNumber && limitedValue !== parsedNumber) {\n      const newValue = `${limitedValue}`.replace('.', decimalSeparator).replace(CHAR_HYPHEN, minusSign);\n      return {\n        value: newValue,\n        selection: [newValue.length, newValue.length]\n      };\n    }\n    return {\n      value,\n      selection\n    };\n  };\n}\n\n/**\n * Manage caret-navigation when user \"deletes\" non-removable digits or separators\n * @example 1,|42 => Backspace => 1|,42 (only if `decimalZeroPadding` is `true`)\n * @example 1|,42 => Delete => 1,|42 (only if `decimalZeroPadding` is `true`)\n * @example 0,|00 => Delete => 0,0|0 (only if `decimalZeroPadding` is `true`)\n * @example 1 |000 => Backspace => 1| 000 (always)\n */\nfunction createNonRemovableCharsDeletionPreprocessor({\n  decimalSeparator,\n  thousandSeparator,\n  decimalZeroPadding\n}) {\n  return ({\n    elementState,\n    data\n  }, actionType) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const [from, to] = selection;\n    const selectedCharacters = value.slice(from, to);\n    const nonRemovableSeparators = decimalZeroPadding ? [decimalSeparator, thousandSeparator] : [thousandSeparator];\n    const areNonRemovableZeroesSelected = decimalZeroPadding && from > value.indexOf(decimalSeparator) && Boolean(selectedCharacters.match(/^0+$/gi));\n    if (actionType !== 'deleteBackward' && actionType !== 'deleteForward' || !nonRemovableSeparators.includes(selectedCharacters) && !areNonRemovableZeroesSelected) {\n      return {\n        elementState,\n        data\n      };\n    }\n    return {\n      elementState: {\n        value,\n        selection: actionType === 'deleteForward' ? [to, to] : [from, from]\n      },\n      data\n    };\n  };\n}\n\n/**\n * It pads integer part with zero if user types decimal separator (for empty input).\n * @example Empty input => User types \",\" (decimal separator) => 0,|\n */\nfunction createNotEmptyIntegerPartPreprocessor({\n  decimalSeparator,\n  precision,\n  prefix,\n  postfix\n}) {\n  const startWithDecimalSepRegExp = new RegExp(`^\\\\D*${escapeRegExp(decimalSeparator)}`);\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const {\n      cleanValue,\n      extractedPrefix\n    } = extractAffixes(value, {\n      prefix,\n      postfix\n    });\n    const [from, to] = selection;\n    const cleanFrom = clamp(from - extractedPrefix.length, 0, cleanValue.length);\n    const cleanTo = clamp(to - extractedPrefix.length, 0, cleanValue.length);\n    if (precision <= 0 || cleanValue.slice(0, cleanFrom).includes(decimalSeparator) || cleanValue.slice(cleanTo).includes(decimalSeparator) || !data.match(startWithDecimalSepRegExp)) {\n      return {\n        elementState,\n        data\n      };\n    }\n    const digitsBeforeCursor = /\\d+/.exec(cleanValue.slice(0, cleanFrom));\n    return {\n      elementState,\n      data: digitsBeforeCursor ? data : `0${data}`\n    };\n  };\n}\n\n/**\n * It replaces pseudo characters with valid one.\n * @example User types '.' (but separator is equal to comma) => dot is replaced with comma.\n * @example User types hyphen / en-dash / em-dash => it is replaced with minus.\n */\nfunction createPseudoCharactersPreprocessor({\n  validCharacter,\n  pseudoCharacters,\n  prefix,\n  postfix\n}) {\n  const pseudoCharactersRegExp = new RegExp(`[${pseudoCharacters.join('')}]`, 'gi');\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const {\n      cleanValue,\n      extractedPostfix,\n      extractedPrefix\n    } = extractAffixes(value, {\n      prefix,\n      postfix\n    });\n    return {\n      elementState: {\n        selection,\n        value: extractedPrefix + cleanValue.replace(pseudoCharactersRegExp, validCharacter) + extractedPostfix\n      },\n      data: data.replace(pseudoCharactersRegExp, validCharacter)\n    };\n  };\n}\n\n/**\n * It rejects new typed decimal separator if it already exists in text field.\n * Behaviour is similar to native <input type=\"number\"> (Chrome).\n * @example 1|23,45 => Press comma (decimal separator) => 1|23,45 (do nothing).\n */\nfunction createRepeatedDecimalSeparatorPreprocessor({\n  decimalSeparator,\n  prefix,\n  postfix\n}) {\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const [from, to] = selection;\n    const {\n      cleanValue\n    } = extractAffixes(value, {\n      prefix,\n      postfix\n    });\n    return {\n      elementState,\n      data: !cleanValue.includes(decimalSeparator) || value.slice(from, to + 1).includes(decimalSeparator) ? data : data.replaceAll(new RegExp(escapeRegExp(decimalSeparator), 'gi'), '')\n    };\n  };\n}\n\n/**\n * It adds symbol for separating thousands.\n * @example 1000000 => (thousandSeparator is equal to space) => 1 000 000.\n */\nfunction createThousandSeparatorPostprocessor({\n  thousandSeparator,\n  decimalSeparator,\n  prefix,\n  postfix,\n  minusSign\n}) {\n  if (!thousandSeparator) {\n    return identity;\n  }\n  const isAllSpaces = (...chars) => chars.every(x => /\\s/.test(x));\n  return ({\n    value,\n    selection\n  }) => {\n    const [initialFrom, initialTo] = selection;\n    let [from, to] = selection;\n    const {\n      cleanValue,\n      extractedPostfix,\n      extractedPrefix\n    } = extractAffixes(value, {\n      prefix,\n      postfix\n    });\n    const {\n      minus,\n      integerPart,\n      decimalPart\n    } = toNumberParts(cleanValue, {\n      decimalSeparator,\n      minusSign\n    });\n    const deletedChars = cleanValue.length - (minus + integerPart + (cleanValue.includes(decimalSeparator) ? decimalSeparator + decimalPart : '')).length;\n    if (deletedChars > 0 && initialFrom && initialFrom <= deletedChars) {\n      from -= deletedChars;\n    }\n    if (deletedChars > 0 && initialTo && initialTo <= deletedChars) {\n      to -= deletedChars;\n    }\n    const processedIntegerPart = Array.from(integerPart).reduceRight((formattedValuePart, char, i) => {\n      const isLeadingThousandSeparator = !i && char === thousandSeparator;\n      const isPositionForSeparator = !isLeadingThousandSeparator && Boolean(formattedValuePart.length) && (formattedValuePart.length + 1) % 4 === 0;\n      const isSeparator = char === thousandSeparator || isAllSpaces(char, thousandSeparator);\n      if (isPositionForSeparator && isSeparator) {\n        return thousandSeparator + formattedValuePart;\n      }\n      if (!isPositionForSeparator && isSeparator) {\n        if (i && i <= initialFrom) {\n          from--;\n        }\n        if (i && i <= initialTo) {\n          to--;\n        }\n        return formattedValuePart;\n      }\n      if (!isPositionForSeparator) {\n        return char + formattedValuePart;\n      }\n      if (i < initialFrom) {\n        from++;\n      }\n      if (i < initialTo) {\n        to++;\n      }\n      return char + thousandSeparator + formattedValuePart;\n    }, '');\n    return {\n      value: extractedPrefix + minus + processedIntegerPart + (cleanValue.includes(decimalSeparator) ? decimalSeparator : '') + decimalPart + extractedPostfix,\n      selection: [from, to]\n    };\n  };\n}\n\n/**\n * It drops decimal part if precision is zero.\n * @example User pastes '123.45' (but precision is zero) => 123\n */\nfunction createZeroPrecisionPreprocessor({\n  precision,\n  decimalSeparator,\n  prefix,\n  postfix\n}) {\n  if (precision > 0) {\n    return identity;\n  }\n  const decimalPartRegExp = new RegExp(`${escapeRegExp(decimalSeparator)}.*$`, 'g');\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const {\n      cleanValue,\n      extractedPrefix,\n      extractedPostfix\n    } = extractAffixes(value, {\n      prefix,\n      postfix\n    });\n    const [from, to] = selection;\n    const newValue = extractedPrefix + cleanValue.replace(decimalPartRegExp, '') + extractedPostfix;\n    return {\n      elementState: {\n        selection: [Math.min(from, newValue.length), Math.min(to, newValue.length)],\n        value: newValue\n      },\n      data: data.replace(decimalPartRegExp, '')\n    };\n  };\n}\nconst DUMMY_SELECTION = [0, 0];\n/**\n * It removes repeated leading zeroes for integer part on blur-event.\n * @example 000000 => blur => 0\n * @example 00005 => blur => 5\n */\nfunction createLeadingZeroesValidationPlugin({\n  decimalSeparator,\n  thousandSeparator,\n  prefix,\n  postfix\n}) {\n  const dropRepeatedLeadingZeroes = createLeadingZeroesValidationPostprocessor({\n    decimalSeparator,\n    thousandSeparator,\n    prefix,\n    postfix\n  });\n  return maskitoEventHandler('blur', element => {\n    const newValue = dropRepeatedLeadingZeroes({\n      value: element.value,\n      selection: DUMMY_SELECTION\n    }, {\n      value: '',\n      selection: DUMMY_SELECTION\n    }).value;\n    maskitoUpdateElement(element, newValue);\n  }, {\n    capture: true\n  });\n}\n\n/**\n * This plugin is connected with {@link createMinMaxPostprocessor}:\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\n */\nfunction createMinMaxPlugin({\n  min,\n  max,\n  decimalSeparator\n}) {\n  return maskitoEventHandler('blur', (element, options) => {\n    const parsedNumber = maskitoParseNumber(element.value, decimalSeparator);\n    const clampedNumber = clamp(parsedNumber, min, max);\n    if (!Number.isNaN(parsedNumber) && parsedNumber !== clampedNumber) {\n      maskitoUpdateElement(element, maskitoTransform(stringifyNumberWithoutExp(clampedNumber), options));\n    }\n  }, {\n    capture: true\n  });\n}\n\n/**\n * It pads EMPTY integer part with zero if decimal parts exists.\n * It works on blur event only!\n * @example 1|,23 => Backspace => Blur => 0,23\n */\nfunction createNotEmptyIntegerPlugin({\n  decimalSeparator,\n  prefix,\n  postfix\n}) {\n  return maskitoEventHandler('blur', element => {\n    const {\n      cleanValue,\n      extractedPostfix,\n      extractedPrefix\n    } = extractAffixes(element.value, {\n      prefix,\n      postfix\n    });\n    const newValue = extractedPrefix + cleanValue.replace(new RegExp(`^(\\\\D+)?${escapeRegExp(decimalSeparator)}`), `$10${decimalSeparator}`) + extractedPostfix;\n    maskitoUpdateElement(element, newValue);\n  }, {\n    capture: true\n  });\n}\nfunction maskitoNumberOptionsGenerator({\n  max = Number.MAX_SAFE_INTEGER,\n  min = Number.MIN_SAFE_INTEGER,\n  precision = 0,\n  thousandSeparator = CHAR_NO_BREAK_SPACE,\n  decimalSeparator = '.',\n  decimalPseudoSeparators,\n  decimalZeroPadding = false,\n  prefix: unsafePrefix = '',\n  postfix = '',\n  minusSign = CHAR_MINUS\n} = {}) {\n  const pseudoMinuses = [CHAR_HYPHEN, CHAR_EN_DASH, CHAR_EM_DASH, CHAR_JP_HYPHEN, CHAR_MINUS].filter(char => char !== thousandSeparator && char !== decimalSeparator && char !== minusSign);\n  const validatedDecimalPseudoSeparators = validateDecimalPseudoSeparators({\n    decimalSeparator,\n    thousandSeparator,\n    decimalPseudoSeparators\n  });\n  const prefix = unsafePrefix.endsWith(decimalSeparator) && precision > 0 ? `${unsafePrefix}${CHAR_ZERO_WIDTH_SPACE}` : unsafePrefix;\n  return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), {\n    mask: generateMaskExpression({\n      decimalSeparator,\n      precision,\n      thousandSeparator,\n      prefix,\n      postfix,\n      isNegativeAllowed: min < 0,\n      minusSign\n    }),\n    preprocessors: [createFullWidthToHalfWidthPreprocessor(), createInitializationOnlyPreprocessor({\n      decimalSeparator,\n      decimalPseudoSeparators: validatedDecimalPseudoSeparators,\n      pseudoMinuses,\n      prefix,\n      postfix,\n      minusSign\n    }), createAffixesFilterPreprocessor({\n      prefix,\n      postfix\n    }), createPseudoCharactersPreprocessor({\n      validCharacter: minusSign,\n      pseudoCharacters: pseudoMinuses,\n      prefix,\n      postfix\n    }), createPseudoCharactersPreprocessor({\n      validCharacter: decimalSeparator,\n      pseudoCharacters: validatedDecimalPseudoSeparators,\n      prefix,\n      postfix\n    }), createNotEmptyIntegerPartPreprocessor({\n      decimalSeparator,\n      precision,\n      prefix,\n      postfix\n    }), createNonRemovableCharsDeletionPreprocessor({\n      decimalSeparator,\n      decimalZeroPadding,\n      thousandSeparator\n    }), createZeroPrecisionPreprocessor({\n      precision,\n      decimalSeparator,\n      prefix,\n      postfix\n    }), createRepeatedDecimalSeparatorPreprocessor({\n      decimalSeparator,\n      prefix,\n      postfix\n    })],\n    postprocessors: [createMinMaxPostprocessor({\n      decimalSeparator,\n      min,\n      max,\n      minusSign\n    }), maskitoPrefixPostprocessorGenerator(prefix), maskitoPostfixPostprocessorGenerator(postfix), createThousandSeparatorPostprocessor({\n      decimalSeparator,\n      thousandSeparator,\n      prefix,\n      postfix,\n      minusSign\n    }), createDecimalZeroPaddingPostprocessor({\n      decimalSeparator,\n      decimalZeroPadding,\n      precision,\n      prefix,\n      postfix\n    }), emptyPostprocessor({\n      prefix,\n      postfix,\n      decimalSeparator,\n      minusSign\n    })],\n    plugins: [createLeadingZeroesValidationPlugin({\n      decimalSeparator,\n      thousandSeparator,\n      prefix,\n      postfix\n    }), createNotEmptyIntegerPlugin({\n      decimalSeparator,\n      prefix,\n      postfix\n    }), createMinMaxPlugin({\n      min,\n      max,\n      decimalSeparator\n    })],\n    overwriteMode: decimalZeroPadding ? ({\n      value,\n      selection: [from]\n    }) => from <= value.indexOf(decimalSeparator) ? 'shift' : 'replace' : 'shift'\n  });\n}\nfunction maskitoTimeOptionsGenerator({\n  mode,\n  timeSegmentMaxValues = {},\n  timeSegmentMinValues = {},\n  step = 0\n}) {\n  const hasMeridiem = mode.includes('AA');\n  const enrichedTimeSegmentMaxValues = Object.assign(Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), hasMeridiem ? {\n    hours: 12\n  } : {}), timeSegmentMaxValues);\n  const enrichedTimeSegmentMinValues = Object.assign(Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MIN_VALUES), hasMeridiem ? {\n    hours: 1\n  } : {}), timeSegmentMinValues);\n  return {\n    mask: createTimeMaskExpression(mode),\n    preprocessors: [createFullWidthToHalfWidthPreprocessor(), createColonConvertPreprocessor(), createZeroPlaceholdersPreprocessor(), createMeridiemPreprocessor(mode), createInvalidTimeSegmentInsertionPreprocessor({\n      timeMode: mode,\n      timeSegmentMinValues: enrichedTimeSegmentMinValues,\n      timeSegmentMaxValues: enrichedTimeSegmentMaxValues\n    })],\n    postprocessors: [createMeridiemPostprocessor(mode), elementState => enrichTimeSegmentsWithZeroes(elementState, {\n      mode,\n      timeSegmentMaxValues: enrichedTimeSegmentMaxValues\n    })],\n    plugins: [createTimeSegmentsSteppingPlugin({\n      fullMode: mode,\n      step,\n      timeSegmentMaxValues: enrichedTimeSegmentMaxValues\n    }), createMeridiemSteppingPlugin(mode.indexOf('AA'))],\n    overwriteMode: 'replace'\n  };\n}\n\n/**\n * Converts a formatted time string to milliseconds based on the given `options.mode`.\n *\n * @param maskedTime a formatted time string by {@link maskitoTimeOptionsGenerator} or {@link maskitoStringifyTime}\n * @param params\n */\nfunction maskitoParseTime(maskedTime, {\n  mode,\n  timeSegmentMaxValues = {}\n}) {\n  var _a, _b, _c, _d;\n  const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n  const msInSecond = maxValues.milliseconds + 1;\n  const msInMinute = (maxValues.seconds + 1) * msInSecond;\n  const msInHour = (maxValues.minutes + 1) * msInMinute;\n  const parsedTime = padEndTimeSegments(parseTimeString(maskedTime, mode));\n  return Number((_a = parsedTime.hours) !== null && _a !== void 0 ? _a : '') * msInHour + Number((_b = parsedTime.minutes) !== null && _b !== void 0 ? _b : '') * msInMinute + Number((_c = parsedTime.seconds) !== null && _c !== void 0 ? _c : '') * msInSecond + Number((_d = parsedTime.milliseconds) !== null && _d !== void 0 ? _d : '');\n}\n\n/**\n * Converts milliseconds to a formatted time string based on the given `options.mode`.\n *\n * @param milliseconds unsigned integer milliseconds\n * @param params\n */\nfunction maskitoStringifyTime(milliseconds, {\n  mode,\n  timeSegmentMaxValues = {}\n}) {\n  const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n  const msInSecond = maxValues.milliseconds + 1;\n  const msInMinute = (maxValues.seconds + 1) * msInSecond;\n  const msInHour = (maxValues.minutes + 1) * msInMinute;\n  const hours = Math.trunc(milliseconds / msInHour);\n  milliseconds -= hours * msInHour;\n  const minutes = Math.trunc(milliseconds / msInMinute);\n  milliseconds -= minutes * msInMinute;\n  const seconds = Math.trunc(milliseconds / msInSecond);\n  milliseconds -= seconds * msInSecond;\n  const result = padStartTimeSegments({\n    hours,\n    minutes,\n    seconds,\n    milliseconds\n  });\n  return mode.replaceAll(/H+/g, result.hours).replaceAll('MSS', result.milliseconds).replaceAll(/M+/g, result.minutes).replaceAll(/S+/g, result.seconds);\n}\nexport { maskitoAddOnFocusPlugin, maskitoCaretGuard, maskitoDateOptionsGenerator, maskitoDateRangeOptionsGenerator, maskitoDateTimeOptionsGenerator, maskitoEventHandler, maskitoNumberOptionsGenerator, maskitoParseNumber, maskitoParseTime, maskitoPostfixPostprocessorGenerator, maskitoPrefixPostprocessorGenerator, maskitoRejectEvent, maskitoRemoveOnBlurPlugin, maskitoStringifyTime, maskitoTimeOptionsGenerator, maskitoWithPlaceholder };","map":{"version":3,"names":["maskitoUpdateElement","MASKITO_DEFAULT_OPTIONS","maskitoTransform","clamp","value","min","max","clampedValue","Math","Number","Date","countDigits","str","replaceAll","length","appendDate","initialDate","day","month","year","date","setDate","getDate","setMonth","getMonth","setFullYear","getFullYear","getDateSegmentValueLength","dateString","_a","_b","_c","_d","_e","_f","match","dateToSegments","String","padStart","hours","getHours","minutes","getMinutes","seconds","getSeconds","milliseconds","getMilliseconds","getFirstCompleteDate","dateModeTemplate","digitsInDate","completeDate","RegExp","exec","isDateStringComplete","split","every","segment","parseDateRangeString","dateRange","rangeSeparator","replace","parseDateString","fullMode","cleanMode","onlyDigitsDate","dateSegments","slice","indexOf","lastIndexOf","Object","fromEntries","entries","filter","_","Boolean","sort","a","b","toLowerCase","segmentsToDate","parsedDate","parsedTime","_g","DATE_TIME_SEPARATOR","toDateString","dateMode","dateTimeSeparator","timeMode","safeYear","DATE_SEGMENTS_MAX_VALUES","DEFAULT_DECIMAL_PSEUDO_SEPARATORS","DEFAULT_MIN_DATE","DEFAULT_MAX_DATE","DEFAULT_TIME_SEGMENT_MAX_VALUES","DEFAULT_TIME_SEGMENT_MIN_VALUES","CHAR_NO_BREAK_SPACE","CHAR_ZERO_WIDTH_SPACE","CHAR_EN_DASH","CHAR_EM_DASH","CHAR_HYPHEN","CHAR_MINUS","CHAR_JP_HYPHEN","CHAR_COLON","CHAR_JP_COLON","ANY_MERIDIEM_CHARACTER_RE","ALL_MERIDIEM_CHARACTERS_RE","TIME_FIXED_CHARACTERS","TIME_SEGMENT_VALUE_LENGTHS","validateDateString","dateSegmentsSeparator","offset","selection","from","to","validatedDateSegments","segmentName","segmentValue","validatedDate","maxSegmentValue","fantomSeparator","lastSegmentDigitIndex","isLastSegmentDigitAdded","validatedDateString","updatedSelection","addedDateSegmentSeparators","reRegExpChar","reHasRegExpChar","source","escapeRegExp","test","raw","extractAffixes","prefix","postfix","prefixRegExp","postfixRegExp","extractedPrefix","extractedPostfix","cleanValue","findCommonBeginningSubstr","res","i","identity","x","isEmpty","entity","keys","ALL_ZEROES_RE","padWithZeroesUntilValid","paddedMaxValue","prefixedZeroesCount","paddedSegmentValue","padEnd","validatedSegmentValue","endsWith","valueWithoutLastChar","toHalfWidthColon","fullWidthColon","toHalfWidthNumber","fullWidthNumber","s","fromCharCode","charCodeAt","createColonConvertPreprocessor","elementState","data","createDateSegmentsZeroPaddingPostprocessor","dateSegmentSeparator","splitFn","uniteFn","dateStrings","restPart","validatedDateStrings","caretShift","forEach","reduce","acc","assign","push","validatedValue","createFirstDateEndSeparatorPreprocessor","firstDateEndSeparator","pseudoFirstDateEndSeparators","firstCompleteDate","pseudoSeparators","includes","pseudoSeparatorsRE","join","newValue","createFullWidthToHalfWidthPreprocessor","createTimeMaskExpression","mode","Array","map","char","concat","padTimeSegments","timeSegments","pad","padStartTimeSegments","SEGMENT_FULL_NAME","HH","MM","SS","MSS","parseTimeString","timeString","onlyDigits","segmentAbbr","LEADING_NON_DIGITS","TRAILING_NON_DIGITS","toTimeString","TRAILING_TIME_SEGMENT_SEPARATOR_REG","enrichTimeSegmentsWithZeroes","timeSegmentMaxValues","possibleTimeSegments","paddedMaxValues","validatedTimeSegments","paddedZeroes","trailingNonDigitCharacters","validatedTimeString","newFrom","newTo","padEndTimeSegments","createInvalidTimeSegmentInsertionPreprocessor","timeSegmentMinValues","parseValue","invalidCharsRegExp","actionType","rawTo","newCharacters","newPossibleValue","restValue","stringifiedSegmentValue","minSegmentValue","createMeridiemPreprocessor","mainMeridiemCharRE","toUpperCase","newData","createMeridiemPostprocessor","initialElementState","fullMeridiem","raiseSegmentValueToMin","segments","segmentsLength","key","segmentLength","createMinMaxDatePostprocessor","endsWithRangeSeparator","fixedDate","fixedValue","tail","clampedDate","normalizeDatePreprocessor","separator","possibleDates","dates","trim","normalizeDateString","template","templateSegments","normalizedSegments","index","maskitoPostfixPostprocessorGenerator","postfixRE","initialValueBeforePostfix","postfixWasModified","alreadyExistedValueBeforePostfix","reverse","isInitiallyMirroredChar","maskitoPrefixPostprocessorGenerator","startsWith","prefixedValue","modifiedValue","addedCharsCount","createValidDatePreprocessor","hasRangeSeparator","repeat","maskitoEventHandler","name","handler","eventListenerOptions","element","maskitoOptions","listener","addEventListener","removeEventListener","maskitoAddOnFocusPlugin","maskitoCaretGuard","guard","document","ownerDocument","isPointerDown","onPointerDown","onPointerUp","matches","once","passive","start","selectionStart","end","selectionEnd","fromLimit","toLimit","setSelectionRange","maskitoRejectEvent","event","defaultPrevented","dispatchEvent","CustomEvent","bubbles","maskitoRemoveOnBlurPlugin","createMeridiemSteppingPlugin","meridiemStartIndex","caretIndex","preventDefault","meridiemMainCharacter","newMeridiem","noop","createTimeSegmentsSteppingPlugin","step","segmentsIndexes","createTimeSegmentsIndexes","activeSegment","getActiveSegment","updatedValue","updateSegmentValue","get","toAdd","Map","getSegmentRange","segmentRange","newSegmentValue","mod","floor","abs","maskitoWithPlaceholder","placeholder","focusedOnly","lastClearValue","action","removePlaceholder","plugins","focused","focus","capture","blur","preprocessors","postprocessors","justPlaceholderRemoval","createZeroPlaceholdersPreprocessor","isLastChar","zeroes","maskitoDateOptionsGenerator","mask","overwriteMode","POSSIBLE_DATE_RANGE_SEPARATOR","createMinMaxRangeLengthPostprocessor","minLength","maxLength","some","fromDate","toDate","minDistantToDate","maxDistantToDate","minLengthClampedToDate","minMaxLengthClampedToDate","createSwapDatesPostprocessor","isDateRangeComplete","caretAtTheEnd","allValueSelected","maskitoDateRangeOptionsGenerator","dateSeparator","dateMask","initialValue","dateIndex","isDateTimeStringComplete","dateTimeString","NON_DIGIT_PLACEHOLDER_RE","LEADING_NON_DIGIT_RE","parseDateTimeString","dateTime","dateDigitsCount","createMinMaxDateTimePostprocessor","createValidDateTimePreprocessor","hasDateTimeSeparator","updatedTimeState","maskitoDateTimeOptionsGenerator","timeStep","hasMeridiem","createAffixesFilterPreprocessor","cleanData","generateMaskExpression","decimalSeparator","isNegativeAllowed","precision","thousandSeparator","decimalPseudoSeparators","pseudoMinuses","minusSign","computedPrefix","computeAllOptionalCharsRegExp","digit","optionalMinus","integerPart","precisionPart","isFinite","decimalPart","computedPostfix","maskitoParseNumber","maskedNumber","hasNegativeSign","escapedDecimalSeparator","unmaskedNumber","sign","NaN","stringifyNumberWithoutExp","valueAsString","numberPart","expPart","valueWithoutExp","fractionalPart","decimalDigits","toFixed","toNumberParts","integerWithMinus","escapedMinus","minus","validateDecimalPseudoSeparators","createDecimalZeroPaddingPostprocessor","decimalZeroPadding","isNaN","emptyPostprocessor","aloneDecimalSeparator","createInitializationOnlyPreprocessor","isInitializationPhase","cleanNumberMask","Infinity","cleanState","cleanFrom","cleanTo","createLeadingZeroesValidationPostprocessor","trimLeadingZeroes","escapedThousandSeparator","countTrimmedZeroesBefore","valueBefore","followedByZero","hasDecimalSeparator","zeroTrimmedIntegerPart","createMinMaxPostprocessor","parsedNumber","limitedValue","createNonRemovableCharsDeletionPreprocessor","selectedCharacters","nonRemovableSeparators","areNonRemovableZeroesSelected","createNotEmptyIntegerPartPreprocessor","startWithDecimalSepRegExp","digitsBeforeCursor","createPseudoCharactersPreprocessor","validCharacter","pseudoCharacters","pseudoCharactersRegExp","createRepeatedDecimalSeparatorPreprocessor","createThousandSeparatorPostprocessor","isAllSpaces","chars","initialFrom","initialTo","deletedChars","processedIntegerPart","reduceRight","formattedValuePart","isLeadingThousandSeparator","isPositionForSeparator","isSeparator","createZeroPrecisionPreprocessor","decimalPartRegExp","DUMMY_SELECTION","createLeadingZeroesValidationPlugin","dropRepeatedLeadingZeroes","createMinMaxPlugin","options","clampedNumber","createNotEmptyIntegerPlugin","maskitoNumberOptionsGenerator","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","unsafePrefix","validatedDecimalPseudoSeparators","maskitoTimeOptionsGenerator","enrichedTimeSegmentMaxValues","enrichedTimeSegmentMinValues","maskitoParseTime","maskedTime","maxValues","msInSecond","msInMinute","msInHour","maskitoStringifyTime","trunc","result"],"sources":["C:/Users/Asus-PC/Downloads/WebLibraryNew/WebLibrary/WebLibraryApp/Frontend/node_modules/@maskito/kit/index.esm.js"],"sourcesContent":["import { maskitoUpdateElement, MASKITO_DEFAULT_OPTIONS, maskitoTransform } from '@maskito/core';\n\n/**\n * Clamps a value between two inclusive limits\n *\n * @param value\n * @param min lower limit\n * @param max upper limit\n */\nfunction clamp(value, min, max) {\n    const clampedValue = Math.min(Number(max), Math.max(Number(min), Number(value)));\n    return (value instanceof Date ? new Date(clampedValue) : clampedValue);\n}\n\nfunction countDigits(str) {\n    return str.replaceAll(/\\W/g, '').length;\n}\n\nfunction appendDate(initialDate, { day, month, year } = {}) {\n    const date = new Date(initialDate);\n    if (day) {\n        date.setDate(date.getDate() + day);\n    }\n    if (month) {\n        date.setMonth(date.getMonth() + month);\n    }\n    if (year) {\n        date.setFullYear(date.getFullYear() + year);\n    }\n    return date;\n}\n\nconst getDateSegmentValueLength = (dateString) => {\n    var _a, _b, _c, _d, _e, _f;\n    return ({\n        day: (_b = (_a = dateString.match(/d/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,\n        month: (_d = (_c = dateString.match(/m/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,\n        year: (_f = (_e = dateString.match(/y/g)) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0,\n    });\n};\n\nfunction dateToSegments(date) {\n    return {\n        day: String(date.getDate()).padStart(2, '0'),\n        month: String(date.getMonth() + 1).padStart(2, '0'),\n        year: String(date.getFullYear()).padStart(4, '0'),\n        hours: String(date.getHours()).padStart(2, '0'),\n        minutes: String(date.getMinutes()).padStart(2, '0'),\n        seconds: String(date.getSeconds()).padStart(2, '0'),\n        milliseconds: String(date.getMilliseconds()).padStart(3, '0'),\n    };\n}\n\nfunction getFirstCompleteDate(dateString, dateModeTemplate) {\n    const digitsInDate = countDigits(dateModeTemplate);\n    const [completeDate = ''] = new RegExp(`(\\\\D*\\\\d){${digitsInDate}}`).exec(dateString) || [];\n    return completeDate;\n}\n\nfunction isDateStringComplete(dateString, dateModeTemplate) {\n    if (dateString.length < dateModeTemplate.length) {\n        return false;\n    }\n    return dateString.split(/\\D/).every((segment) => !/^0+$/.exec(segment));\n}\n\nfunction parseDateRangeString(dateRange, dateModeTemplate, rangeSeparator) {\n    const digitsInDate = countDigits(dateModeTemplate);\n    return (dateRange\n        .replace(rangeSeparator, '')\n        .match(new RegExp(`(\\\\D*\\\\d[^\\\\d\\\\s]*){1,${digitsInDate}}`, 'g')) || []);\n}\n\nfunction parseDateString(dateString, fullMode) {\n    const cleanMode = fullMode.replaceAll(/[^dmy]/g, '');\n    const onlyDigitsDate = dateString.replaceAll(/\\D+/g, '');\n    const dateSegments = {\n        day: onlyDigitsDate.slice(cleanMode.indexOf('d'), cleanMode.lastIndexOf('d') + 1),\n        month: onlyDigitsDate.slice(cleanMode.indexOf('m'), cleanMode.lastIndexOf('m') + 1),\n        year: onlyDigitsDate.slice(cleanMode.indexOf('y'), cleanMode.lastIndexOf('y') + 1),\n    };\n    return Object.fromEntries(Object.entries(dateSegments)\n        .filter(([_, value]) => Boolean(value))\n        .sort(([a], [b]) => fullMode.toLowerCase().indexOf(a.slice(0, 1)) >\n        fullMode.toLowerCase().indexOf(b.slice(0, 1))\n        ? 1\n        : -1));\n}\n\nfunction segmentsToDate(parsedDate, parsedTime) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const year = ((_a = parsedDate.year) === null || _a === void 0 ? void 0 : _a.length) === 2 ? `20${parsedDate.year}` : parsedDate.year;\n    const date = new Date(Number(year !== null && year !== void 0 ? year : '0'), Number((_b = parsedDate.month) !== null && _b !== void 0 ? _b : '1') - 1, Number((_c = parsedDate.day) !== null && _c !== void 0 ? _c : '1'), Number((_d = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.hours) !== null && _d !== void 0 ? _d : '0'), Number((_e = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.minutes) !== null && _e !== void 0 ? _e : '0'), Number((_f = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.seconds) !== null && _f !== void 0 ? _f : '0'), Number((_g = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.milliseconds) !== null && _g !== void 0 ? _g : '0'));\n    // needed for years less than 1900\n    date.setFullYear(Number(year !== null && year !== void 0 ? year : '0'));\n    return date;\n}\n\nconst DATE_TIME_SEPARATOR = ', ';\n\nfunction toDateString({ day, month, year, hours, minutes, seconds, milliseconds, }, { dateMode, dateTimeSeparator = DATE_TIME_SEPARATOR, timeMode, }) {\n    var _a;\n    const safeYear = ((_a = dateMode.match(/y/g)) === null || _a === void 0 ? void 0 : _a.length) === 2 ? year === null || year === void 0 ? void 0 : year.slice(-2) : year;\n    const fullMode = dateMode + (timeMode ? dateTimeSeparator + timeMode : '');\n    return fullMode\n        .replaceAll(/d+/g, day !== null && day !== void 0 ? day : '')\n        .replaceAll(/m+/g, month !== null && month !== void 0 ? month : '')\n        .replaceAll(/y+/g, safeYear !== null && safeYear !== void 0 ? safeYear : '')\n        .replaceAll(/H+/g, hours !== null && hours !== void 0 ? hours : '')\n        .replaceAll('MSS', milliseconds !== null && milliseconds !== void 0 ? milliseconds : '')\n        .replaceAll(/M+/g, minutes !== null && minutes !== void 0 ? minutes : '')\n        .replaceAll(/S+/g, seconds !== null && seconds !== void 0 ? seconds : '')\n        .replaceAll(/^\\D+/g, '')\n        .replaceAll(/\\D+$/g, '');\n}\n\nconst DATE_SEGMENTS_MAX_VALUES = {\n    day: 31,\n    month: 12,\n    year: 9999,\n};\n\nconst DEFAULT_DECIMAL_PSEUDO_SEPARATORS = ['.', ',', 'б', 'ю'];\n\nconst DEFAULT_MIN_DATE = new Date('0001-01-01');\nconst DEFAULT_MAX_DATE = new Date('9999-12-31');\n\nconst DEFAULT_TIME_SEGMENT_MAX_VALUES = {\n    hours: 23,\n    minutes: 59,\n    seconds: 59,\n    milliseconds: 999,\n};\nconst DEFAULT_TIME_SEGMENT_MIN_VALUES = {\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    milliseconds: 0,\n};\n\n/**\n * {@link https://unicode-table.com/en/00A0/ Non-breaking space}.\n */\nconst CHAR_NO_BREAK_SPACE = '\\u00A0';\n/**\n * {@link https://symbl.cc/en/200B/ Zero width space}.\n */\nconst CHAR_ZERO_WIDTH_SPACE = '\\u200B';\n/**\n * {@link https://unicode-table.com/en/2013/ EN dash}\n * is used to indicate a range of numbers or a span of time.\n * @example 2006–2022\n */\nconst CHAR_EN_DASH = '\\u2013';\n/**\n * {@link https://unicode-table.com/en/2014/ EM dash}\n * is used to mark a break in a sentence.\n * @example Taiga UI — powerful set of open source components for Angular\n * ___\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_HYPHEN}!\n */\nconst CHAR_EM_DASH = '\\u2014';\n/**\n * {@link https://unicode-table.com/en/002D/ Hyphen (minus sign)}\n * is used to combine words.\n * @example well-behaved\n * ___\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_EM_DASH}!\n */\nconst CHAR_HYPHEN = '\\u002D';\n/**\n * {@link https://unicode-table.com/en/2212/ Minus}\n * is used as math operator symbol or before negative digits.\n * ---\n * Can be used as `&minus;`. Don't confuse with {@link CHAR_HYPHEN}\n */\nconst CHAR_MINUS = '\\u2212';\n/**\n * {@link https://symbl.cc/en/30FC/ Katakana-Hiragana Prolonged Sound Mark}\n * is used as prolonged sounds in Japanese.\n */\nconst CHAR_JP_HYPHEN = '\\u30FC';\n/**\n * {@link https://symbl.cc/en/003A/ Colon}\n * is a punctuation mark that connects parts of a text logically.\n * ---\n * is also used as separator in time.\n */\nconst CHAR_COLON = '\\u003A';\n/**\n * {@link https://symbl.cc/en/FF1A/ Full-width colon}\n * is a full-width punctuation mark used to separate parts of a text commonly in Japanese.\n */\nconst CHAR_JP_COLON = '\\uFF1A';\n\nconst ANY_MERIDIEM_CHARACTER_RE = new RegExp(`[${CHAR_NO_BREAK_SPACE}APM]+$`, 'g');\nconst ALL_MERIDIEM_CHARACTERS_RE = new RegExp(`${CHAR_NO_BREAK_SPACE}[AP]M$`, 'g');\n\nconst TIME_FIXED_CHARACTERS = [':', '.'];\n\nconst TIME_SEGMENT_VALUE_LENGTHS = {\n    hours: 2,\n    minutes: 2,\n    seconds: 2,\n    milliseconds: 3,\n};\n\nfunction validateDateString({ dateString, dateModeTemplate, dateSegmentsSeparator, offset, selection: [from, to], }) {\n    const parsedDate = parseDateString(dateString, dateModeTemplate);\n    const dateSegments = Object.entries(parsedDate);\n    const validatedDateSegments = {};\n    for (const [segmentName, segmentValue] of dateSegments) {\n        const validatedDate = toDateString(validatedDateSegments, {\n            dateMode: dateModeTemplate,\n        });\n        const maxSegmentValue = DATE_SEGMENTS_MAX_VALUES[segmentName];\n        const fantomSeparator = validatedDate.length && dateSegmentsSeparator.length;\n        const lastSegmentDigitIndex = offset +\n            validatedDate.length +\n            fantomSeparator +\n            getDateSegmentValueLength(dateModeTemplate)[segmentName];\n        const isLastSegmentDigitAdded = lastSegmentDigitIndex >= from && lastSegmentDigitIndex === to;\n        if (isLastSegmentDigitAdded && Number(segmentValue) > Number(maxSegmentValue)) {\n            // 3|1.10.2010 => Type 9 => 3|1.10.2010\n            return { validatedDateString: '', updatedSelection: [from, to] }; // prevent changes\n        }\n        if (isLastSegmentDigitAdded && Number(segmentValue) < 1) {\n            // 31.0|1.2010 => Type 0 => 31.0|1.2010\n            return { validatedDateString: '', updatedSelection: [from, to] }; // prevent changes\n        }\n        validatedDateSegments[segmentName] = segmentValue;\n    }\n    const validatedDateString = toDateString(validatedDateSegments, {\n        dateMode: dateModeTemplate,\n    });\n    const addedDateSegmentSeparators = validatedDateString.length - dateString.length;\n    return {\n        validatedDateString,\n        updatedSelection: [\n            from + addedDateSegmentSeparators,\n            to + addedDateSegmentSeparators,\n        ],\n    };\n}\n\n/**\n * Copy-pasted solution from lodash\n * @see https://lodash.com/docs/4.17.15#escapeRegExp\n */\nconst reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nconst reHasRegExpChar = new RegExp(reRegExpChar.source);\nfunction escapeRegExp(str) {\n    return str && reHasRegExpChar.test(str)\n        ? str.replaceAll(reRegExpChar, String.raw `\\$&`)\n        : str;\n}\n\nfunction extractAffixes(value, { prefix, postfix }) {\n    var _a, _b;\n    const prefixRegExp = new RegExp(`^${escapeRegExp(prefix)}`);\n    const postfixRegExp = new RegExp(`${escapeRegExp(postfix)}$`);\n    const [extractedPrefix = ''] = (_a = value.match(prefixRegExp)) !== null && _a !== void 0 ? _a : [];\n    const [extractedPostfix = ''] = (_b = value.match(postfixRegExp)) !== null && _b !== void 0 ? _b : [];\n    const cleanValue = value.replace(prefixRegExp, '').replace(postfixRegExp, '');\n    return { extractedPrefix, extractedPostfix, cleanValue };\n}\n\nfunction findCommonBeginningSubstr(a, b) {\n    let res = '';\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return res;\n        }\n        res += a[i];\n    }\n    return res;\n}\n\nfunction identity(x) {\n    return x;\n}\n\nfunction isEmpty(entity) {\n    return !entity || (typeof entity === 'object' && Object.keys(entity).length === 0);\n}\n\nconst ALL_ZEROES_RE = /^0+$/;\nfunction padWithZeroesUntilValid(segmentValue, paddedMaxValue, prefixedZeroesCount = 0) {\n    const paddedSegmentValue = segmentValue.padEnd(paddedMaxValue.length, '0');\n    if (Number(paddedSegmentValue) <= Number(paddedMaxValue)) {\n        return { validatedSegmentValue: segmentValue, prefixedZeroesCount };\n    }\n    if (paddedSegmentValue.endsWith('0')) {\n        // 00:|00 => Type 9 => 00:09|\n        return padWithZeroesUntilValid(`0${segmentValue.slice(0, paddedMaxValue.length - 1)}`, paddedMaxValue, prefixedZeroesCount + 1);\n    }\n    const valueWithoutLastChar = segmentValue.slice(0, paddedMaxValue.length - 1);\n    if (ALL_ZEROES_RE.exec(valueWithoutLastChar)) {\n        return { validatedSegmentValue: '', prefixedZeroesCount };\n    }\n    // |19:00 => Type 2 => 2|0:00\n    return padWithZeroesUntilValid(`${valueWithoutLastChar}0`, paddedMaxValue, prefixedZeroesCount);\n}\n\n/**\n * Replace fullwidth colon with half width colon\n * @param fullWidthColon full width colon\n * @returns processed half width colon\n */\nfunction toHalfWidthColon(fullWidthColon) {\n    return fullWidthColon.replaceAll(new RegExp(CHAR_JP_COLON, 'g'), CHAR_COLON);\n}\n\n/**\n * Replace fullwidth numbers with half width number\n * @param fullWidthNumber full width number\n * @returns processed half width number\n */\nfunction toHalfWidthNumber(fullWidthNumber) {\n    return fullWidthNumber.replaceAll(/[０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xfee0));\n}\n\n/**\n * Convert full width colon (：) to half width one (:)\n */\nfunction createColonConvertPreprocessor() {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        return {\n            elementState: {\n                selection,\n                value: toHalfWidthColon(value),\n            },\n            data: toHalfWidthColon(data),\n        };\n    };\n}\n\nfunction createDateSegmentsZeroPaddingPostprocessor({ dateModeTemplate, dateSegmentSeparator, splitFn, uniteFn, }) {\n    return ({ value, selection }) => {\n        var _a;\n        const [from, to] = selection;\n        const { dateStrings, restPart = '' } = splitFn(value);\n        const validatedDateStrings = [];\n        let caretShift = 0;\n        dateStrings.forEach((dateString) => {\n            const parsedDate = parseDateString(dateString, dateModeTemplate);\n            const dateSegments = Object.entries(parsedDate);\n            const validatedDateSegments = dateSegments.reduce((acc, [segmentName, segmentValue]) => {\n                const { validatedSegmentValue, prefixedZeroesCount } = padWithZeroesUntilValid(segmentValue, `${DATE_SEGMENTS_MAX_VALUES[segmentName]}`);\n                caretShift += prefixedZeroesCount;\n                return Object.assign(Object.assign({}, acc), { [segmentName]: validatedSegmentValue });\n            }, {});\n            validatedDateStrings.push(toDateString(validatedDateSegments, { dateMode: dateModeTemplate }));\n        });\n        const validatedValue = uniteFn(validatedDateStrings, value) +\n            (((_a = dateStrings[dateStrings.length - 1]) === null || _a === void 0 ? void 0 : _a.endsWith(dateSegmentSeparator))\n                ? dateSegmentSeparator\n                : '') +\n            restPart;\n        if (caretShift &&\n            validatedValue.slice(to + caretShift, to + caretShift + dateSegmentSeparator.length) === dateSegmentSeparator) {\n            /**\n             * If `caretShift` > 0, it means that time segment was padded with zero.\n             * It is only possible if any character insertion happens.\n             * If caret is before `dateSegmentSeparator` => it should be moved after `dateSegmentSeparator`.\n             */\n            caretShift += dateSegmentSeparator.length;\n        }\n        return {\n            selection: [from + caretShift, to + caretShift],\n            value: validatedValue,\n        };\n    };\n}\n\n/**\n * It replaces pseudo range separators with valid one.\n * @example '01.01.2000_11.11.2000' -> '01.01.2000 - 01.01.2000'\n * @example '01.01.2000_23:59' -> '01.01.2000, 23:59'\n */\nfunction createFirstDateEndSeparatorPreprocessor({ dateModeTemplate, firstDateEndSeparator, dateSegmentSeparator, pseudoFirstDateEndSeparators, }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const firstCompleteDate = getFirstCompleteDate(value, dateModeTemplate);\n        const pseudoSeparators = pseudoFirstDateEndSeparators.filter((x) => !firstDateEndSeparator.includes(x) && x !== dateSegmentSeparator);\n        const pseudoSeparatorsRE = new RegExp(`[${pseudoSeparators.join('')}]`, 'gi');\n        const newValue = firstCompleteDate && value.length > firstCompleteDate.length\n            ? firstCompleteDate +\n                value\n                    .slice(firstCompleteDate.length)\n                    .replace(/^[\\D\\s]*/, firstDateEndSeparator)\n            : value;\n        const caretShift = newValue.length - value.length;\n        return {\n            elementState: {\n                selection: [from + caretShift, to + caretShift],\n                value: newValue,\n            },\n            data: data.replace(pseudoSeparatorsRE, firstDateEndSeparator),\n        };\n    };\n}\n\n/**\n * Convert full width numbers like １, ２ to half width numbers 1, 2\n */\nfunction createFullWidthToHalfWidthPreprocessor() {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        return {\n            elementState: {\n                selection,\n                value: toHalfWidthNumber(value),\n            },\n            data: toHalfWidthNumber(data),\n        };\n    };\n}\n\nfunction createTimeMaskExpression(mode) {\n    return Array.from(mode.replace(' AA', ''))\n        .map((char) => (TIME_FIXED_CHARACTERS.includes(char) ? char : /\\d/))\n        .concat(mode.includes('AA') ? [CHAR_NO_BREAK_SPACE, /[AP]/i, /M/i] : []);\n}\n\nfunction padTimeSegments(timeSegments, pad) {\n    return Object.fromEntries(Object.entries(timeSegments).map(([segmentName, segmentValue]) => [\n        segmentName,\n        pad(String(segmentValue), TIME_SEGMENT_VALUE_LENGTHS[segmentName]),\n    ]));\n}\n\nfunction padStartTimeSegments(timeSegments) {\n    return padTimeSegments(timeSegments, (value, length) => value.padStart(length, '0'));\n}\n\nconst SEGMENT_FULL_NAME = {\n    HH: 'hours',\n    MM: 'minutes',\n    SS: 'seconds',\n    MSS: 'milliseconds',\n};\n/**\n * @param timeString can be with/without fixed characters\n */\nfunction parseTimeString(timeString, timeMode) {\n    const onlyDigits = timeString.replaceAll(/\\D+/g, '');\n    let offset = 0;\n    return Object.fromEntries(timeMode\n        .split(/\\W/)\n        .filter((segmentAbbr) => SEGMENT_FULL_NAME[segmentAbbr])\n        .map((segmentAbbr) => {\n        const segmentValue = onlyDigits.slice(offset, offset + segmentAbbr.length);\n        offset += segmentAbbr.length;\n        return [SEGMENT_FULL_NAME[segmentAbbr], segmentValue];\n    }));\n}\n\nconst LEADING_NON_DIGITS = /^\\D*/;\nconst TRAILING_NON_DIGITS = /\\D*$/;\nfunction toTimeString({ hours = '', minutes = '', seconds = '', milliseconds = '', }) {\n    return `${hours}:${minutes}:${seconds}.${milliseconds}`\n        .replace(LEADING_NON_DIGITS, '')\n        .replace(TRAILING_NON_DIGITS, '');\n}\n\nconst TRAILING_TIME_SEGMENT_SEPARATOR_REG = new RegExp(`[${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]$`);\n/**\n * Pads invalid time segment with zero to make it valid.\n * @example 00:|00 => Type 9 (too much for the first digit of minutes) => 00:09|\n * @example |19:00 => Type 2 (29 - invalid value for hours) => 2|0:00\n */\nfunction enrichTimeSegmentsWithZeroes({ value, selection }, { mode, timeSegmentMaxValues = DEFAULT_TIME_SEGMENT_MAX_VALUES, }) {\n    const [from, to] = selection;\n    const parsedTime = parseTimeString(value, mode);\n    const possibleTimeSegments = Object.entries(parsedTime);\n    const paddedMaxValues = padStartTimeSegments(timeSegmentMaxValues);\n    const validatedTimeSegments = {};\n    let paddedZeroes = 0;\n    for (const [segmentName, segmentValue] of possibleTimeSegments) {\n        const maxSegmentValue = paddedMaxValues[segmentName];\n        const { validatedSegmentValue, prefixedZeroesCount } = padWithZeroesUntilValid(segmentValue, String(maxSegmentValue));\n        paddedZeroes += prefixedZeroesCount;\n        validatedTimeSegments[segmentName] = validatedSegmentValue;\n    }\n    // trailing segment separators or meridiem characters\n    const [trailingNonDigitCharacters = ''] = value.match(/\\D+$/g) || [];\n    const validatedTimeString = toTimeString(validatedTimeSegments) + trailingNonDigitCharacters;\n    const addedDateSegmentSeparators = Math.max(validatedTimeString.length - value.length, 0);\n    let newFrom = from + paddedZeroes + addedDateSegmentSeparators;\n    let newTo = to + paddedZeroes + addedDateSegmentSeparators;\n    if (newFrom === newTo &&\n        paddedZeroes &&\n        // if next character after cursor is time segment separator\n        validatedTimeString.slice(0, newTo + 1).match(TRAILING_TIME_SEGMENT_SEPARATOR_REG)) {\n        newFrom++;\n        newTo++;\n    }\n    return {\n        value: validatedTimeString,\n        selection: [newFrom, newTo],\n    };\n}\n\nfunction padEndTimeSegments(timeSegments) {\n    return padTimeSegments(timeSegments, (value, length) => value.padEnd(length, '0'));\n}\n\n/**\n * Prevent insertion if any time segment will become invalid\n * (and even zero padding won't help with it).\n * @example 2|0:00 => Type 9 => 2|0:00\n */\nfunction createInvalidTimeSegmentInsertionPreprocessor({ timeMode, timeSegmentMinValues = DEFAULT_TIME_SEGMENT_MIN_VALUES, timeSegmentMaxValues = DEFAULT_TIME_SEGMENT_MAX_VALUES, parseValue = (x) => ({ timeString: x }), }) {\n    const invalidCharsRegExp = new RegExp(`[^\\\\d${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]+`);\n    return ({ elementState, data }, actionType) => {\n        if (actionType !== 'insert') {\n            return { elementState, data };\n        }\n        const { value, selection } = elementState;\n        const [from, rawTo] = selection;\n        const newCharacters = data.replace(invalidCharsRegExp, '');\n        const to = rawTo + newCharacters.length; // to be conformed with `overwriteMode: replace`\n        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n        const { timeString, restValue = '' } = parseValue(newPossibleValue);\n        const timeSegments = Object.entries(parseTimeString(timeString, timeMode));\n        let offset = restValue.length;\n        for (const [segmentName, stringifiedSegmentValue] of timeSegments) {\n            const minSegmentValue = timeSegmentMinValues[segmentName];\n            const maxSegmentValue = timeSegmentMaxValues[segmentName];\n            const segmentValue = Number(stringifiedSegmentValue);\n            const lastSegmentDigitIndex = offset + TIME_SEGMENT_VALUE_LENGTHS[segmentName];\n            if (lastSegmentDigitIndex >= from &&\n                lastSegmentDigitIndex <= to &&\n                segmentValue !== clamp(segmentValue, minSegmentValue, maxSegmentValue)) {\n                return { elementState, data: '' }; // prevent insertion\n            }\n            offset +=\n                stringifiedSegmentValue.length +\n                    // any time segment separator\n                    1;\n        }\n        return { elementState, data };\n    };\n}\n\nfunction createMeridiemPreprocessor(timeMode) {\n    if (!timeMode.includes('AA')) {\n        return identity;\n    }\n    const mainMeridiemCharRE = /^[AP]$/gi;\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const newValue = value.toUpperCase();\n        const newData = data.toUpperCase();\n        if (newValue.match(ALL_MERIDIEM_CHARACTERS_RE) &&\n            newData.match(mainMeridiemCharRE)) {\n            return {\n                elementState: {\n                    value: newValue.replaceAll(ALL_MERIDIEM_CHARACTERS_RE, ''),\n                    selection,\n                },\n                data: `${newData}M`,\n            };\n        }\n        return { elementState: { selection, value: newValue }, data: newData };\n    };\n}\nfunction createMeridiemPostprocessor(timeMode) {\n    if (!timeMode.includes('AA')) {\n        return identity;\n    }\n    return ({ value, selection }, initialElementState) => {\n        if (!value.match(ANY_MERIDIEM_CHARACTER_RE) ||\n            value.match(ALL_MERIDIEM_CHARACTERS_RE)) {\n            return { value, selection };\n        }\n        const [from, to] = selection;\n        // any meridiem character was deleted\n        if (initialElementState.value.match(ALL_MERIDIEM_CHARACTERS_RE)) {\n            const newValue = value.replace(ANY_MERIDIEM_CHARACTER_RE, '');\n            return {\n                value: newValue,\n                selection: [\n                    Math.min(from, newValue.length),\n                    Math.min(to, newValue.length),\n                ],\n            };\n        }\n        const fullMeridiem = `${CHAR_NO_BREAK_SPACE}${value.includes('P') ? 'P' : 'A'}M`;\n        const newValue = value.replace(ANY_MERIDIEM_CHARACTER_RE, (x) => x !== CHAR_NO_BREAK_SPACE ? fullMeridiem : x);\n        return {\n            value: newValue,\n            selection: to >= newValue.indexOf(fullMeridiem)\n                ? [newValue.length, newValue.length]\n                : selection,\n        };\n    };\n}\n\nfunction raiseSegmentValueToMin(segments, fullMode) {\n    const segmentsLength = getDateSegmentValueLength(fullMode);\n    return Object.fromEntries(Object.entries(segments).map(([key, value]) => {\n        const segmentLength = segmentsLength[key];\n        return [\n            key,\n            value.length === segmentLength && /^0+$/.exec(value)\n                ? '1'.padStart(segmentLength, '0')\n                : value,\n        ];\n    }));\n}\n\nfunction createMinMaxDatePostprocessor({ dateModeTemplate, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, rangeSeparator = '', dateSegmentSeparator = '.', }) {\n    return ({ value, selection }) => {\n        const endsWithRangeSeparator = rangeSeparator && value.endsWith(rangeSeparator);\n        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n        let validatedValue = '';\n        for (const dateString of dateStrings) {\n            validatedValue += validatedValue ? rangeSeparator : '';\n            const parsedDate = parseDateString(dateString, dateModeTemplate);\n            if (!isDateStringComplete(dateString, dateModeTemplate)) {\n                const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n                const fixedValue = toDateString(fixedDate, { dateMode: dateModeTemplate });\n                const tail = dateString.endsWith(dateSegmentSeparator)\n                    ? dateSegmentSeparator\n                    : '';\n                validatedValue += fixedValue + tail;\n                continue;\n            }\n            const date = segmentsToDate(parsedDate);\n            const clampedDate = clamp(date, min, max);\n            validatedValue += toDateString(dateToSegments(clampedDate), {\n                dateMode: dateModeTemplate,\n            });\n        }\n        return {\n            selection,\n            value: validatedValue + (endsWithRangeSeparator ? rangeSeparator : ''),\n        };\n    };\n}\n\nfunction normalizeDatePreprocessor({ dateModeTemplate, dateSegmentsSeparator, rangeSeparator = '', dateTimeSeparator = DATE_TIME_SEPARATOR, }) {\n    return ({ elementState, data }) => {\n        var _a;\n        const separator = rangeSeparator\n            ? new RegExp(`${rangeSeparator}|-`)\n            : dateTimeSeparator;\n        const possibleDates = data.split(separator);\n        const dates = data.includes(dateTimeSeparator)\n            ? [(_a = possibleDates[0]) !== null && _a !== void 0 ? _a : '']\n            : possibleDates;\n        if (dates.every((date) => date.trim().split(/\\D/).filter(Boolean).length ===\n            dateModeTemplate.split(dateSegmentsSeparator).length)) {\n            const newData = dates\n                .map((date) => normalizeDateString(date, dateModeTemplate, dateSegmentsSeparator))\n                .join(rangeSeparator);\n            return {\n                elementState,\n                data: `${newData}${data.includes(dateTimeSeparator)\n                    ? dateTimeSeparator + possibleDates[1] || ''\n                    : ''}`,\n            };\n        }\n        return { elementState, data };\n    };\n}\nfunction normalizeDateString(dateString, template, separator) {\n    const dateSegments = dateString.split(/\\D/).filter(Boolean);\n    const templateSegments = template.split(separator);\n    const normalizedSegments = dateSegments.map((segment, index) => {\n        var _a, _b;\n        return index === templateSegments.length - 1\n            ? segment\n            : segment.padStart((_b = (_a = templateSegments[index]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0, '0');\n    });\n    return normalizedSegments.join(separator);\n}\n\nfunction maskitoPostfixPostprocessorGenerator(postfix) {\n    const postfixRE = new RegExp(`${escapeRegExp(postfix)}$`);\n    return postfix\n        ? ({ value, selection }, initialElementState) => {\n            if (!value && !initialElementState.value.endsWith(postfix)) {\n                // cases when developer wants input to be empty (programmatically)\n                return { value, selection };\n            }\n            if (!value.endsWith(postfix) &&\n                !initialElementState.value.endsWith(postfix)) {\n                return { selection, value: value + postfix };\n            }\n            const initialValueBeforePostfix = initialElementState.value.replace(postfixRE, '');\n            const postfixWasModified = initialElementState.selection[1] >= initialValueBeforePostfix.length;\n            const alreadyExistedValueBeforePostfix = findCommonBeginningSubstr(initialValueBeforePostfix, value);\n            return {\n                selection,\n                value: Array.from(postfix)\n                    .reverse()\n                    .reduce((newValue, char, index) => {\n                    const i = newValue.length - 1 - index;\n                    const isInitiallyMirroredChar = alreadyExistedValueBeforePostfix[i] === char &&\n                        postfixWasModified;\n                    return newValue[i] !== char || isInitiallyMirroredChar\n                        ? newValue.slice(0, i + 1) + char + newValue.slice(i + 1)\n                        : newValue;\n                }, value),\n            };\n        }\n        : identity;\n}\n\nfunction maskitoPrefixPostprocessorGenerator(prefix) {\n    return prefix\n        ? ({ value, selection }, initialElementState) => {\n            if (value.startsWith(prefix) || // already valid\n                (!value && !initialElementState.value.startsWith(prefix)) // cases when developer wants input to be empty\n            ) {\n                return { value, selection };\n            }\n            const [from, to] = selection;\n            const prefixedValue = Array.from(prefix).reduce((modifiedValue, char, i) => modifiedValue[i] === char\n                ? modifiedValue\n                : modifiedValue.slice(0, i) + char + modifiedValue.slice(i), value);\n            const addedCharsCount = prefixedValue.length - value.length;\n            return {\n                selection: [from + addedCharsCount, to + addedCharsCount],\n                value: prefixedValue,\n            };\n        }\n        : identity;\n}\n\nfunction createValidDatePreprocessor({ dateModeTemplate, dateSegmentsSeparator, rangeSeparator = '', }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        if (data === dateSegmentsSeparator) {\n            return {\n                elementState,\n                data: selection[0] === value.length ? data : '',\n            };\n        }\n        const newCharacters = data.replaceAll(new RegExp(`[^\\\\d${escapeRegExp(dateSegmentsSeparator)}${rangeSeparator}]`, 'g'), '');\n        if (!newCharacters) {\n            return { elementState, data: '' };\n        }\n        const [from, rawTo] = selection;\n        let to = rawTo + data.length;\n        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n        const dateStrings = parseDateRangeString(newPossibleValue, dateModeTemplate, rangeSeparator);\n        let validatedValue = '';\n        const hasRangeSeparator = Boolean(rangeSeparator) && newPossibleValue.includes(rangeSeparator);\n        for (const dateString of dateStrings) {\n            const { validatedDateString, updatedSelection } = validateDateString({\n                dateString,\n                dateModeTemplate,\n                dateSegmentsSeparator,\n                offset: validatedValue.length,\n                selection: [from, to],\n            });\n            if (dateString && !validatedDateString) {\n                return { elementState, data: '' }; // prevent changes\n            }\n            to = updatedSelection[1];\n            validatedValue +=\n                hasRangeSeparator && !validatedValue\n                    ? validatedDateString + rangeSeparator\n                    : validatedDateString;\n        }\n        const newData = validatedValue.slice(from, to);\n        return {\n            elementState: {\n                selection,\n                value: validatedValue.slice(0, from) +\n                    newData\n                        .split(dateSegmentsSeparator)\n                        .map((segment) => '0'.repeat(segment.length))\n                        .join(dateSegmentsSeparator) +\n                    validatedValue.slice(to),\n            },\n            data: newData,\n        };\n    };\n}\n\nfunction maskitoEventHandler(name, handler, eventListenerOptions) {\n    return (element, maskitoOptions) => {\n        const listener = () => handler(element, maskitoOptions);\n        element.addEventListener(name, listener, eventListenerOptions);\n        return () => element.removeEventListener(name, listener, eventListenerOptions);\n    };\n}\n\nfunction maskitoAddOnFocusPlugin(value) {\n    return maskitoEventHandler('focus', (element) => {\n        if (!element.value) {\n            maskitoUpdateElement(element, value);\n        }\n    });\n}\n\nfunction maskitoCaretGuard(guard) {\n    return (element) => {\n        const document = element.ownerDocument;\n        let isPointerDown = 0;\n        const onPointerDown = () => isPointerDown++;\n        const onPointerUp = () => {\n            isPointerDown = Math.max(--isPointerDown, 0);\n        };\n        const listener = () => {\n            var _a, _b;\n            if (!element.matches(':focus')) {\n                return;\n            }\n            if (isPointerDown) {\n                return document.addEventListener('mouseup', listener, {\n                    once: true,\n                    passive: true,\n                });\n            }\n            const start = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n            const end = (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0;\n            const [fromLimit, toLimit] = guard(element.value, [start, end]);\n            if (fromLimit > start || toLimit < end) {\n                element.setSelectionRange(clamp(start, fromLimit, toLimit), clamp(end, fromLimit, toLimit));\n            }\n        };\n        document.addEventListener('selectionchange', listener, { passive: true });\n        element.addEventListener('mousedown', onPointerDown, { passive: true });\n        document.addEventListener('mouseup', onPointerUp, { passive: true });\n        return () => {\n            document.removeEventListener('selectionchange', listener);\n            document.removeEventListener('mousedown', onPointerDown);\n            document.removeEventListener('mouseup', onPointerUp);\n        };\n    };\n}\n\nconst maskitoRejectEvent = (element) => {\n    const listener = () => {\n        const value = element.value;\n        element.addEventListener('beforeinput', (event) => {\n            if (event.defaultPrevented && value === element.value) {\n                element.dispatchEvent(new CustomEvent('maskitoReject', { bubbles: true }));\n            }\n        }, { once: true });\n    };\n    element.addEventListener('beforeinput', listener, true);\n    return () => element.removeEventListener('beforeinput', listener, true);\n};\n\nfunction maskitoRemoveOnBlurPlugin(value) {\n    return maskitoEventHandler('blur', (element) => {\n        if (element.value === value) {\n            maskitoUpdateElement(element, '');\n        }\n    });\n}\n\nfunction createMeridiemSteppingPlugin(meridiemStartIndex) {\n    if (meridiemStartIndex < 0) {\n        return () => { };\n    }\n    return (element) => {\n        const listener = (event) => {\n            const caretIndex = Number(element.selectionStart);\n            const value = element.value.toUpperCase();\n            if ((event.key !== 'ArrowUp' && event.key !== 'ArrowDown') ||\n                caretIndex < meridiemStartIndex) {\n                return;\n            }\n            event.preventDefault();\n            // eslint-disable-next-line no-nested-ternary\n            const meridiemMainCharacter = value.includes('A')\n                ? 'P'\n                : value.includes('P') || event.key === 'ArrowUp'\n                    ? 'A'\n                    : 'P';\n            const newMeridiem = `${CHAR_NO_BREAK_SPACE}${meridiemMainCharacter}M`;\n            maskitoUpdateElement(element, {\n                value: value.length === meridiemStartIndex\n                    ? value + newMeridiem\n                    : value.replace(ANY_MERIDIEM_CHARACTER_RE, newMeridiem),\n                selection: [caretIndex, caretIndex],\n            });\n        };\n        element.addEventListener('keydown', listener);\n        return () => element.removeEventListener('keydown', listener);\n    };\n}\n\nconst noop = () => { };\nfunction createTimeSegmentsSteppingPlugin({ step, fullMode, timeSegmentMaxValues, }) {\n    const segmentsIndexes = createTimeSegmentsIndexes(fullMode);\n    return step <= 0\n        ? noop\n        : (element) => {\n            const listener = (event) => {\n                var _a;\n                if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {\n                    return;\n                }\n                event.preventDefault();\n                const selectionStart = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n                const activeSegment = getActiveSegment({\n                    segmentsIndexes,\n                    selectionStart,\n                });\n                if (!activeSegment) {\n                    return;\n                }\n                const updatedValue = updateSegmentValue({\n                    selection: segmentsIndexes.get(activeSegment),\n                    value: element.value,\n                    toAdd: event.key === 'ArrowUp' ? step : -step,\n                    max: timeSegmentMaxValues[activeSegment],\n                });\n                maskitoUpdateElement(element, {\n                    value: updatedValue,\n                    selection: [selectionStart, selectionStart],\n                });\n            };\n            element.addEventListener('keydown', listener);\n            return () => element.removeEventListener('keydown', listener);\n        };\n}\nfunction createTimeSegmentsIndexes(fullMode) {\n    return new Map([\n        ['hours', getSegmentRange(fullMode, 'HH')],\n        ['milliseconds', getSegmentRange(fullMode, 'MSS')],\n        ['minutes', getSegmentRange(fullMode, 'MM')],\n        ['seconds', getSegmentRange(fullMode, 'SS')],\n    ]);\n}\nfunction getSegmentRange(mode, segment) {\n    const index = mode.indexOf(segment);\n    return index === -1 ? [-1, -1] : [index, index + segment.length];\n}\nfunction getActiveSegment({ segmentsIndexes, selectionStart, }) {\n    for (const [segmentName, segmentRange] of segmentsIndexes.entries()) {\n        const [from, to] = segmentRange;\n        if (from <= selectionStart && selectionStart <= to) {\n            return segmentName;\n        }\n    }\n    return null;\n}\nfunction updateSegmentValue({ selection, value, toAdd, max, }) {\n    const [from, to] = selection;\n    const segmentValue = Number(value.slice(from, to).padEnd(to - from, '0'));\n    const newSegmentValue = mod(segmentValue + toAdd, max + 1);\n    return (value.slice(0, from) +\n        String(newSegmentValue).padStart(to - from, '0') +\n        value.slice(to, value.length));\n}\nfunction mod(value, max) {\n    if (value < 0) {\n        value += Math.floor(Math.abs(value) / max + 1) * max;\n    }\n    return value % max;\n}\n\nfunction maskitoWithPlaceholder(placeholder, focusedOnly = false) {\n    let lastClearValue = '';\n    let action = 'validation';\n    const removePlaceholder = (value) => {\n        for (let i = value.length - 1; i >= lastClearValue.length; i--) {\n            if (value[i] !== placeholder[i]) {\n                return value.slice(0, i + 1);\n            }\n        }\n        return value.slice(0, lastClearValue.length);\n    };\n    const plugins = [maskitoCaretGuard((value) => [0, removePlaceholder(value).length])];\n    let focused = false;\n    if (focusedOnly) {\n        const focus = maskitoEventHandler('focus', (element) => {\n            focused = true;\n            maskitoUpdateElement(element, element.value + placeholder.slice(element.value.length));\n        }, { capture: true });\n        const blur = maskitoEventHandler('blur', (element) => {\n            focused = false;\n            maskitoUpdateElement(element, removePlaceholder(element.value));\n        }, { capture: true });\n        plugins.push(focus, blur);\n    }\n    return {\n        plugins,\n        removePlaceholder,\n        preprocessors: [\n            ({ elementState, data }, actionType) => {\n                action = actionType;\n                const { value, selection } = elementState;\n                return {\n                    elementState: {\n                        selection,\n                        value: removePlaceholder(value),\n                    },\n                    data,\n                };\n            },\n        ],\n        postprocessors: [\n            ({ value, selection }, initialElementState) => {\n                lastClearValue = value;\n                const justPlaceholderRemoval = value +\n                    placeholder.slice(value.length, initialElementState.value.length) ===\n                    initialElementState.value;\n                if (action === 'validation' && justPlaceholderRemoval) {\n                    /**\n                     * If `value` still equals to `initialElementState.value`,\n                     * then it means that value is patched programmatically (from Maskito's plugin or externally).\n                     * In this case, we don't want to mutate value and automatically add/remove placeholder.\n                     * ___\n                     * For example, developer wants to remove manually placeholder (+ do something else with value) on blur.\n                     * Without this condition, placeholder will be unexpectedly added again.\n                     */\n                    return { selection, value: initialElementState.value };\n                }\n                const newValue = focused || !focusedOnly\n                    ? value + placeholder.slice(value.length)\n                    : value;\n                if (newValue === initialElementState.value &&\n                    action === 'deleteBackward') {\n                    const [caretIndex] = initialElementState.selection;\n                    return {\n                        value: newValue,\n                        selection: [caretIndex, caretIndex],\n                    };\n                }\n                return { value: newValue, selection };\n            },\n        ],\n    };\n}\n\nfunction createZeroPlaceholdersPreprocessor() {\n    return ({ elementState }, actionType) => {\n        const { value, selection } = elementState;\n        if (!value || isLastChar(value, selection)) {\n            return { elementState };\n        }\n        const [from, to] = selection;\n        const zeroes = value.slice(from, to).replaceAll(/\\d/g, '0');\n        const newValue = value.slice(0, from) + zeroes + value.slice(to);\n        if (!zeroes.replaceAll(/\\D/g, '')) {\n            return { elementState };\n        }\n        if (actionType === 'validation' || (actionType === 'insert' && from === to)) {\n            return {\n                elementState: { selection, value: newValue },\n            };\n        }\n        return {\n            elementState: {\n                selection: actionType === 'deleteBackward' || actionType === 'insert'\n                    ? [from, from]\n                    : [to, to],\n                value: newValue,\n            },\n        };\n    };\n}\nfunction isLastChar(value, [_, to]) {\n    return to === value.length;\n}\n\nfunction maskitoDateOptionsGenerator({ mode, separator = '.', max, min, }) {\n    const dateModeTemplate = mode.split('/').join(separator);\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: Array.from(dateModeTemplate).map((char) => separator.includes(char) ? char : /\\d/), overwriteMode: 'replace', preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createZeroPlaceholdersPreprocessor(),\n            normalizeDatePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: separator,\n            }),\n            createValidDatePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: separator,\n            }),\n        ], postprocessors: [\n            createDateSegmentsZeroPaddingPostprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: separator,\n                splitFn: (value) => ({ dateStrings: [value] }),\n                uniteFn: ([dateString = '']) => dateString,\n            }),\n            createMinMaxDatePostprocessor({\n                min,\n                max,\n                dateModeTemplate,\n                dateSegmentSeparator: separator,\n            }),\n        ] });\n}\n\nconst POSSIBLE_DATE_RANGE_SEPARATOR = [\n    CHAR_HYPHEN,\n    CHAR_EN_DASH,\n    CHAR_EM_DASH,\n    CHAR_MINUS,\n    CHAR_JP_HYPHEN,\n];\n\nfunction createMinMaxRangeLengthPostprocessor({ dateModeTemplate, rangeSeparator, minLength, maxLength, max = DEFAULT_MAX_DATE, }) {\n    if (isEmpty(minLength) && isEmpty(maxLength)) {\n        return identity;\n    }\n    return ({ value, selection }) => {\n        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n        if (dateStrings.length !== 2 ||\n            dateStrings.some((date) => !isDateStringComplete(date, dateModeTemplate))) {\n            return { value, selection };\n        }\n        const [fromDate, toDate] = dateStrings.map((dateString) => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n        if (!fromDate || !toDate) {\n            return { value, selection };\n        }\n        const minDistantToDate = appendDate(fromDate, Object.assign(Object.assign({}, minLength), { \n            // 06.02.2023 - 07.02.2023 => {minLength: {day: 3}} => 06.02.2023 - 08.02.2023\n            // \"from\"-day is included in the range\n            day: (minLength === null || minLength === void 0 ? void 0 : minLength.day) && minLength.day - 1 }));\n        const maxDistantToDate = !isEmpty(maxLength)\n            ? appendDate(fromDate, Object.assign(Object.assign({}, maxLength), { day: (maxLength === null || maxLength === void 0 ? void 0 : maxLength.day) && maxLength.day - 1 }))\n            : max;\n        const minLengthClampedToDate = clamp(toDate, minDistantToDate, max);\n        const minMaxLengthClampedToDate = minLengthClampedToDate > maxDistantToDate\n            ? maxDistantToDate\n            : minLengthClampedToDate;\n        return {\n            selection,\n            value: dateStrings[0] +\n                rangeSeparator +\n                toDateString(dateToSegments(minMaxLengthClampedToDate), {\n                    dateMode: dateModeTemplate,\n                }),\n        };\n    };\n}\n\nfunction createSwapDatesPostprocessor({ dateModeTemplate, rangeSeparator, }) {\n    return ({ value, selection }) => {\n        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n        const isDateRangeComplete = dateStrings.length === 2 &&\n            dateStrings.every((date) => isDateStringComplete(date, dateModeTemplate));\n        const [from, to] = selection;\n        const caretAtTheEnd = from >= value.length;\n        const allValueSelected = from === 0 && to >= value.length; // dropping text inside with a pointer\n        if (!(caretAtTheEnd || allValueSelected) || !isDateRangeComplete) {\n            return { value, selection };\n        }\n        const [fromDate, toDate] = dateStrings.map((dateString) => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n        return {\n            selection,\n            value: fromDate && toDate && fromDate > toDate\n                ? dateStrings.reverse().join(rangeSeparator)\n                : value,\n        };\n    };\n}\n\nfunction maskitoDateRangeOptionsGenerator({ mode, min, max, minLength, maxLength, dateSeparator = '.', rangeSeparator = `${CHAR_NO_BREAK_SPACE}${CHAR_EN_DASH}${CHAR_NO_BREAK_SPACE}`, }) {\n    const dateModeTemplate = mode.split('/').join(dateSeparator);\n    const dateMask = Array.from(dateModeTemplate).map((char) => dateSeparator.includes(char) ? char : /\\d/);\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: [...dateMask, ...Array.from(rangeSeparator), ...dateMask], overwriteMode: 'replace', preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createFirstDateEndSeparatorPreprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                firstDateEndSeparator: rangeSeparator,\n                pseudoFirstDateEndSeparators: POSSIBLE_DATE_RANGE_SEPARATOR,\n            }),\n            createZeroPlaceholdersPreprocessor(),\n            normalizeDatePreprocessor({\n                dateModeTemplate,\n                rangeSeparator,\n                dateSegmentsSeparator: dateSeparator,\n            }),\n            createValidDatePreprocessor({\n                dateModeTemplate,\n                rangeSeparator,\n                dateSegmentsSeparator: dateSeparator,\n            }),\n        ], postprocessors: [\n            createDateSegmentsZeroPaddingPostprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                splitFn: (value) => ({\n                    dateStrings: parseDateRangeString(value, dateModeTemplate, rangeSeparator),\n                }),\n                uniteFn: (validatedDateStrings, initialValue) => validatedDateStrings.reduce((acc, dateString, dateIndex) => acc +\n                    dateString +\n                    (!dateIndex && initialValue.includes(rangeSeparator)\n                        ? rangeSeparator\n                        : ''), ''),\n            }),\n            createMinMaxDatePostprocessor({\n                min,\n                max,\n                dateModeTemplate,\n                rangeSeparator,\n                dateSegmentSeparator: dateSeparator,\n            }),\n            createMinMaxRangeLengthPostprocessor({\n                dateModeTemplate,\n                minLength,\n                maxLength,\n                max,\n                rangeSeparator,\n            }),\n            createSwapDatesPostprocessor({\n                dateModeTemplate,\n                rangeSeparator,\n            }),\n        ] });\n}\n\nfunction isDateTimeStringComplete(dateTimeString, { dateMode, timeMode, dateTimeSeparator = DATE_TIME_SEPARATOR, }) {\n    var _a;\n    return (dateTimeString.length >=\n        dateMode.length + timeMode.length + dateTimeSeparator.length &&\n        ((_a = dateTimeString.split(dateTimeSeparator)[0]) !== null && _a !== void 0 ? _a : '')\n            .split(/\\D/)\n            .every((segment) => !/^0+$/.exec(segment)));\n}\n\nconst NON_DIGIT_PLACEHOLDER_RE = /[^dmy]/g;\nconst LEADING_NON_DIGIT_RE = /^\\D*/;\nfunction parseDateTimeString(dateTime, dateModeTemplate) {\n    const dateDigitsCount = dateModeTemplate.replaceAll(NON_DIGIT_PLACEHOLDER_RE, '').length;\n    const [date = ''] = new RegExp(`(\\\\d[^\\\\d]*){0,${dateDigitsCount - 1}}\\\\d?`).exec(dateTime) || [];\n    const [dateTimeSeparator = ''] = LEADING_NON_DIGIT_RE.exec(dateTime.slice(date.length)) || [];\n    return [date, dateTime.slice(date.length + dateTimeSeparator.length)];\n}\n\nfunction createMinMaxDateTimePostprocessor({ dateModeTemplate, timeMode, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, dateTimeSeparator, }) {\n    return ({ value, selection }) => {\n        const [dateString, timeString] = parseDateTimeString(value, dateModeTemplate);\n        const parsedDate = parseDateString(dateString, dateModeTemplate);\n        const parsedTime = parseTimeString(timeString, timeMode);\n        if (!isDateTimeStringComplete(value, {\n            dateMode: dateModeTemplate,\n            timeMode,\n            dateTimeSeparator,\n        })) {\n            const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n            const { year, month, day } = isDateStringComplete(dateString, dateModeTemplate)\n                ? dateToSegments(clamp(segmentsToDate(fixedDate), min, max))\n                : fixedDate;\n            const fixedValue = toDateString(Object.assign({ year,\n                month,\n                day }, parsedTime), { dateMode: dateModeTemplate, dateTimeSeparator, timeMode });\n            const tail = value.slice(fixedValue.length);\n            return {\n                selection,\n                value: fixedValue + tail,\n            };\n        }\n        const date = segmentsToDate(parsedDate, parsedTime);\n        const clampedDate = clamp(date, min, max);\n        // trailing segment separators or meridiem characters\n        const [trailingNonDigitCharacters = ''] = value.match(/\\D+$/g) || [];\n        const validatedValue = toDateString(dateToSegments(clampedDate), {\n            dateMode: dateModeTemplate,\n            dateTimeSeparator,\n            timeMode,\n        }) + trailingNonDigitCharacters;\n        return {\n            selection,\n            value: validatedValue,\n        };\n    };\n}\n\nfunction createValidDateTimePreprocessor({ dateModeTemplate, dateSegmentsSeparator, dateTimeSeparator, timeMode, timeSegmentMaxValues, }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        if (data === dateSegmentsSeparator) {\n            return {\n                elementState,\n                data: selection[0] === value.length ? data : '',\n            };\n        }\n        const newCharacters = data.replaceAll(/\\D/g, '');\n        if (!newCharacters) {\n            return { elementState, data };\n        }\n        const [from, rawTo] = selection;\n        let to = rawTo + data.length;\n        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n        const [dateString, timeString] = parseDateTimeString(newPossibleValue, dateModeTemplate);\n        let validatedValue = '';\n        const hasDateTimeSeparator = newPossibleValue.includes(dateTimeSeparator);\n        const { validatedDateString, updatedSelection } = validateDateString({\n            dateString,\n            dateSegmentsSeparator,\n            dateModeTemplate,\n            offset: 0,\n            selection: [from, to],\n        });\n        if (dateString && !validatedDateString) {\n            return { elementState, data: '' }; // prevent changes\n        }\n        to = updatedSelection[1];\n        validatedValue += validatedDateString;\n        const updatedTimeState = enrichTimeSegmentsWithZeroes({ value: timeString, selection: [from, to] }, { mode: timeMode, timeSegmentMaxValues });\n        to = updatedTimeState.selection[1];\n        validatedValue += hasDateTimeSeparator\n            ? dateTimeSeparator + updatedTimeState.value\n            : updatedTimeState.value;\n        const newData = validatedValue.slice(from, to);\n        return {\n            elementState: {\n                selection,\n                value: validatedValue.slice(0, from) +\n                    newData\n                        .split(dateSegmentsSeparator)\n                        .map((segment) => '0'.repeat(segment.length))\n                        .join(dateSegmentsSeparator) +\n                    validatedValue.slice(to),\n            },\n            data: newData,\n        };\n    };\n}\n\nfunction maskitoDateTimeOptionsGenerator({ dateMode, timeMode, dateSeparator = '.', min, max, dateTimeSeparator = DATE_TIME_SEPARATOR, timeStep = 0, }) {\n    const hasMeridiem = timeMode.includes('AA');\n    const dateModeTemplate = dateMode.split('/').join(dateSeparator);\n    const timeSegmentMaxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), (hasMeridiem ? { hours: 12 } : {}));\n    const timeSegmentMinValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MIN_VALUES), (hasMeridiem ? { hours: 1 } : {}));\n    const fullMode = `${dateModeTemplate}${dateTimeSeparator}${timeMode}`;\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: [\n            ...Array.from(dateModeTemplate).map((char) => dateSeparator.includes(char) ? char : /\\d/),\n            ...dateTimeSeparator.split(''),\n            ...createTimeMaskExpression(timeMode),\n        ], overwriteMode: 'replace', preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createColonConvertPreprocessor(),\n            createFirstDateEndSeparatorPreprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                firstDateEndSeparator: dateTimeSeparator,\n                pseudoFirstDateEndSeparators: dateTimeSeparator.split(''),\n            }),\n            createZeroPlaceholdersPreprocessor(),\n            createMeridiemPreprocessor(timeMode),\n            normalizeDatePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: dateSeparator,\n                dateTimeSeparator,\n            }),\n            createInvalidTimeSegmentInsertionPreprocessor({\n                timeMode,\n                timeSegmentMinValues,\n                timeSegmentMaxValues,\n                parseValue: (x) => {\n                    const [dateString, timeString] = parseDateTimeString(x, dateModeTemplate);\n                    return { timeString, restValue: dateString + dateTimeSeparator };\n                },\n            }),\n            createValidDateTimePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: dateSeparator,\n                dateTimeSeparator,\n                timeMode,\n                timeSegmentMaxValues,\n            }),\n        ], postprocessors: [\n            createMeridiemPostprocessor(timeMode),\n            createDateSegmentsZeroPaddingPostprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                splitFn: (value) => {\n                    const [dateString, timeString] = parseDateTimeString(value, dateModeTemplate);\n                    return { dateStrings: [dateString], restPart: timeString };\n                },\n                uniteFn: ([validatedDateString], initialValue) => validatedDateString +\n                    (initialValue.includes(dateTimeSeparator) ? dateTimeSeparator : ''),\n            }),\n            createMinMaxDateTimePostprocessor({\n                min,\n                max,\n                dateModeTemplate,\n                timeMode,\n                dateTimeSeparator,\n            }),\n        ], plugins: [\n            createTimeSegmentsSteppingPlugin({\n                step: timeStep,\n                fullMode,\n                timeSegmentMaxValues: DEFAULT_TIME_SEGMENT_MAX_VALUES,\n            }),\n            createMeridiemSteppingPlugin(fullMode.indexOf('AA')),\n        ] });\n}\n\n/**\n * It drops prefix and postfix from data\n * Needed for case, when prefix or postfix contain decimalSeparator, to ignore it in resulting number\n * @example User pastes '{prefix}123.45{postfix}' => 123.45\n */\nfunction createAffixesFilterPreprocessor({ prefix, postfix, }) {\n    return ({ elementState, data }) => {\n        const { cleanValue: cleanData } = extractAffixes(data, {\n            prefix,\n            postfix,\n        });\n        return {\n            elementState,\n            data: cleanData,\n        };\n    };\n}\n\nfunction generateMaskExpression({ decimalSeparator, isNegativeAllowed, precision, thousandSeparator, prefix, postfix, decimalPseudoSeparators = [], pseudoMinuses = [], minusSign, }) {\n    const computedPrefix = computeAllOptionalCharsRegExp(prefix);\n    const digit = String.raw `\\d`;\n    const optionalMinus = isNegativeAllowed\n        ? `[${minusSign}${pseudoMinuses.map((x) => `\\\\${x}`).join('')}]?`\n        : '';\n    const integerPart = thousandSeparator\n        ? `[${digit}${escapeRegExp(thousandSeparator).replaceAll(/\\s/g, String.raw `\\s`)}]*`\n        : `[${digit}]*`;\n    const precisionPart = Number.isFinite(precision) ? precision : '';\n    const decimalPart = precision > 0\n        ? `([${escapeRegExp(decimalSeparator)}${decimalPseudoSeparators\n            .map(escapeRegExp)\n            .join('')}]${digit}{0,${precisionPart}})?`\n        : '';\n    const computedPostfix = computeAllOptionalCharsRegExp(postfix);\n    return new RegExp(`^${computedPrefix}${optionalMinus}${integerPart}${decimalPart}${computedPostfix}$`);\n}\nfunction computeAllOptionalCharsRegExp(str) {\n    return str\n        ? `${str\n            .split('')\n            .map((char) => `${escapeRegExp(char)}?`)\n            .join('')}`\n        : '';\n}\n\nfunction maskitoParseNumber(maskedNumber, decimalSeparator = '.') {\n    const hasNegativeSign = !!new RegExp(`^\\\\D*[${CHAR_MINUS}\\\\${CHAR_HYPHEN}${CHAR_EN_DASH}${CHAR_EM_DASH}${CHAR_JP_HYPHEN}]`).exec(maskedNumber);\n    const escapedDecimalSeparator = escapeRegExp(decimalSeparator);\n    const unmaskedNumber = maskedNumber\n        // drop all decimal separators not followed by a digit\n        .replaceAll(new RegExp(`${escapedDecimalSeparator}(?!\\\\d)`, 'g'), '')\n        // drop all non-digit characters except decimal separator\n        .replaceAll(new RegExp(`[^\\\\d${escapedDecimalSeparator}]`, 'g'), '')\n        .replace(decimalSeparator, '.');\n    if (unmaskedNumber) {\n        const sign = hasNegativeSign ? CHAR_HYPHEN : '';\n        return Number(`${sign}${unmaskedNumber}`);\n    }\n    return NaN;\n}\n\n/**\n * Convert number to string with replacing exponent part on decimals\n *\n * @param value the number\n * @return string representation of a number\n */\nfunction stringifyNumberWithoutExp(value) {\n    var _a;\n    const valueAsString = String(value);\n    const [numberPart = '', expPart] = valueAsString.split('e-');\n    let valueWithoutExp = valueAsString;\n    if (expPart) {\n        const [, fractionalPart] = numberPart.split('.');\n        const decimalDigits = Number(expPart) + ((_a = fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) !== null && _a !== void 0 ? _a : 0);\n        valueWithoutExp = value.toFixed(decimalDigits);\n    }\n    return valueWithoutExp;\n}\n\nfunction toNumberParts(value, { decimalSeparator, minusSign }) {\n    const [integerWithMinus = '', decimalPart = ''] = value.split(decimalSeparator);\n    const escapedMinus = escapeRegExp(minusSign);\n    const [, minus = '', integerPart = ''] = new RegExp(`^(?:[^\\\\d${escapedMinus}])?(${escapedMinus})?(.*)`).exec(integerWithMinus) || [];\n    return { minus, integerPart, decimalPart };\n}\n\nfunction validateDecimalPseudoSeparators({ decimalSeparator, thousandSeparator, decimalPseudoSeparators = DEFAULT_DECIMAL_PSEUDO_SEPARATORS, }) {\n    return decimalPseudoSeparators.filter((char) => char !== thousandSeparator && char !== decimalSeparator);\n}\n\n/**\n * If `decimalZeroPadding` is `true`, it pads decimal part with zeroes\n * (until number of digits after decimalSeparator is equal to the `precision`).\n * @example 1,42 => (`precision` is equal to 4) => 1,4200.\n */\nfunction createDecimalZeroPaddingPostprocessor({ decimalSeparator, precision, decimalZeroPadding, prefix, postfix, }) {\n    if (precision <= 0 || !decimalZeroPadding) {\n        return identity;\n    }\n    return ({ value, selection }) => {\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        if (Number.isNaN(maskitoParseNumber(cleanValue, decimalSeparator))) {\n            return { value, selection };\n        }\n        const [integerPart, decimalPart = ''] = cleanValue.split(decimalSeparator);\n        return {\n            value: extractedPrefix +\n                integerPart +\n                decimalSeparator +\n                decimalPart.padEnd(precision, '0') +\n                extractedPostfix,\n            selection,\n        };\n    };\n}\n\n/**\n * Make textfield empty if there is no integer part and all decimal digits are zeroes.\n * @example 0|,00 => Backspace => Empty.\n * @example -0|,00 => Backspace => -.\n * @example ,42| => Backspace x2 => ,|00 => Backspace => Empty\n */\nfunction emptyPostprocessor({ prefix, postfix, decimalSeparator, minusSign, }) {\n    return ({ value, selection }) => {\n        const [caretIndex] = selection;\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const { minus, integerPart, decimalPart } = toNumberParts(cleanValue, {\n            decimalSeparator,\n            minusSign,\n        });\n        const aloneDecimalSeparator = !integerPart && !decimalPart && cleanValue.includes(decimalSeparator);\n        if ((!integerPart &&\n            !Number(decimalPart) &&\n            caretIndex === (minus + extractedPrefix).length) ||\n            aloneDecimalSeparator) {\n            return {\n                selection,\n                value: extractedPrefix + minus + extractedPostfix,\n            };\n        }\n        return { value, selection };\n    };\n}\n\n/**\n * This preprocessor works only once at initialization phase (when `new Maskito(...)` is executed).\n * This preprocessor helps to avoid conflicts during transition from one mask to another (for the same input).\n * For example, the developer changes postfix (or other mask's props) during run-time.\n * ```\n * let maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' year'});\n * // [3 seconds later]\n * maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' years'});\n * ```\n */\nfunction createInitializationOnlyPreprocessor({ decimalSeparator, decimalPseudoSeparators, pseudoMinuses, prefix, postfix, minusSign, }) {\n    let isInitializationPhase = true;\n    const cleanNumberMask = generateMaskExpression({\n        decimalSeparator,\n        decimalPseudoSeparators,\n        pseudoMinuses,\n        prefix: '',\n        postfix: '',\n        thousandSeparator: '',\n        precision: Infinity,\n        isNegativeAllowed: true,\n        minusSign,\n    });\n    return ({ elementState, data }) => {\n        if (!isInitializationPhase) {\n            return { elementState, data };\n        }\n        isInitializationPhase = false;\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const { extractedPrefix, cleanValue, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const cleanState = maskitoTransform({\n            selection: [\n                Math.max(from - extractedPrefix.length, 0),\n                clamp(to - extractedPrefix.length, 0, cleanValue.length),\n            ],\n            value: cleanValue,\n        }, {\n            mask: cleanNumberMask,\n        });\n        const [cleanFrom, cleanTo] = cleanState.selection;\n        return {\n            elementState: {\n                selection: [\n                    cleanFrom + extractedPrefix.length,\n                    cleanTo + extractedPrefix.length,\n                ],\n                value: extractedPrefix + cleanState.value + extractedPostfix,\n            },\n            data,\n        };\n    };\n}\n\n/**\n * It removes repeated leading zeroes for integer part.\n * @example 0,|00005 => Backspace => |5\n * @example -0,|00005 => Backspace => -|5\n * @example User types \"000000\" => 0|\n * @example 0| => User types \"5\" => 5|\n */\nfunction createLeadingZeroesValidationPostprocessor({ decimalSeparator, thousandSeparator, prefix, postfix, }) {\n    const trimLeadingZeroes = (value) => {\n        const escapedThousandSeparator = escapeRegExp(thousandSeparator);\n        return value\n            .replace(\n        // all leading zeroes followed by another zero\n        new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=0)`), '$1')\n            .replace(\n        // zero followed by not-zero digit\n        new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=[1-9])`), '$1');\n    };\n    const countTrimmedZeroesBefore = (value, index) => {\n        const valueBefore = value.slice(0, index);\n        const followedByZero = value.slice(index).startsWith('0');\n        return (valueBefore.length -\n            trimLeadingZeroes(valueBefore).length +\n            (followedByZero ? 1 : 0));\n    };\n    return ({ value, selection }) => {\n        const [from, to] = selection;\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const hasDecimalSeparator = cleanValue.includes(decimalSeparator);\n        const [integerPart = '', decimalPart = ''] = cleanValue.split(decimalSeparator);\n        const zeroTrimmedIntegerPart = trimLeadingZeroes(integerPart);\n        if (integerPart === zeroTrimmedIntegerPart) {\n            return { value, selection };\n        }\n        const newFrom = from - countTrimmedZeroesBefore(value, from);\n        const newTo = to - countTrimmedZeroesBefore(value, to);\n        return {\n            value: extractedPrefix +\n                zeroTrimmedIntegerPart +\n                (hasDecimalSeparator ? decimalSeparator : '') +\n                decimalPart +\n                extractedPostfix,\n            selection: [Math.max(newFrom, 0), Math.max(newTo, 0)],\n        };\n    };\n}\n\n/**\n * This postprocessor is connected with {@link createMinMaxPlugin}:\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\n */\nfunction createMinMaxPostprocessor({ min, max, decimalSeparator, minusSign, }) {\n    return ({ value, selection }) => {\n        const parsedNumber = maskitoParseNumber(value, decimalSeparator);\n        const limitedValue = \n        /**\n         * We cannot limit lower bound if user enters positive number.\n         * The same for upper bound and negative number.\n         * ___\n         * @example (min = 5)\n         * Empty input => Without this condition user cannot type 42 (the first digit will be rejected)\n         * ___\n         * @example (max = -10)\n         * Value is -10 => Without this condition user cannot delete 0 to enter another digit\n         */\n        parsedNumber > 0 ? Math.min(parsedNumber, max) : Math.max(parsedNumber, min);\n        if (parsedNumber && limitedValue !== parsedNumber) {\n            const newValue = `${limitedValue}`\n                .replace('.', decimalSeparator)\n                .replace(CHAR_HYPHEN, minusSign);\n            return {\n                value: newValue,\n                selection: [newValue.length, newValue.length],\n            };\n        }\n        return {\n            value,\n            selection,\n        };\n    };\n}\n\n/**\n * Manage caret-navigation when user \"deletes\" non-removable digits or separators\n * @example 1,|42 => Backspace => 1|,42 (only if `decimalZeroPadding` is `true`)\n * @example 1|,42 => Delete => 1,|42 (only if `decimalZeroPadding` is `true`)\n * @example 0,|00 => Delete => 0,0|0 (only if `decimalZeroPadding` is `true`)\n * @example 1 |000 => Backspace => 1| 000 (always)\n */\nfunction createNonRemovableCharsDeletionPreprocessor({ decimalSeparator, thousandSeparator, decimalZeroPadding, }) {\n    return ({ elementState, data }, actionType) => {\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const selectedCharacters = value.slice(from, to);\n        const nonRemovableSeparators = decimalZeroPadding\n            ? [decimalSeparator, thousandSeparator]\n            : [thousandSeparator];\n        const areNonRemovableZeroesSelected = decimalZeroPadding &&\n            from > value.indexOf(decimalSeparator) &&\n            Boolean(selectedCharacters.match(/^0+$/gi));\n        if ((actionType !== 'deleteBackward' && actionType !== 'deleteForward') ||\n            (!nonRemovableSeparators.includes(selectedCharacters) &&\n                !areNonRemovableZeroesSelected)) {\n            return {\n                elementState,\n                data,\n            };\n        }\n        return {\n            elementState: {\n                value,\n                selection: actionType === 'deleteForward' ? [to, to] : [from, from],\n            },\n            data,\n        };\n    };\n}\n\n/**\n * It pads integer part with zero if user types decimal separator (for empty input).\n * @example Empty input => User types \",\" (decimal separator) => 0,|\n */\nfunction createNotEmptyIntegerPartPreprocessor({ decimalSeparator, precision, prefix, postfix, }) {\n    const startWithDecimalSepRegExp = new RegExp(`^\\\\D*${escapeRegExp(decimalSeparator)}`);\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const { cleanValue, extractedPrefix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const [from, to] = selection;\n        const cleanFrom = clamp(from - extractedPrefix.length, 0, cleanValue.length);\n        const cleanTo = clamp(to - extractedPrefix.length, 0, cleanValue.length);\n        if (precision <= 0 ||\n            cleanValue.slice(0, cleanFrom).includes(decimalSeparator) ||\n            cleanValue.slice(cleanTo).includes(decimalSeparator) ||\n            !data.match(startWithDecimalSepRegExp)) {\n            return { elementState, data };\n        }\n        const digitsBeforeCursor = /\\d+/.exec(cleanValue.slice(0, cleanFrom));\n        return {\n            elementState,\n            data: digitsBeforeCursor ? data : `0${data}`,\n        };\n    };\n}\n\n/**\n * It replaces pseudo characters with valid one.\n * @example User types '.' (but separator is equal to comma) => dot is replaced with comma.\n * @example User types hyphen / en-dash / em-dash => it is replaced with minus.\n */\nfunction createPseudoCharactersPreprocessor({ validCharacter, pseudoCharacters, prefix, postfix, }) {\n    const pseudoCharactersRegExp = new RegExp(`[${pseudoCharacters.join('')}]`, 'gi');\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const { cleanValue, extractedPostfix, extractedPrefix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        return {\n            elementState: {\n                selection,\n                value: extractedPrefix +\n                    cleanValue.replace(pseudoCharactersRegExp, validCharacter) +\n                    extractedPostfix,\n            },\n            data: data.replace(pseudoCharactersRegExp, validCharacter),\n        };\n    };\n}\n\n/**\n * It rejects new typed decimal separator if it already exists in text field.\n * Behaviour is similar to native <input type=\"number\"> (Chrome).\n * @example 1|23,45 => Press comma (decimal separator) => 1|23,45 (do nothing).\n */\nfunction createRepeatedDecimalSeparatorPreprocessor({ decimalSeparator, prefix, postfix, }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const { cleanValue } = extractAffixes(value, { prefix, postfix });\n        return {\n            elementState,\n            data: !cleanValue.includes(decimalSeparator) ||\n                value.slice(from, to + 1).includes(decimalSeparator)\n                ? data\n                : data.replaceAll(new RegExp(escapeRegExp(decimalSeparator), 'gi'), ''),\n        };\n    };\n}\n\n/**\n * It adds symbol for separating thousands.\n * @example 1000000 => (thousandSeparator is equal to space) => 1 000 000.\n */\nfunction createThousandSeparatorPostprocessor({ thousandSeparator, decimalSeparator, prefix, postfix, minusSign, }) {\n    if (!thousandSeparator) {\n        return identity;\n    }\n    const isAllSpaces = (...chars) => chars.every((x) => /\\s/.test(x));\n    return ({ value, selection }) => {\n        const [initialFrom, initialTo] = selection;\n        let [from, to] = selection;\n        const { cleanValue, extractedPostfix, extractedPrefix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const { minus, integerPart, decimalPart } = toNumberParts(cleanValue, {\n            decimalSeparator,\n            minusSign,\n        });\n        const deletedChars = cleanValue.length -\n            (minus +\n                integerPart +\n                (cleanValue.includes(decimalSeparator)\n                    ? decimalSeparator + decimalPart\n                    : '')).length;\n        if (deletedChars > 0 && initialFrom && initialFrom <= deletedChars) {\n            from -= deletedChars;\n        }\n        if (deletedChars > 0 && initialTo && initialTo <= deletedChars) {\n            to -= deletedChars;\n        }\n        const processedIntegerPart = Array.from(integerPart).reduceRight((formattedValuePart, char, i) => {\n            const isLeadingThousandSeparator = !i && char === thousandSeparator;\n            const isPositionForSeparator = !isLeadingThousandSeparator &&\n                Boolean(formattedValuePart.length) &&\n                (formattedValuePart.length + 1) % 4 === 0;\n            const isSeparator = char === thousandSeparator || isAllSpaces(char, thousandSeparator);\n            if (isPositionForSeparator && isSeparator) {\n                return thousandSeparator + formattedValuePart;\n            }\n            if (!isPositionForSeparator && isSeparator) {\n                if (i && i <= initialFrom) {\n                    from--;\n                }\n                if (i && i <= initialTo) {\n                    to--;\n                }\n                return formattedValuePart;\n            }\n            if (!isPositionForSeparator) {\n                return char + formattedValuePart;\n            }\n            if (i < initialFrom) {\n                from++;\n            }\n            if (i < initialTo) {\n                to++;\n            }\n            return char + thousandSeparator + formattedValuePart;\n        }, '');\n        return {\n            value: extractedPrefix +\n                minus +\n                processedIntegerPart +\n                (cleanValue.includes(decimalSeparator) ? decimalSeparator : '') +\n                decimalPart +\n                extractedPostfix,\n            selection: [from, to],\n        };\n    };\n}\n\n/**\n * It drops decimal part if precision is zero.\n * @example User pastes '123.45' (but precision is zero) => 123\n */\nfunction createZeroPrecisionPreprocessor({ precision, decimalSeparator, prefix, postfix, }) {\n    if (precision > 0) {\n        return identity;\n    }\n    const decimalPartRegExp = new RegExp(`${escapeRegExp(decimalSeparator)}.*$`, 'g');\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const [from, to] = selection;\n        const newValue = extractedPrefix +\n            cleanValue.replace(decimalPartRegExp, '') +\n            extractedPostfix;\n        return {\n            elementState: {\n                selection: [\n                    Math.min(from, newValue.length),\n                    Math.min(to, newValue.length),\n                ],\n                value: newValue,\n            },\n            data: data.replace(decimalPartRegExp, ''),\n        };\n    };\n}\n\nconst DUMMY_SELECTION = [0, 0];\n/**\n * It removes repeated leading zeroes for integer part on blur-event.\n * @example 000000 => blur => 0\n * @example 00005 => blur => 5\n */\nfunction createLeadingZeroesValidationPlugin({ decimalSeparator, thousandSeparator, prefix, postfix, }) {\n    const dropRepeatedLeadingZeroes = createLeadingZeroesValidationPostprocessor({\n        decimalSeparator,\n        thousandSeparator,\n        prefix,\n        postfix,\n    });\n    return maskitoEventHandler('blur', (element) => {\n        const newValue = dropRepeatedLeadingZeroes({\n            value: element.value,\n            selection: DUMMY_SELECTION,\n        }, { value: '', selection: DUMMY_SELECTION }).value;\n        maskitoUpdateElement(element, newValue);\n    }, { capture: true });\n}\n\n/**\n * This plugin is connected with {@link createMinMaxPostprocessor}:\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\n */\nfunction createMinMaxPlugin({ min, max, decimalSeparator, }) {\n    return maskitoEventHandler('blur', (element, options) => {\n        const parsedNumber = maskitoParseNumber(element.value, decimalSeparator);\n        const clampedNumber = clamp(parsedNumber, min, max);\n        if (!Number.isNaN(parsedNumber) && parsedNumber !== clampedNumber) {\n            maskitoUpdateElement(element, maskitoTransform(stringifyNumberWithoutExp(clampedNumber), options));\n        }\n    }, { capture: true });\n}\n\n/**\n * It pads EMPTY integer part with zero if decimal parts exists.\n * It works on blur event only!\n * @example 1|,23 => Backspace => Blur => 0,23\n */\nfunction createNotEmptyIntegerPlugin({ decimalSeparator, prefix, postfix, }) {\n    return maskitoEventHandler('blur', (element) => {\n        const { cleanValue, extractedPostfix, extractedPrefix } = extractAffixes(element.value, { prefix, postfix });\n        const newValue = extractedPrefix +\n            cleanValue.replace(new RegExp(`^(\\\\D+)?${escapeRegExp(decimalSeparator)}`), `$10${decimalSeparator}`) +\n            extractedPostfix;\n        maskitoUpdateElement(element, newValue);\n    }, { capture: true });\n}\n\nfunction maskitoNumberOptionsGenerator({ max = Number.MAX_SAFE_INTEGER, min = Number.MIN_SAFE_INTEGER, precision = 0, thousandSeparator = CHAR_NO_BREAK_SPACE, decimalSeparator = '.', decimalPseudoSeparators, decimalZeroPadding = false, prefix: unsafePrefix = '', postfix = '', minusSign = CHAR_MINUS, } = {}) {\n    const pseudoMinuses = [\n        CHAR_HYPHEN,\n        CHAR_EN_DASH,\n        CHAR_EM_DASH,\n        CHAR_JP_HYPHEN,\n        CHAR_MINUS,\n    ].filter((char) => char !== thousandSeparator && char !== decimalSeparator && char !== minusSign);\n    const validatedDecimalPseudoSeparators = validateDecimalPseudoSeparators({\n        decimalSeparator,\n        thousandSeparator,\n        decimalPseudoSeparators,\n    });\n    const prefix = unsafePrefix.endsWith(decimalSeparator) && precision > 0\n        ? `${unsafePrefix}${CHAR_ZERO_WIDTH_SPACE}`\n        : unsafePrefix;\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: generateMaskExpression({\n            decimalSeparator,\n            precision,\n            thousandSeparator,\n            prefix,\n            postfix,\n            isNegativeAllowed: min < 0,\n            minusSign,\n        }), preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createInitializationOnlyPreprocessor({\n                decimalSeparator,\n                decimalPseudoSeparators: validatedDecimalPseudoSeparators,\n                pseudoMinuses,\n                prefix,\n                postfix,\n                minusSign,\n            }),\n            createAffixesFilterPreprocessor({ prefix, postfix }),\n            createPseudoCharactersPreprocessor({\n                validCharacter: minusSign,\n                pseudoCharacters: pseudoMinuses,\n                prefix,\n                postfix,\n            }),\n            createPseudoCharactersPreprocessor({\n                validCharacter: decimalSeparator,\n                pseudoCharacters: validatedDecimalPseudoSeparators,\n                prefix,\n                postfix,\n            }),\n            createNotEmptyIntegerPartPreprocessor({\n                decimalSeparator,\n                precision,\n                prefix,\n                postfix,\n            }),\n            createNonRemovableCharsDeletionPreprocessor({\n                decimalSeparator,\n                decimalZeroPadding,\n                thousandSeparator,\n            }),\n            createZeroPrecisionPreprocessor({\n                precision,\n                decimalSeparator,\n                prefix,\n                postfix,\n            }),\n            createRepeatedDecimalSeparatorPreprocessor({\n                decimalSeparator,\n                prefix,\n                postfix,\n            }),\n        ], postprocessors: [\n            createMinMaxPostprocessor({ decimalSeparator, min, max, minusSign }),\n            maskitoPrefixPostprocessorGenerator(prefix),\n            maskitoPostfixPostprocessorGenerator(postfix),\n            createThousandSeparatorPostprocessor({\n                decimalSeparator,\n                thousandSeparator,\n                prefix,\n                postfix,\n                minusSign,\n            }),\n            createDecimalZeroPaddingPostprocessor({\n                decimalSeparator,\n                decimalZeroPadding,\n                precision,\n                prefix,\n                postfix,\n            }),\n            emptyPostprocessor({\n                prefix,\n                postfix,\n                decimalSeparator,\n                minusSign,\n            }),\n        ], plugins: [\n            createLeadingZeroesValidationPlugin({\n                decimalSeparator,\n                thousandSeparator,\n                prefix,\n                postfix,\n            }),\n            createNotEmptyIntegerPlugin({\n                decimalSeparator,\n                prefix,\n                postfix,\n            }),\n            createMinMaxPlugin({ min, max, decimalSeparator }),\n        ], overwriteMode: decimalZeroPadding\n            ? ({ value, selection: [from] }) => from <= value.indexOf(decimalSeparator) ? 'shift' : 'replace'\n            : 'shift' });\n}\n\nfunction maskitoTimeOptionsGenerator({ mode, timeSegmentMaxValues = {}, timeSegmentMinValues = {}, step = 0, }) {\n    const hasMeridiem = mode.includes('AA');\n    const enrichedTimeSegmentMaxValues = Object.assign(Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), (hasMeridiem ? { hours: 12 } : {})), timeSegmentMaxValues);\n    const enrichedTimeSegmentMinValues = Object.assign(Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MIN_VALUES), (hasMeridiem ? { hours: 1 } : {})), timeSegmentMinValues);\n    return {\n        mask: createTimeMaskExpression(mode),\n        preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createColonConvertPreprocessor(),\n            createZeroPlaceholdersPreprocessor(),\n            createMeridiemPreprocessor(mode),\n            createInvalidTimeSegmentInsertionPreprocessor({\n                timeMode: mode,\n                timeSegmentMinValues: enrichedTimeSegmentMinValues,\n                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,\n            }),\n        ],\n        postprocessors: [\n            createMeridiemPostprocessor(mode),\n            (elementState) => enrichTimeSegmentsWithZeroes(elementState, {\n                mode,\n                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,\n            }),\n        ],\n        plugins: [\n            createTimeSegmentsSteppingPlugin({\n                fullMode: mode,\n                step,\n                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,\n            }),\n            createMeridiemSteppingPlugin(mode.indexOf('AA')),\n        ],\n        overwriteMode: 'replace',\n    };\n}\n\n/**\n * Converts a formatted time string to milliseconds based on the given `options.mode`.\n *\n * @param maskedTime a formatted time string by {@link maskitoTimeOptionsGenerator} or {@link maskitoStringifyTime}\n * @param params\n */\nfunction maskitoParseTime(maskedTime, { mode, timeSegmentMaxValues = {} }) {\n    var _a, _b, _c, _d;\n    const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n    const msInSecond = maxValues.milliseconds + 1;\n    const msInMinute = (maxValues.seconds + 1) * msInSecond;\n    const msInHour = (maxValues.minutes + 1) * msInMinute;\n    const parsedTime = padEndTimeSegments(parseTimeString(maskedTime, mode));\n    return (Number((_a = parsedTime.hours) !== null && _a !== void 0 ? _a : '') * msInHour +\n        Number((_b = parsedTime.minutes) !== null && _b !== void 0 ? _b : '') * msInMinute +\n        Number((_c = parsedTime.seconds) !== null && _c !== void 0 ? _c : '') * msInSecond +\n        Number((_d = parsedTime.milliseconds) !== null && _d !== void 0 ? _d : ''));\n}\n\n/**\n * Converts milliseconds to a formatted time string based on the given `options.mode`.\n *\n * @param milliseconds unsigned integer milliseconds\n * @param params\n */\nfunction maskitoStringifyTime(milliseconds, { mode, timeSegmentMaxValues = {} }) {\n    const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n    const msInSecond = maxValues.milliseconds + 1;\n    const msInMinute = (maxValues.seconds + 1) * msInSecond;\n    const msInHour = (maxValues.minutes + 1) * msInMinute;\n    const hours = Math.trunc(milliseconds / msInHour);\n    milliseconds -= hours * msInHour;\n    const minutes = Math.trunc(milliseconds / msInMinute);\n    milliseconds -= minutes * msInMinute;\n    const seconds = Math.trunc(milliseconds / msInSecond);\n    milliseconds -= seconds * msInSecond;\n    const result = padStartTimeSegments({ hours, minutes, seconds, milliseconds });\n    return mode\n        .replaceAll(/H+/g, result.hours)\n        .replaceAll('MSS', result.milliseconds)\n        .replaceAll(/M+/g, result.minutes)\n        .replaceAll(/S+/g, result.seconds);\n}\n\nexport { maskitoAddOnFocusPlugin, maskitoCaretGuard, maskitoDateOptionsGenerator, maskitoDateRangeOptionsGenerator, maskitoDateTimeOptionsGenerator, maskitoEventHandler, maskitoNumberOptionsGenerator, maskitoParseNumber, maskitoParseTime, maskitoPostfixPostprocessorGenerator, maskitoPrefixPostprocessorGenerator, maskitoRejectEvent, maskitoRemoveOnBlurPlugin, maskitoStringifyTime, maskitoTimeOptionsGenerator, maskitoWithPlaceholder };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}