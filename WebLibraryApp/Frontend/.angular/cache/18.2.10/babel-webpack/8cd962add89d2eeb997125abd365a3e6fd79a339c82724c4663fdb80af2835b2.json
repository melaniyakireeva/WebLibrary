{"ast":null,"code":"function getContentEditableSelection(element) {\n  const {\n    anchorOffset = 0,\n    focusOffset = 0\n  } = element.ownerDocument.getSelection() || {};\n  const from = Math.min(anchorOffset, focusOffset);\n  const to = Math.max(anchorOffset, focusOffset);\n  return [from, to];\n}\nfunction setContentEditableSelection(element, [from, to]) {\n  var _a, _b, _c, _d;\n  const document = element.ownerDocument;\n  const range = document.createRange();\n  range.setStart(element.firstChild || element, Math.min(from, (_b = (_a = element.textContent) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0));\n  range.setEnd(element.lastChild || element, Math.min(to, (_d = (_c = element.textContent) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0));\n  const selection = document.getSelection();\n  if (selection) {\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n}\nclass ContentEditableAdapter {\n  constructor(element) {\n    this.element = element;\n    this.maxLength = Infinity;\n  }\n  get value() {\n    return this.element.innerText.replace(/\\n\\n$/, '\\n');\n  }\n  set value(value) {\n    // Setting into innerHTML of element with `white-space: pre;` style\n    this.element.innerHTML = value.replace(/\\n$/, '\\n\\n');\n  }\n  get selectionStart() {\n    return getContentEditableSelection(this.element)[0];\n  }\n  get selectionEnd() {\n    return getContentEditableSelection(this.element)[1];\n  }\n  setSelectionRange(from, to) {\n    setContentEditableSelection(this.element, [from !== null && from !== void 0 ? from : 0, to !== null && to !== void 0 ? to : 0]);\n  }\n  select() {\n    this.setSelectionRange(0, this.value.length);\n  }\n}\nfunction maskitoAdaptContentEditable(element) {\n  const adapter = new ContentEditableAdapter(element);\n  return new Proxy(element, {\n    get(target, prop) {\n      if (prop in adapter) {\n        return adapter[prop];\n      }\n      const nativeProperty = target[prop];\n      return typeof nativeProperty === 'function' ? nativeProperty.bind(target) : nativeProperty;\n    },\n    set(target, prop, val, receiver) {\n      return Reflect.set(prop in adapter ? adapter : target, prop, val, receiver);\n    }\n  });\n}\nconst MASKITO_DEFAULT_ELEMENT_PREDICATE = e => e.isContentEditable ? maskitoAdaptContentEditable(e) : e.querySelector('input,textarea') || e;\nconst MASKITO_DEFAULT_OPTIONS = {\n  mask: /^.*$/,\n  preprocessors: [],\n  postprocessors: [],\n  plugins: [],\n  overwriteMode: 'shift'\n};\nclass MaskHistory {\n  constructor() {\n    this.now = null;\n    this.past = [];\n    this.future = [];\n  }\n  undo() {\n    const state = this.past.pop();\n    if (state && this.now) {\n      this.future.push(this.now);\n      this.updateElement(state, 'historyUndo');\n    }\n  }\n  redo() {\n    const state = this.future.pop();\n    if (state && this.now) {\n      this.past.push(this.now);\n      this.updateElement(state, 'historyRedo');\n    }\n  }\n  updateHistory(state) {\n    if (!this.now) {\n      this.now = state;\n      return;\n    }\n    const isValueChanged = this.now.value !== state.value;\n    const isSelectionChanged = this.now.selection.some((item, index) => item !== state.selection[index]);\n    if (!isValueChanged && !isSelectionChanged) {\n      return;\n    }\n    if (isValueChanged) {\n      this.past.push(this.now);\n      this.future = [];\n    }\n    this.now = state;\n  }\n  updateElement(state, inputType) {\n    this.now = state;\n    this.updateElementState(state, {\n      inputType,\n      data: null\n    });\n  }\n}\nfunction areElementValuesEqual(sampleState, ...states) {\n  return states.every(({\n    value\n  }) => value === sampleState.value);\n}\nfunction areElementStatesEqual(sampleState, ...states) {\n  return states.every(({\n    value,\n    selection\n  }) => value === sampleState.value && selection[0] === sampleState.selection[0] && selection[1] === sampleState.selection[1]);\n}\nfunction applyOverwriteMode({\n  value,\n  selection\n}, newCharacters, mode) {\n  const [from, to] = selection;\n  const computedMode = typeof mode === 'function' ? mode({\n    value,\n    selection\n  }) : mode;\n  return {\n    value,\n    selection: computedMode === 'replace' ? [from, Math.max(from + newCharacters.length, to)] : [from, to]\n  };\n}\nfunction isFixedCharacter(char) {\n  return typeof char === 'string';\n}\nfunction getLeadingFixedCharacters(mask, validatedValuePart, newCharacter, initialElementState) {\n  let leadingFixedCharacters = '';\n  for (let i = validatedValuePart.length; i < mask.length; i++) {\n    const charConstraint = mask[i] || '';\n    const isInitiallyExisted = (initialElementState === null || initialElementState === void 0 ? void 0 : initialElementState.value[i]) === charConstraint;\n    if (!isFixedCharacter(charConstraint) || charConstraint === newCharacter && !isInitiallyExisted) {\n      return leadingFixedCharacters;\n    }\n    leadingFixedCharacters += charConstraint;\n  }\n  return leadingFixedCharacters;\n}\nfunction validateValueWithMask(value, maskExpression) {\n  if (Array.isArray(maskExpression)) {\n    return value.length === maskExpression.length && Array.from(value).every((char, i) => {\n      const charConstraint = maskExpression[i] || '';\n      return isFixedCharacter(charConstraint) ? char === charConstraint : char.match(charConstraint);\n    });\n  }\n  return maskExpression.test(value);\n}\nfunction guessValidValueByPattern(elementState, mask, initialElementState) {\n  let maskedFrom = null;\n  let maskedTo = null;\n  const maskedValue = Array.from(elementState.value).reduce((validatedCharacters, char, charIndex) => {\n    const leadingCharacters = getLeadingFixedCharacters(mask, validatedCharacters, char, initialElementState);\n    const newValidatedChars = validatedCharacters + leadingCharacters;\n    const charConstraint = mask[newValidatedChars.length] || '';\n    if (maskedFrom === null && charIndex >= elementState.selection[0]) {\n      maskedFrom = newValidatedChars.length;\n    }\n    if (maskedTo === null && charIndex >= elementState.selection[1]) {\n      maskedTo = newValidatedChars.length;\n    }\n    if (isFixedCharacter(charConstraint)) {\n      return newValidatedChars + charConstraint;\n    }\n    return char.match(charConstraint) ? newValidatedChars + char : newValidatedChars;\n  }, '');\n  const trailingFixedCharacters = getLeadingFixedCharacters(mask, maskedValue, '', initialElementState);\n  return {\n    value: validateValueWithMask(maskedValue + trailingFixedCharacters, mask) ? maskedValue + trailingFixedCharacters : maskedValue,\n    selection: [maskedFrom !== null && maskedFrom !== void 0 ? maskedFrom : maskedValue.length, maskedTo !== null && maskedTo !== void 0 ? maskedTo : maskedValue.length]\n  };\n}\nfunction guessValidValueByRegExp({\n  value,\n  selection\n}, maskRegExp) {\n  const [from, to] = selection;\n  let newFrom = from;\n  let newTo = to;\n  const validatedValue = Array.from(value).reduce((validatedValuePart, char, i) => {\n    const newPossibleValue = validatedValuePart + char;\n    if (from === i) {\n      newFrom = validatedValuePart.length;\n    }\n    if (to === i) {\n      newTo = validatedValuePart.length;\n    }\n    return newPossibleValue.match(maskRegExp) ? newPossibleValue : validatedValuePart;\n  }, '');\n  return {\n    value: validatedValue,\n    selection: [newFrom, newTo]\n  };\n}\nfunction calibrateValueByMask(elementState, mask, initialElementState = null) {\n  if (validateValueWithMask(elementState.value, mask)) {\n    return elementState;\n  }\n  const {\n    value,\n    selection\n  } = Array.isArray(mask) ? guessValidValueByPattern(elementState, mask, initialElementState) : guessValidValueByRegExp(elementState, mask);\n  return {\n    selection,\n    value: Array.isArray(mask) ? value.slice(0, mask.length) : value\n  };\n}\nfunction removeFixedMaskCharacters(initialElementState, mask) {\n  if (!Array.isArray(mask)) {\n    return initialElementState;\n  }\n  const [from, to] = initialElementState.selection;\n  const selection = [];\n  const unmaskedValue = Array.from(initialElementState.value).reduce((rawValue, char, i) => {\n    const charConstraint = mask[i] || '';\n    if (i === from) {\n      selection.push(rawValue.length);\n    }\n    if (i === to) {\n      selection.push(rawValue.length);\n    }\n    return isFixedCharacter(charConstraint) && charConstraint === char ? rawValue : rawValue + char;\n  }, '');\n  if (selection.length < 2) {\n    selection.push(...new Array(2 - selection.length).fill(unmaskedValue.length));\n  }\n  return {\n    value: unmaskedValue,\n    selection: [selection[0], selection[1]]\n  };\n}\nclass MaskModel {\n  constructor(initialElementState, maskOptions) {\n    this.initialElementState = initialElementState;\n    this.maskOptions = maskOptions;\n    this.value = '';\n    this.selection = [0, 0];\n    const {\n      value,\n      selection\n    } = calibrateValueByMask(this.initialElementState, this.getMaskExpression(this.initialElementState));\n    this.value = value;\n    this.selection = selection;\n  }\n  addCharacters([from, to], newCharacters) {\n    const {\n      value,\n      maskOptions\n    } = this;\n    const maskExpression = this.getMaskExpression({\n      value: value.slice(0, from) + newCharacters + value.slice(to),\n      selection: [from + newCharacters.length, from + newCharacters.length]\n    });\n    const initialElementState = {\n      value,\n      selection: [from, to]\n    };\n    const unmaskedElementState = removeFixedMaskCharacters(initialElementState, maskExpression);\n    const [unmaskedFrom, unmaskedTo] = applyOverwriteMode(unmaskedElementState, newCharacters, maskOptions.overwriteMode).selection;\n    const newUnmaskedLeadingValuePart = unmaskedElementState.value.slice(0, unmaskedFrom) + newCharacters;\n    const newCaretIndex = newUnmaskedLeadingValuePart.length;\n    const maskedElementState = calibrateValueByMask({\n      value: newUnmaskedLeadingValuePart + unmaskedElementState.value.slice(unmaskedTo),\n      selection: [newCaretIndex, newCaretIndex]\n    }, maskExpression, initialElementState);\n    const isInvalidCharsInsertion = value.slice(0, from) === calibrateValueByMask({\n      value: newUnmaskedLeadingValuePart,\n      selection: [newCaretIndex, newCaretIndex]\n    }, maskExpression, initialElementState).value;\n    if (isInvalidCharsInsertion || areElementStatesEqual(this, maskedElementState) // If typing new characters does not change value\n    ) {\n      throw new Error('Invalid mask value');\n    }\n    this.value = maskedElementState.value;\n    this.selection = maskedElementState.selection;\n  }\n  deleteCharacters([from, to]) {\n    if (from === to || !to) {\n      return;\n    }\n    const {\n      value\n    } = this;\n    const maskExpression = this.getMaskExpression({\n      value: value.slice(0, from) + value.slice(to),\n      selection: [from, from]\n    });\n    const initialElementState = {\n      value,\n      selection: [from, to]\n    };\n    const unmaskedElementState = removeFixedMaskCharacters(initialElementState, maskExpression);\n    const [unmaskedFrom, unmaskedTo] = unmaskedElementState.selection;\n    const newUnmaskedValue = unmaskedElementState.value.slice(0, unmaskedFrom) + unmaskedElementState.value.slice(unmaskedTo);\n    const maskedElementState = calibrateValueByMask({\n      value: newUnmaskedValue,\n      selection: [unmaskedFrom, unmaskedFrom]\n    }, maskExpression, initialElementState);\n    this.value = maskedElementState.value;\n    this.selection = maskedElementState.selection;\n  }\n  getMaskExpression(elementState) {\n    const {\n      mask\n    } = this.maskOptions;\n    return typeof mask === 'function' ? mask(elementState) : mask;\n  }\n}\nclass EventListener {\n  constructor(element) {\n    this.element = element;\n    this.listeners = [];\n  }\n  listen(eventType, fn, options) {\n    const untypedFn = fn;\n    this.element.addEventListener(eventType, untypedFn, options);\n    this.listeners.push(() => this.element.removeEventListener(eventType, untypedFn, options));\n  }\n  destroy() {\n    this.listeners.forEach(stopListen => stopListen());\n  }\n}\nconst HotkeyModifier = {\n  CTRL: 1 << 0,\n  ALT: 1 << 1,\n  SHIFT: 1 << 2,\n  META: 1 << 3\n};\n// TODO add variants that can be processed correctly\nconst HotkeyCode = {\n  Y: 89,\n  Z: 90\n};\n/**\n * Checks if the passed keyboard event match the required hotkey.\n *\n * @example\n * input.addEventListener('keydown', (event) => {\n *     if (isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z)) {\n *         // redo hotkey pressed\n *     }\n * })\n *\n * @return will return `true` only if the {@link HotkeyCode} matches and only the necessary\n * {@link HotkeyModifier modifiers} have been pressed\n */\nfunction isHotkey(event, modifiers, hotkeyCode) {\n  return event.ctrlKey === !!(modifiers & HotkeyModifier.CTRL) && event.altKey === !!(modifiers & HotkeyModifier.ALT) && event.shiftKey === !!(modifiers & HotkeyModifier.SHIFT) && event.metaKey === !!(modifiers & HotkeyModifier.META) &&\n  /**\n   * We intentionally use legacy {@link KeyboardEvent#keyCode `keyCode`} property. It is more\n   * \"keyboard-layout\"-independent than {@link KeyboardEvent#key `key`} or {@link KeyboardEvent#code `code`} properties.\n   * @see {@link https://github.com/taiga-family/maskito/issues/315 `KeyboardEvent#code` issue}\n   */\n  event.keyCode === hotkeyCode;\n}\nfunction isRedo(event) {\n  return isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Y) ||\n  // Windows\n  isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z) ||\n  // Windows & Android\n  isHotkey(event, HotkeyModifier.META | HotkeyModifier.SHIFT, HotkeyCode.Z) // macOS & iOS\n  ;\n}\nfunction isUndo(event) {\n  return isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Z) ||\n  // Windows & Android\n  isHotkey(event, HotkeyModifier.META, HotkeyCode.Z) // macOS & iOS\n  ;\n}\n\n/**\n * Sets value to element, and dispatches input event\n * if you passed ELementState, it also sets selection range\n *\n * @example\n * maskitoUpdateElement(input, newValue);\n * maskitoUpdateElement(input, elementState);\n *\n * @see {@link https://github.com/taiga-family/maskito/issues/804 issue}\n *\n * @return void\n */\nfunction maskitoUpdateElement(element, valueOrElementState) {\n  var _a;\n  const initialValue = element.value;\n  if (typeof valueOrElementState === 'string') {\n    element.value = valueOrElementState;\n  } else {\n    const [from, to] = valueOrElementState.selection;\n    element.value = valueOrElementState.value;\n    if (element.matches(':focus')) {\n      (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n    }\n  }\n  if (element.value !== initialValue) {\n    element.dispatchEvent(new Event('input',\n    /**\n     * React handles this event only on bubbling phase\n     *\n     * here is the list of events that are processed in the capture stage, others are processed in the bubbling stage\n     * https://github.com/facebook/react/blob/cb2439624f43c510007f65aea5c50a8bb97917e4/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js#L222\n     */\n    {\n      bubbles: true\n    }));\n  }\n}\nfunction getLineSelection({\n  value,\n  selection\n}, isForward) {\n  const [from, to] = selection;\n  if (from !== to) {\n    return [from, to];\n  }\n  const nearestBreak = isForward ? value.slice(from).indexOf('\\n') + 1 || value.length : value.slice(0, to).lastIndexOf('\\n') + 1;\n  const selectFrom = isForward ? from : nearestBreak;\n  const selectTo = isForward ? nearestBreak : to;\n  return [selectFrom, selectTo];\n}\nfunction getNotEmptySelection({\n  value,\n  selection\n}, isForward) {\n  const [from, to] = selection;\n  if (from !== to) {\n    return [from, to];\n  }\n  const notEmptySelection = isForward ? [from, to + 1] : [from - 1, to];\n  return notEmptySelection.map(x => Math.min(Math.max(x, 0), value.length));\n}\nconst TRAILING_SPACES_REG = /\\s+$/g;\nconst LEADING_SPACES_REG = /^\\s+/g;\nconst SPACE_REG = /\\s/;\nfunction getWordSelection({\n  value,\n  selection\n}, isForward) {\n  const [from, to] = selection;\n  if (from !== to) {\n    return [from, to];\n  }\n  if (isForward) {\n    const valueAfterSelectionStart = value.slice(from);\n    const [leadingSpaces] = valueAfterSelectionStart.match(LEADING_SPACES_REG) || [''];\n    const nearestWordEndIndex = valueAfterSelectionStart.trimStart().search(SPACE_REG);\n    return [from, nearestWordEndIndex !== -1 ? from + leadingSpaces.length + nearestWordEndIndex : value.length];\n  }\n  const valueBeforeSelectionEnd = value.slice(0, to);\n  const [trailingSpaces] = valueBeforeSelectionEnd.match(TRAILING_SPACES_REG) || [''];\n  const selectedWordLength = valueBeforeSelectionEnd.trimEnd().split('').reverse().findIndex(char => SPACE_REG.exec(char));\n  return [selectedWordLength !== -1 ? to - trailingSpaces.length - selectedWordLength : 0, to];\n}\n\n/* eslint-disable @typescript-eslint/no-restricted-types */\n/**\n * @internal\n */\nfunction maskitoPipe(processors = []) {\n  return (initialData, ...readonlyArgs) => processors.reduce((data, fn) => Object.assign(Object.assign({}, data), fn(data, ...readonlyArgs)), initialData);\n}\nfunction maskitoTransform(valueOrState, maskitoOptions) {\n  const options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), maskitoOptions);\n  const preprocessor = maskitoPipe(options.preprocessors);\n  const postprocessor = maskitoPipe(options.postprocessors);\n  const initialElementState = typeof valueOrState === 'string' ? {\n    value: valueOrState,\n    selection: [0, 0]\n  } : valueOrState;\n  const {\n    elementState\n  } = preprocessor({\n    elementState: initialElementState,\n    data: ''\n  }, 'validation');\n  const maskModel = new MaskModel(elementState, options);\n  const {\n    value,\n    selection\n  } = postprocessor(maskModel, initialElementState);\n  return typeof valueOrState === 'string' ? value : {\n    value,\n    selection\n  };\n}\nclass Maskito extends MaskHistory {\n  constructor(element, maskitoOptions) {\n    super();\n    this.element = element;\n    this.maskitoOptions = maskitoOptions;\n    this.isTextArea = this.element.nodeName === 'TEXTAREA';\n    this.eventListener = new EventListener(this.element);\n    this.options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), this.maskitoOptions);\n    this.upcomingElementState = null;\n    this.preprocessor = maskitoPipe(this.options.preprocessors);\n    this.postprocessor = maskitoPipe(this.options.postprocessors);\n    this.teardowns = this.options.plugins.map(plugin => plugin(this.element, this.options));\n    this.updateHistory(this.elementState);\n    this.eventListener.listen('keydown', event => {\n      if (isRedo(event)) {\n        event.preventDefault();\n        return this.redo();\n      }\n      if (isUndo(event)) {\n        event.preventDefault();\n        return this.undo();\n      }\n    });\n    this.eventListener.listen('beforeinput', event => {\n      var _a, _b, _c;\n      const isForward = event.inputType.includes('Forward');\n      this.updateHistory(this.elementState);\n      switch (event.inputType) {\n        // historyUndo/historyRedo will not be triggered if value was modified programmatically\n        case 'historyUndo':\n          event.preventDefault();\n          return this.undo();\n        case 'historyRedo':\n          event.preventDefault();\n          return this.redo();\n        case 'deleteByCut':\n        case 'deleteContentBackward':\n        case 'deleteContentForward':\n          return this.handleDelete({\n            event,\n            isForward,\n            selection: getNotEmptySelection(this.elementState, isForward)\n          });\n        case 'deleteWordForward':\n        case 'deleteWordBackward':\n          return this.handleDelete({\n            event,\n            isForward,\n            selection: getWordSelection(this.elementState, isForward),\n            force: true\n          });\n        case 'deleteSoftLineBackward':\n        case 'deleteSoftLineForward':\n        case 'deleteHardLineBackward':\n        case 'deleteHardLineForward':\n          return this.handleDelete({\n            event,\n            isForward,\n            selection: getLineSelection(this.elementState, isForward),\n            force: true\n          });\n        case 'insertCompositionText':\n          return;\n        // will be handled inside `compositionend` event\n        case 'insertReplacementText':\n          /**\n           * According {@link https://www.w3.org/TR/input-events-2 W3C specification}:\n           * > `insertReplacementText` â€“ insert or replace existing text by means of a spell checker,\n           * > auto-correct, writing suggestions or similar.\n           * ___\n           * Firefox emits `insertReplacementText` event for its suggestion/autofill and for spell checker.\n           * However, it is impossible to detect which part of the textfield value is going to be replaced\n           * (`selectionStart` and `selectionEnd` just equal to the last caret position).\n           * ___\n           * Chrome does not fire `beforeinput` event for its suggestion/autofill.\n           * It emits only `input` event with `inputType` and `data` set to `undefined`.\n           * ___\n           * All these browser limitations make us to validate the result value later in `input` event.\n           */\n          return;\n        case 'insertLineBreak':\n        case 'insertParagraph':\n          return this.handleEnter(event);\n        case 'insertFromPaste':\n        case 'insertText':\n        case 'insertFromDrop':\n        default:\n          return this.handleInsert(event, (_c = (_a = event.data) !== null && _a !== void 0 ? _a :\n          // `event.data` for `contentEditable` is always `null` for paste/drop events\n          (_b = event.dataTransfer) === null || _b === void 0 ? void 0 : _b.getData('text/plain')) !== null && _c !== void 0 ? _c : '');\n      }\n    });\n    this.eventListener.listen('input', () => {\n      if (this.upcomingElementState) {\n        this.updateElementState(this.upcomingElementState);\n        this.upcomingElementState = null;\n      }\n    }, {\n      capture: true\n    });\n    this.eventListener.listen('input', ({\n      inputType\n    }) => {\n      if (inputType === 'insertCompositionText') {\n        return; // will be handled inside `compositionend` event\n      }\n      this.ensureValueFitsMask();\n      this.updateHistory(this.elementState);\n    });\n    this.eventListener.listen('compositionend', () => {\n      this.ensureValueFitsMask();\n      this.updateHistory(this.elementState);\n    });\n  }\n  destroy() {\n    this.eventListener.destroy();\n    this.teardowns.forEach(teardown => teardown === null || teardown === void 0 ? void 0 : teardown());\n  }\n  updateElementState({\n    value,\n    selection\n  }, eventInit) {\n    const initialValue = this.elementState.value;\n    this.updateValue(value);\n    this.updateSelectionRange(selection);\n    if (eventInit && initialValue !== value) {\n      this.dispatchInputEvent(eventInit);\n    }\n  }\n  get elementState() {\n    const {\n      value,\n      selectionStart,\n      selectionEnd\n    } = this.element;\n    return {\n      value,\n      selection: [selectionStart !== null && selectionStart !== void 0 ? selectionStart : 0, selectionEnd !== null && selectionEnd !== void 0 ? selectionEnd : 0]\n    };\n  }\n  get maxLength() {\n    const {\n      maxLength\n    } = this.element;\n    return maxLength === -1 ? Infinity : maxLength;\n  }\n  updateSelectionRange([from, to]) {\n    var _a;\n    const {\n      element\n    } = this;\n    if (element.matches(':focus') && (element.selectionStart !== from || element.selectionEnd !== to)) {\n      (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n    }\n  }\n  updateValue(value) {\n    this.element.value = value;\n  }\n  ensureValueFitsMask() {\n    this.updateElementState(maskitoTransform(this.elementState, this.options), {\n      inputType: 'insertText',\n      data: null\n    });\n  }\n  dispatchInputEvent(eventInit = {\n    inputType: 'insertText',\n    data: null\n  }) {\n    if (globalThis.InputEvent) {\n      this.element.dispatchEvent(new InputEvent('input', Object.assign(Object.assign({}, eventInit), {\n        bubbles: true,\n        cancelable: false\n      })));\n    }\n  }\n  handleDelete({\n    event,\n    selection,\n    isForward,\n    force = false\n  }) {\n    const initialState = {\n      value: this.elementState.value,\n      selection\n    };\n    const [initialFrom, initialTo] = initialState.selection;\n    const {\n      elementState\n    } = this.preprocessor({\n      elementState: initialState,\n      data: ''\n    }, isForward ? 'deleteForward' : 'deleteBackward');\n    const maskModel = new MaskModel(elementState, this.options);\n    const [from, to] = elementState.selection;\n    maskModel.deleteCharacters([from, to]);\n    const newElementState = this.postprocessor(maskModel, initialState);\n    const newPossibleValue = initialState.value.slice(0, initialFrom) + initialState.value.slice(initialTo);\n    if (newPossibleValue === newElementState.value && !force && !this.element.isContentEditable) {\n      return;\n    }\n    if (areElementValuesEqual(initialState, elementState, maskModel, newElementState)) {\n      event.preventDefault();\n      // User presses Backspace/Delete for the fixed value\n      return this.updateSelectionRange(isForward ? [to, to] : [from, from]);\n    }\n    this.upcomingElementState = newElementState;\n  }\n  handleInsert(event, data) {\n    const {\n      options,\n      maxLength,\n      element,\n      elementState: initialElementState\n    } = this;\n    const {\n      elementState,\n      data: insertedText = data\n    } = this.preprocessor({\n      data,\n      elementState: initialElementState\n    }, 'insert');\n    const maskModel = new MaskModel(elementState, options);\n    try {\n      maskModel.addCharacters(elementState.selection, insertedText);\n    } catch (_a) {\n      return event.preventDefault();\n    }\n    const [from, to] = elementState.selection;\n    const newPossibleValue = initialElementState.value.slice(0, from) + data + initialElementState.value.slice(to);\n    const newElementState = this.postprocessor(maskModel, initialElementState);\n    if (newElementState.value.length > maxLength) {\n      return event.preventDefault();\n    }\n    if (newPossibleValue !== newElementState.value || element.isContentEditable) {\n      this.upcomingElementState = newElementState;\n      if (options.overwriteMode === 'replace' && newPossibleValue.length > maxLength) {\n        /**\n         * Browsers know nothing about Maskito and its `overwriteMode`.\n         * When textfield value length is already equal to attribute `maxlength`,\n         * pressing any key (even with valid value) does not emit `input` event.\n         */\n        this.dispatchInputEvent({\n          inputType: 'insertText',\n          data\n        });\n      }\n    }\n  }\n  handleEnter(event) {\n    if (this.isTextArea || this.element.isContentEditable) {\n      this.handleInsert(event, '\\n');\n    }\n  }\n}\nfunction maskitoChangeEventPlugin() {\n  return element => {\n    if (element.isContentEditable) {\n      return;\n    }\n    let value = element.value;\n    const valueListener = () => {\n      value = element.value;\n    };\n    const blurListener = () => {\n      if (element.value !== value) {\n        element.dispatchEvent(new Event('change', {\n          bubbles: true\n        }));\n      }\n    };\n    element.addEventListener('focus', valueListener);\n    element.addEventListener('change', valueListener);\n    element.addEventListener('blur', blurListener);\n    return () => {\n      element.removeEventListener('focus', valueListener);\n      element.removeEventListener('change', valueListener);\n      element.removeEventListener('blur', blurListener);\n    };\n  };\n}\nfunction maskitoInitialCalibrationPlugin(customOptions) {\n  return (element, options) => {\n    var _a, _b;\n    const from = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n    const to = (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0;\n    maskitoUpdateElement(element, {\n      value: maskitoTransform(element.value, customOptions || options),\n      selection: [from, to]\n    });\n  };\n}\nfunction maskitoStrictCompositionPlugin() {\n  return (element, maskitoOptions) => {\n    const listener = event => {\n      var _a, _b;\n      if (event.inputType !== 'insertCompositionText') {\n        return;\n      }\n      const selection = [(_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0, (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0];\n      const elementState = {\n        selection,\n        value: element.value\n      };\n      const validatedState = maskitoTransform(elementState, maskitoOptions);\n      if (!areElementStatesEqual(elementState, validatedState)) {\n        event.preventDefault();\n        maskitoUpdateElement(element, validatedState);\n      }\n    };\n    element.addEventListener('input', listener);\n    return () => element.removeEventListener('input', listener);\n  };\n}\nexport { MASKITO_DEFAULT_ELEMENT_PREDICATE, MASKITO_DEFAULT_OPTIONS, Maskito, maskitoAdaptContentEditable, maskitoChangeEventPlugin, maskitoInitialCalibrationPlugin, maskitoPipe, maskitoStrictCompositionPlugin, maskitoTransform, maskitoUpdateElement };","map":{"version":3,"names":["getContentEditableSelection","element","anchorOffset","focusOffset","ownerDocument","getSelection","from","Math","min","to","max","setContentEditableSelection","_a","_b","_c","_d","document","range","createRange","setStart","firstChild","textContent","length","setEnd","lastChild","selection","removeAllRanges","addRange","ContentEditableAdapter","constructor","maxLength","Infinity","value","innerText","replace","innerHTML","selectionStart","selectionEnd","setSelectionRange","select","maskitoAdaptContentEditable","adapter","Proxy","get","target","prop","nativeProperty","bind","set","val","receiver","Reflect","MASKITO_DEFAULT_ELEMENT_PREDICATE","e","isContentEditable","querySelector","MASKITO_DEFAULT_OPTIONS","mask","preprocessors","postprocessors","plugins","overwriteMode","MaskHistory","now","past","future","undo","state","pop","push","updateElement","redo","updateHistory","isValueChanged","isSelectionChanged","some","item","index","inputType","updateElementState","data","areElementValuesEqual","sampleState","states","every","areElementStatesEqual","applyOverwriteMode","newCharacters","mode","computedMode","isFixedCharacter","char","getLeadingFixedCharacters","validatedValuePart","newCharacter","initialElementState","leadingFixedCharacters","i","charConstraint","isInitiallyExisted","validateValueWithMask","maskExpression","Array","isArray","match","test","guessValidValueByPattern","elementState","maskedFrom","maskedTo","maskedValue","reduce","validatedCharacters","charIndex","leadingCharacters","newValidatedChars","trailingFixedCharacters","guessValidValueByRegExp","maskRegExp","newFrom","newTo","validatedValue","newPossibleValue","calibrateValueByMask","slice","removeFixedMaskCharacters","unmaskedValue","rawValue","fill","MaskModel","maskOptions","getMaskExpression","addCharacters","unmaskedElementState","unmaskedFrom","unmaskedTo","newUnmaskedLeadingValuePart","newCaretIndex","maskedElementState","isInvalidCharsInsertion","Error","deleteCharacters","newUnmaskedValue","EventListener","listeners","listen","eventType","fn","options","untypedFn","addEventListener","removeEventListener","destroy","forEach","stopListen","HotkeyModifier","CTRL","ALT","SHIFT","META","HotkeyCode","Y","Z","isHotkey","event","modifiers","hotkeyCode","ctrlKey","altKey","shiftKey","metaKey","keyCode","isRedo","isUndo","maskitoUpdateElement","valueOrElementState","initialValue","matches","call","dispatchEvent","Event","bubbles","getLineSelection","isForward","nearestBreak","indexOf","lastIndexOf","selectFrom","selectTo","getNotEmptySelection","notEmptySelection","map","x","TRAILING_SPACES_REG","LEADING_SPACES_REG","SPACE_REG","getWordSelection","valueAfterSelectionStart","leadingSpaces","nearestWordEndIndex","trimStart","search","valueBeforeSelectionEnd","trailingSpaces","selectedWordLength","trimEnd","split","reverse","findIndex","exec","maskitoPipe","processors","initialData","readonlyArgs","Object","assign","maskitoTransform","valueOrState","maskitoOptions","preprocessor","postprocessor","maskModel","Maskito","isTextArea","nodeName","eventListener","upcomingElementState","teardowns","plugin","preventDefault","includes","handleDelete","force","handleEnter","handleInsert","dataTransfer","getData","capture","ensureValueFitsMask","teardown","eventInit","updateValue","updateSelectionRange","dispatchInputEvent","globalThis","InputEvent","cancelable","initialState","initialFrom","initialTo","newElementState","insertedText","maskitoChangeEventPlugin","valueListener","blurListener","maskitoInitialCalibrationPlugin","customOptions","maskitoStrictCompositionPlugin","listener","validatedState"],"sources":["C:/Users/Asus-PC/Downloads/WebLibraryNew/WebLibrary/WebLibraryApp/Frontend/node_modules/@maskito/core/index.esm.js"],"sourcesContent":["function getContentEditableSelection(element) {\n    const { anchorOffset = 0, focusOffset = 0 } = element.ownerDocument.getSelection() || {};\n    const from = Math.min(anchorOffset, focusOffset);\n    const to = Math.max(anchorOffset, focusOffset);\n    return [from, to];\n}\n\nfunction setContentEditableSelection(element, [from, to]) {\n    var _a, _b, _c, _d;\n    const document = element.ownerDocument;\n    const range = document.createRange();\n    range.setStart(element.firstChild || element, Math.min(from, (_b = (_a = element.textContent) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0));\n    range.setEnd(element.lastChild || element, Math.min(to, (_d = (_c = element.textContent) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0));\n    const selection = document.getSelection();\n    if (selection) {\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n}\n\nclass ContentEditableAdapter {\n    constructor(element) {\n        this.element = element;\n        this.maxLength = Infinity;\n    }\n    get value() {\n        return this.element.innerText.replace(/\\n\\n$/, '\\n');\n    }\n    set value(value) {\n        // Setting into innerHTML of element with `white-space: pre;` style\n        this.element.innerHTML = value.replace(/\\n$/, '\\n\\n');\n    }\n    get selectionStart() {\n        return getContentEditableSelection(this.element)[0];\n    }\n    get selectionEnd() {\n        return getContentEditableSelection(this.element)[1];\n    }\n    setSelectionRange(from, to) {\n        setContentEditableSelection(this.element, [from !== null && from !== void 0 ? from : 0, to !== null && to !== void 0 ? to : 0]);\n    }\n    select() {\n        this.setSelectionRange(0, this.value.length);\n    }\n}\nfunction maskitoAdaptContentEditable(element) {\n    const adapter = new ContentEditableAdapter(element);\n    return new Proxy(element, {\n        get(target, prop) {\n            if (prop in adapter) {\n                return adapter[prop];\n            }\n            const nativeProperty = target[prop];\n            return typeof nativeProperty === 'function'\n                ? nativeProperty.bind(target)\n                : nativeProperty;\n        },\n        set(target, prop, val, receiver) {\n            return Reflect.set(prop in adapter ? adapter : target, prop, val, receiver);\n        },\n    });\n}\n\nconst MASKITO_DEFAULT_ELEMENT_PREDICATE = (e) => e.isContentEditable\n    ? maskitoAdaptContentEditable(e)\n    : e.querySelector('input,textarea') ||\n        e;\n\nconst MASKITO_DEFAULT_OPTIONS = {\n    mask: /^.*$/,\n    preprocessors: [],\n    postprocessors: [],\n    plugins: [],\n    overwriteMode: 'shift',\n};\n\nclass MaskHistory {\n    constructor() {\n        this.now = null;\n        this.past = [];\n        this.future = [];\n    }\n    undo() {\n        const state = this.past.pop();\n        if (state && this.now) {\n            this.future.push(this.now);\n            this.updateElement(state, 'historyUndo');\n        }\n    }\n    redo() {\n        const state = this.future.pop();\n        if (state && this.now) {\n            this.past.push(this.now);\n            this.updateElement(state, 'historyRedo');\n        }\n    }\n    updateHistory(state) {\n        if (!this.now) {\n            this.now = state;\n            return;\n        }\n        const isValueChanged = this.now.value !== state.value;\n        const isSelectionChanged = this.now.selection.some((item, index) => item !== state.selection[index]);\n        if (!isValueChanged && !isSelectionChanged) {\n            return;\n        }\n        if (isValueChanged) {\n            this.past.push(this.now);\n            this.future = [];\n        }\n        this.now = state;\n    }\n    updateElement(state, inputType) {\n        this.now = state;\n        this.updateElementState(state, { inputType, data: null });\n    }\n}\n\nfunction areElementValuesEqual(sampleState, ...states) {\n    return states.every(({ value }) => value === sampleState.value);\n}\nfunction areElementStatesEqual(sampleState, ...states) {\n    return states.every(({ value, selection }) => value === sampleState.value &&\n        selection[0] === sampleState.selection[0] &&\n        selection[1] === sampleState.selection[1]);\n}\n\nfunction applyOverwriteMode({ value, selection }, newCharacters, mode) {\n    const [from, to] = selection;\n    const computedMode = typeof mode === 'function' ? mode({ value, selection }) : mode;\n    return {\n        value,\n        selection: computedMode === 'replace'\n            ? [from, Math.max(from + newCharacters.length, to)]\n            : [from, to],\n    };\n}\n\nfunction isFixedCharacter(char) {\n    return typeof char === 'string';\n}\n\nfunction getLeadingFixedCharacters(mask, validatedValuePart, newCharacter, initialElementState) {\n    let leadingFixedCharacters = '';\n    for (let i = validatedValuePart.length; i < mask.length; i++) {\n        const charConstraint = mask[i] || '';\n        const isInitiallyExisted = (initialElementState === null || initialElementState === void 0 ? void 0 : initialElementState.value[i]) === charConstraint;\n        if (!isFixedCharacter(charConstraint) ||\n            (charConstraint === newCharacter && !isInitiallyExisted)) {\n            return leadingFixedCharacters;\n        }\n        leadingFixedCharacters += charConstraint;\n    }\n    return leadingFixedCharacters;\n}\n\nfunction validateValueWithMask(value, maskExpression) {\n    if (Array.isArray(maskExpression)) {\n        return (value.length === maskExpression.length &&\n            Array.from(value).every((char, i) => {\n                const charConstraint = maskExpression[i] || '';\n                return isFixedCharacter(charConstraint)\n                    ? char === charConstraint\n                    : char.match(charConstraint);\n            }));\n    }\n    return maskExpression.test(value);\n}\n\nfunction guessValidValueByPattern(elementState, mask, initialElementState) {\n    let maskedFrom = null;\n    let maskedTo = null;\n    const maskedValue = Array.from(elementState.value).reduce((validatedCharacters, char, charIndex) => {\n        const leadingCharacters = getLeadingFixedCharacters(mask, validatedCharacters, char, initialElementState);\n        const newValidatedChars = validatedCharacters + leadingCharacters;\n        const charConstraint = mask[newValidatedChars.length] || '';\n        if (maskedFrom === null && charIndex >= elementState.selection[0]) {\n            maskedFrom = newValidatedChars.length;\n        }\n        if (maskedTo === null && charIndex >= elementState.selection[1]) {\n            maskedTo = newValidatedChars.length;\n        }\n        if (isFixedCharacter(charConstraint)) {\n            return newValidatedChars + charConstraint;\n        }\n        return char.match(charConstraint)\n            ? newValidatedChars + char\n            : newValidatedChars;\n    }, '');\n    const trailingFixedCharacters = getLeadingFixedCharacters(mask, maskedValue, '', initialElementState);\n    return {\n        value: validateValueWithMask(maskedValue + trailingFixedCharacters, mask)\n            ? maskedValue + trailingFixedCharacters\n            : maskedValue,\n        selection: [maskedFrom !== null && maskedFrom !== void 0 ? maskedFrom : maskedValue.length, maskedTo !== null && maskedTo !== void 0 ? maskedTo : maskedValue.length],\n    };\n}\n\nfunction guessValidValueByRegExp({ value, selection }, maskRegExp) {\n    const [from, to] = selection;\n    let newFrom = from;\n    let newTo = to;\n    const validatedValue = Array.from(value).reduce((validatedValuePart, char, i) => {\n        const newPossibleValue = validatedValuePart + char;\n        if (from === i) {\n            newFrom = validatedValuePart.length;\n        }\n        if (to === i) {\n            newTo = validatedValuePart.length;\n        }\n        return newPossibleValue.match(maskRegExp) ? newPossibleValue : validatedValuePart;\n    }, '');\n    return { value: validatedValue, selection: [newFrom, newTo] };\n}\n\nfunction calibrateValueByMask(elementState, mask, initialElementState = null) {\n    if (validateValueWithMask(elementState.value, mask)) {\n        return elementState;\n    }\n    const { value, selection } = Array.isArray(mask)\n        ? guessValidValueByPattern(elementState, mask, initialElementState)\n        : guessValidValueByRegExp(elementState, mask);\n    return {\n        selection,\n        value: Array.isArray(mask) ? value.slice(0, mask.length) : value,\n    };\n}\n\nfunction removeFixedMaskCharacters(initialElementState, mask) {\n    if (!Array.isArray(mask)) {\n        return initialElementState;\n    }\n    const [from, to] = initialElementState.selection;\n    const selection = [];\n    const unmaskedValue = Array.from(initialElementState.value).reduce((rawValue, char, i) => {\n        const charConstraint = mask[i] || '';\n        if (i === from) {\n            selection.push(rawValue.length);\n        }\n        if (i === to) {\n            selection.push(rawValue.length);\n        }\n        return isFixedCharacter(charConstraint) && charConstraint === char\n            ? rawValue\n            : rawValue + char;\n    }, '');\n    if (selection.length < 2) {\n        selection.push(...new Array(2 - selection.length).fill(unmaskedValue.length));\n    }\n    return {\n        value: unmaskedValue,\n        selection: [selection[0], selection[1]],\n    };\n}\n\nclass MaskModel {\n    constructor(initialElementState, maskOptions) {\n        this.initialElementState = initialElementState;\n        this.maskOptions = maskOptions;\n        this.value = '';\n        this.selection = [0, 0];\n        const { value, selection } = calibrateValueByMask(this.initialElementState, this.getMaskExpression(this.initialElementState));\n        this.value = value;\n        this.selection = selection;\n    }\n    addCharacters([from, to], newCharacters) {\n        const { value, maskOptions } = this;\n        const maskExpression = this.getMaskExpression({\n            value: value.slice(0, from) + newCharacters + value.slice(to),\n            selection: [from + newCharacters.length, from + newCharacters.length],\n        });\n        const initialElementState = { value, selection: [from, to] };\n        const unmaskedElementState = removeFixedMaskCharacters(initialElementState, maskExpression);\n        const [unmaskedFrom, unmaskedTo] = applyOverwriteMode(unmaskedElementState, newCharacters, maskOptions.overwriteMode).selection;\n        const newUnmaskedLeadingValuePart = unmaskedElementState.value.slice(0, unmaskedFrom) + newCharacters;\n        const newCaretIndex = newUnmaskedLeadingValuePart.length;\n        const maskedElementState = calibrateValueByMask({\n            value: newUnmaskedLeadingValuePart +\n                unmaskedElementState.value.slice(unmaskedTo),\n            selection: [newCaretIndex, newCaretIndex],\n        }, maskExpression, initialElementState);\n        const isInvalidCharsInsertion = value.slice(0, from) ===\n            calibrateValueByMask({\n                value: newUnmaskedLeadingValuePart,\n                selection: [newCaretIndex, newCaretIndex],\n            }, maskExpression, initialElementState).value;\n        if (isInvalidCharsInsertion ||\n            areElementStatesEqual(this, maskedElementState) // If typing new characters does not change value\n        ) {\n            throw new Error('Invalid mask value');\n        }\n        this.value = maskedElementState.value;\n        this.selection = maskedElementState.selection;\n    }\n    deleteCharacters([from, to]) {\n        if (from === to || !to) {\n            return;\n        }\n        const { value } = this;\n        const maskExpression = this.getMaskExpression({\n            value: value.slice(0, from) + value.slice(to),\n            selection: [from, from],\n        });\n        const initialElementState = { value, selection: [from, to] };\n        const unmaskedElementState = removeFixedMaskCharacters(initialElementState, maskExpression);\n        const [unmaskedFrom, unmaskedTo] = unmaskedElementState.selection;\n        const newUnmaskedValue = unmaskedElementState.value.slice(0, unmaskedFrom) +\n            unmaskedElementState.value.slice(unmaskedTo);\n        const maskedElementState = calibrateValueByMask({ value: newUnmaskedValue, selection: [unmaskedFrom, unmaskedFrom] }, maskExpression, initialElementState);\n        this.value = maskedElementState.value;\n        this.selection = maskedElementState.selection;\n    }\n    getMaskExpression(elementState) {\n        const { mask } = this.maskOptions;\n        return typeof mask === 'function' ? mask(elementState) : mask;\n    }\n}\n\nclass EventListener {\n    constructor(element) {\n        this.element = element;\n        this.listeners = [];\n    }\n    listen(eventType, fn, options) {\n        const untypedFn = fn;\n        this.element.addEventListener(eventType, untypedFn, options);\n        this.listeners.push(() => this.element.removeEventListener(eventType, untypedFn, options));\n    }\n    destroy() {\n        this.listeners.forEach((stopListen) => stopListen());\n    }\n}\n\nconst HotkeyModifier = {\n    CTRL: 1 << 0,\n    ALT: 1 << 1,\n    SHIFT: 1 << 2,\n    META: 1 << 3,\n};\n// TODO add variants that can be processed correctly\nconst HotkeyCode = {\n    Y: 89,\n    Z: 90,\n};\n/**\n * Checks if the passed keyboard event match the required hotkey.\n *\n * @example\n * input.addEventListener('keydown', (event) => {\n *     if (isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z)) {\n *         // redo hotkey pressed\n *     }\n * })\n *\n * @return will return `true` only if the {@link HotkeyCode} matches and only the necessary\n * {@link HotkeyModifier modifiers} have been pressed\n */\nfunction isHotkey(event, modifiers, hotkeyCode) {\n    return (event.ctrlKey === !!(modifiers & HotkeyModifier.CTRL) &&\n        event.altKey === !!(modifiers & HotkeyModifier.ALT) &&\n        event.shiftKey === !!(modifiers & HotkeyModifier.SHIFT) &&\n        event.metaKey === !!(modifiers & HotkeyModifier.META) &&\n        /**\n         * We intentionally use legacy {@link KeyboardEvent#keyCode `keyCode`} property. It is more\n         * \"keyboard-layout\"-independent than {@link KeyboardEvent#key `key`} or {@link KeyboardEvent#code `code`} properties.\n         * @see {@link https://github.com/taiga-family/maskito/issues/315 `KeyboardEvent#code` issue}\n         */\n        event.keyCode === hotkeyCode);\n}\n\nfunction isRedo(event) {\n    return (isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Y) || // Windows\n        isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z) || // Windows & Android\n        isHotkey(event, HotkeyModifier.META | HotkeyModifier.SHIFT, HotkeyCode.Z) // macOS & iOS\n    );\n}\nfunction isUndo(event) {\n    return (isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Z) || // Windows & Android\n        isHotkey(event, HotkeyModifier.META, HotkeyCode.Z) // macOS & iOS\n    );\n}\n\n/**\n * Sets value to element, and dispatches input event\n * if you passed ELementState, it also sets selection range\n *\n * @example\n * maskitoUpdateElement(input, newValue);\n * maskitoUpdateElement(input, elementState);\n *\n * @see {@link https://github.com/taiga-family/maskito/issues/804 issue}\n *\n * @return void\n */\nfunction maskitoUpdateElement(element, valueOrElementState) {\n    var _a;\n    const initialValue = element.value;\n    if (typeof valueOrElementState === 'string') {\n        element.value = valueOrElementState;\n    }\n    else {\n        const [from, to] = valueOrElementState.selection;\n        element.value = valueOrElementState.value;\n        if (element.matches(':focus')) {\n            (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n        }\n    }\n    if (element.value !== initialValue) {\n        element.dispatchEvent(new Event('input', \n        /**\n         * React handles this event only on bubbling phase\n         *\n         * here is the list of events that are processed in the capture stage, others are processed in the bubbling stage\n         * https://github.com/facebook/react/blob/cb2439624f43c510007f65aea5c50a8bb97917e4/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js#L222\n         */\n        { bubbles: true }));\n    }\n}\n\nfunction getLineSelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    const nearestBreak = isForward\n        ? value.slice(from).indexOf('\\n') + 1 || value.length\n        : value.slice(0, to).lastIndexOf('\\n') + 1;\n    const selectFrom = isForward ? from : nearestBreak;\n    const selectTo = isForward ? nearestBreak : to;\n    return [selectFrom, selectTo];\n}\n\nfunction getNotEmptySelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    const notEmptySelection = isForward ? [from, to + 1] : [from - 1, to];\n    return notEmptySelection.map((x) => Math.min(Math.max(x, 0), value.length));\n}\n\nconst TRAILING_SPACES_REG = /\\s+$/g;\nconst LEADING_SPACES_REG = /^\\s+/g;\nconst SPACE_REG = /\\s/;\nfunction getWordSelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    if (isForward) {\n        const valueAfterSelectionStart = value.slice(from);\n        const [leadingSpaces] = valueAfterSelectionStart.match(LEADING_SPACES_REG) || [\n            '',\n        ];\n        const nearestWordEndIndex = valueAfterSelectionStart\n            .trimStart()\n            .search(SPACE_REG);\n        return [\n            from,\n            nearestWordEndIndex !== -1\n                ? from + leadingSpaces.length + nearestWordEndIndex\n                : value.length,\n        ];\n    }\n    const valueBeforeSelectionEnd = value.slice(0, to);\n    const [trailingSpaces] = valueBeforeSelectionEnd.match(TRAILING_SPACES_REG) || [''];\n    const selectedWordLength = valueBeforeSelectionEnd\n        .trimEnd()\n        .split('')\n        .reverse()\n        .findIndex((char) => SPACE_REG.exec(char));\n    return [\n        selectedWordLength !== -1 ? to - trailingSpaces.length - selectedWordLength : 0,\n        to,\n    ];\n}\n\n/* eslint-disable @typescript-eslint/no-restricted-types */\n/**\n * @internal\n */\nfunction maskitoPipe(processors = []) {\n    return (initialData, ...readonlyArgs) => processors.reduce((data, fn) => (Object.assign(Object.assign({}, data), fn(data, ...readonlyArgs))), initialData);\n}\n\nfunction maskitoTransform(valueOrState, maskitoOptions) {\n    const options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), maskitoOptions);\n    const preprocessor = maskitoPipe(options.preprocessors);\n    const postprocessor = maskitoPipe(options.postprocessors);\n    const initialElementState = typeof valueOrState === 'string'\n        ? { value: valueOrState, selection: [0, 0] }\n        : valueOrState;\n    const { elementState } = preprocessor({ elementState: initialElementState, data: '' }, 'validation');\n    const maskModel = new MaskModel(elementState, options);\n    const { value, selection } = postprocessor(maskModel, initialElementState);\n    return typeof valueOrState === 'string' ? value : { value, selection };\n}\n\nclass Maskito extends MaskHistory {\n    constructor(element, maskitoOptions) {\n        super();\n        this.element = element;\n        this.maskitoOptions = maskitoOptions;\n        this.isTextArea = this.element.nodeName === 'TEXTAREA';\n        this.eventListener = new EventListener(this.element);\n        this.options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), this.maskitoOptions);\n        this.upcomingElementState = null;\n        this.preprocessor = maskitoPipe(this.options.preprocessors);\n        this.postprocessor = maskitoPipe(this.options.postprocessors);\n        this.teardowns = this.options.plugins.map((plugin) => plugin(this.element, this.options));\n        this.updateHistory(this.elementState);\n        this.eventListener.listen('keydown', (event) => {\n            if (isRedo(event)) {\n                event.preventDefault();\n                return this.redo();\n            }\n            if (isUndo(event)) {\n                event.preventDefault();\n                return this.undo();\n            }\n        });\n        this.eventListener.listen('beforeinput', (event) => {\n            var _a, _b, _c;\n            const isForward = event.inputType.includes('Forward');\n            this.updateHistory(this.elementState);\n            switch (event.inputType) {\n                // historyUndo/historyRedo will not be triggered if value was modified programmatically\n                case 'historyUndo':\n                    event.preventDefault();\n                    return this.undo();\n                case 'historyRedo':\n                    event.preventDefault();\n                    return this.redo();\n                case 'deleteByCut':\n                case 'deleteContentBackward':\n                case 'deleteContentForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getNotEmptySelection(this.elementState, isForward),\n                    });\n                case 'deleteWordForward':\n                case 'deleteWordBackward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getWordSelection(this.elementState, isForward),\n                        force: true,\n                    });\n                case 'deleteSoftLineBackward':\n                case 'deleteSoftLineForward':\n                case 'deleteHardLineBackward':\n                case 'deleteHardLineForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getLineSelection(this.elementState, isForward),\n                        force: true,\n                    });\n                case 'insertCompositionText':\n                    return; // will be handled inside `compositionend` event\n                case 'insertReplacementText':\n                    /**\n                     * According {@link https://www.w3.org/TR/input-events-2 W3C specification}:\n                     * > `insertReplacementText` â€“ insert or replace existing text by means of a spell checker,\n                     * > auto-correct, writing suggestions or similar.\n                     * ___\n                     * Firefox emits `insertReplacementText` event for its suggestion/autofill and for spell checker.\n                     * However, it is impossible to detect which part of the textfield value is going to be replaced\n                     * (`selectionStart` and `selectionEnd` just equal to the last caret position).\n                     * ___\n                     * Chrome does not fire `beforeinput` event for its suggestion/autofill.\n                     * It emits only `input` event with `inputType` and `data` set to `undefined`.\n                     * ___\n                     * All these browser limitations make us to validate the result value later in `input` event.\n                     */\n                    return;\n                case 'insertLineBreak':\n                case 'insertParagraph':\n                    return this.handleEnter(event);\n                case 'insertFromPaste':\n                case 'insertText':\n                case 'insertFromDrop':\n                default:\n                    return this.handleInsert(event, (_c = (_a = event.data) !== null && _a !== void 0 ? _a : \n                    // `event.data` for `contentEditable` is always `null` for paste/drop events\n                    (_b = event.dataTransfer) === null || _b === void 0 ? void 0 : _b.getData('text/plain')) !== null && _c !== void 0 ? _c : '');\n            }\n        });\n        this.eventListener.listen('input', () => {\n            if (this.upcomingElementState) {\n                this.updateElementState(this.upcomingElementState);\n                this.upcomingElementState = null;\n            }\n        }, { capture: true });\n        this.eventListener.listen('input', ({ inputType }) => {\n            if (inputType === 'insertCompositionText') {\n                return; // will be handled inside `compositionend` event\n            }\n            this.ensureValueFitsMask();\n            this.updateHistory(this.elementState);\n        });\n        this.eventListener.listen('compositionend', () => {\n            this.ensureValueFitsMask();\n            this.updateHistory(this.elementState);\n        });\n    }\n    destroy() {\n        this.eventListener.destroy();\n        this.teardowns.forEach((teardown) => teardown === null || teardown === void 0 ? void 0 : teardown());\n    }\n    updateElementState({ value, selection }, eventInit) {\n        const initialValue = this.elementState.value;\n        this.updateValue(value);\n        this.updateSelectionRange(selection);\n        if (eventInit && initialValue !== value) {\n            this.dispatchInputEvent(eventInit);\n        }\n    }\n    get elementState() {\n        const { value, selectionStart, selectionEnd } = this.element;\n        return {\n            value,\n            selection: [selectionStart !== null && selectionStart !== void 0 ? selectionStart : 0, selectionEnd !== null && selectionEnd !== void 0 ? selectionEnd : 0],\n        };\n    }\n    get maxLength() {\n        const { maxLength } = this.element;\n        return maxLength === -1 ? Infinity : maxLength;\n    }\n    updateSelectionRange([from, to]) {\n        var _a;\n        const { element } = this;\n        if (element.matches(':focus') &&\n            (element.selectionStart !== from || element.selectionEnd !== to)) {\n            (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n        }\n    }\n    updateValue(value) {\n        this.element.value = value;\n    }\n    ensureValueFitsMask() {\n        this.updateElementState(maskitoTransform(this.elementState, this.options), {\n            inputType: 'insertText',\n            data: null,\n        });\n    }\n    dispatchInputEvent(eventInit = {\n        inputType: 'insertText',\n        data: null,\n    }) {\n        if (globalThis.InputEvent) {\n            this.element.dispatchEvent(new InputEvent('input', Object.assign(Object.assign({}, eventInit), { bubbles: true, cancelable: false })));\n        }\n    }\n    handleDelete({ event, selection, isForward, force = false, }) {\n        const initialState = {\n            value: this.elementState.value,\n            selection,\n        };\n        const [initialFrom, initialTo] = initialState.selection;\n        const { elementState } = this.preprocessor({\n            elementState: initialState,\n            data: '',\n        }, isForward ? 'deleteForward' : 'deleteBackward');\n        const maskModel = new MaskModel(elementState, this.options);\n        const [from, to] = elementState.selection;\n        maskModel.deleteCharacters([from, to]);\n        const newElementState = this.postprocessor(maskModel, initialState);\n        const newPossibleValue = initialState.value.slice(0, initialFrom) +\n            initialState.value.slice(initialTo);\n        if (newPossibleValue === newElementState.value &&\n            !force &&\n            !this.element.isContentEditable) {\n            return;\n        }\n        if (areElementValuesEqual(initialState, elementState, maskModel, newElementState)) {\n            event.preventDefault();\n            // User presses Backspace/Delete for the fixed value\n            return this.updateSelectionRange(isForward ? [to, to] : [from, from]);\n        }\n        this.upcomingElementState = newElementState;\n    }\n    handleInsert(event, data) {\n        const { options, maxLength, element, elementState: initialElementState } = this;\n        const { elementState, data: insertedText = data } = this.preprocessor({\n            data,\n            elementState: initialElementState,\n        }, 'insert');\n        const maskModel = new MaskModel(elementState, options);\n        try {\n            maskModel.addCharacters(elementState.selection, insertedText);\n        }\n        catch (_a) {\n            return event.preventDefault();\n        }\n        const [from, to] = elementState.selection;\n        const newPossibleValue = initialElementState.value.slice(0, from) +\n            data +\n            initialElementState.value.slice(to);\n        const newElementState = this.postprocessor(maskModel, initialElementState);\n        if (newElementState.value.length > maxLength) {\n            return event.preventDefault();\n        }\n        if (newPossibleValue !== newElementState.value || element.isContentEditable) {\n            this.upcomingElementState = newElementState;\n            if (options.overwriteMode === 'replace' &&\n                newPossibleValue.length > maxLength) {\n                /**\n                 * Browsers know nothing about Maskito and its `overwriteMode`.\n                 * When textfield value length is already equal to attribute `maxlength`,\n                 * pressing any key (even with valid value) does not emit `input` event.\n                 */\n                this.dispatchInputEvent({ inputType: 'insertText', data });\n            }\n        }\n    }\n    handleEnter(event) {\n        if (this.isTextArea || this.element.isContentEditable) {\n            this.handleInsert(event, '\\n');\n        }\n    }\n}\n\nfunction maskitoChangeEventPlugin() {\n    return (element) => {\n        if (element.isContentEditable) {\n            return;\n        }\n        let value = element.value;\n        const valueListener = () => {\n            value = element.value;\n        };\n        const blurListener = () => {\n            if (element.value !== value) {\n                element.dispatchEvent(new Event('change', { bubbles: true }));\n            }\n        };\n        element.addEventListener('focus', valueListener);\n        element.addEventListener('change', valueListener);\n        element.addEventListener('blur', blurListener);\n        return () => {\n            element.removeEventListener('focus', valueListener);\n            element.removeEventListener('change', valueListener);\n            element.removeEventListener('blur', blurListener);\n        };\n    };\n}\n\nfunction maskitoInitialCalibrationPlugin(customOptions) {\n    return (element, options) => {\n        var _a, _b;\n        const from = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n        const to = (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0;\n        maskitoUpdateElement(element, {\n            value: maskitoTransform(element.value, customOptions || options),\n            selection: [from, to],\n        });\n    };\n}\n\nfunction maskitoStrictCompositionPlugin() {\n    return (element, maskitoOptions) => {\n        const listener = (event) => {\n            var _a, _b;\n            if (event.inputType !== 'insertCompositionText') {\n                return;\n            }\n            const selection = [\n                (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0,\n                (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0,\n            ];\n            const elementState = {\n                selection,\n                value: element.value,\n            };\n            const validatedState = maskitoTransform(elementState, maskitoOptions);\n            if (!areElementStatesEqual(elementState, validatedState)) {\n                event.preventDefault();\n                maskitoUpdateElement(element, validatedState);\n            }\n        };\n        element.addEventListener('input', listener);\n        return () => element.removeEventListener('input', listener);\n    };\n}\n\nexport { MASKITO_DEFAULT_ELEMENT_PREDICATE, MASKITO_DEFAULT_OPTIONS, Maskito, maskitoAdaptContentEditable, maskitoChangeEventPlugin, maskitoInitialCalibrationPlugin, maskitoPipe, maskitoStrictCompositionPlugin, maskitoTransform, maskitoUpdateElement };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}