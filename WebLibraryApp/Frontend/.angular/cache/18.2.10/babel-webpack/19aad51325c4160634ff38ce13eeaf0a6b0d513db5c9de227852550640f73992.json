{"ast":null,"code":"import { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { inject, Directive } from '@angular/core';\nimport { tuiInjectElement, tuiIsHTMLElement, tuiContainsOrAfter } from '@taiga-ui/cdk/utils/dom';\nimport { tuiGetNativeFocused, tuiBlurNativeFocused, tuiGetClosestFocusable } from '@taiga-ui/cdk/utils/focus';\nclass TuiFocusTrap {\n  constructor() {\n    this.doc = inject(DOCUMENT);\n    this.el = tuiInjectElement();\n    this.activeElement = tuiGetNativeFocused(this.doc);\n    /**\n     * This would cause currently focused element to lose focus,\n     * but it might cause ExpressionChanged error due to potential HostBinding.\n     * Microtask keeps it in the same frame but allows change detection to run\n     */\n    void Promise.resolve().then(() => this.el.focus());\n  }\n  ngOnDestroy() {\n    tuiBlurNativeFocused(this.doc);\n    /**\n     * HostListeners are triggered even after ngOnDestroy\n     * {@link https://github.com/angular/angular/issues/38100}\n     * so we need to delay it but stay in the same sync cycle,\n     * therefore using Promise instead of setTimeout\n     */\n    // eslint-disable-next-line\n    Promise.resolve().then(() => {\n      if (tuiIsHTMLElement(this.activeElement)) {\n        this.activeElement.focus();\n      }\n    });\n  }\n  onFocusIn(node) {\n    if (!tuiContainsOrAfter(this.el, node)) {\n      tuiGetClosestFocusable({\n        initial: this.el,\n        root: this.el\n      })?.focus();\n    }\n  }\n  static {\n    this.ɵfac = function TuiFocusTrap_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TuiFocusTrap)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: TuiFocusTrap,\n      selectors: [[\"\", \"tuiFocusTrap\", \"\"]],\n      hostAttrs: [\"tabIndex\", \"0\"],\n      hostBindings: function TuiFocusTrap_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"focusin.silent\", function TuiFocusTrap_focusin_silent_HostBindingHandler($event) {\n            return ctx.onFocusIn($event.target);\n          }, false, i0.ɵɵresolveWindow);\n        }\n      },\n      standalone: true\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TuiFocusTrap, [{\n    type: Directive,\n    args: [{\n      standalone: true,\n      selector: '[tuiFocusTrap]',\n      host: {\n        tabIndex: '0',\n        '(window:focusin.silent)': 'onFocusIn($event.target)'\n      }\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TuiFocusTrap };","map":{"version":3,"names":["DOCUMENT","i0","inject","Directive","tuiInjectElement","tuiIsHTMLElement","tuiContainsOrAfter","tuiGetNativeFocused","tuiBlurNativeFocused","tuiGetClosestFocusable","TuiFocusTrap","constructor","doc","el","activeElement","Promise","resolve","then","focus","ngOnDestroy","onFocusIn","node","initial","root","ɵfac","TuiFocusTrap_Factory","__ngFactoryType__","ɵdir","ɵɵdefineDirective","type","selectors","hostAttrs","hostBindings","TuiFocusTrap_HostBindings","rf","ctx","ɵɵlistener","TuiFocusTrap_focusin_silent_HostBindingHandler","$event","target","ɵɵresolveWindow","standalone","ngDevMode","ɵsetClassMetadata","args","selector","host","tabIndex"],"sources":["C:/Users/Asus-PC/Downloads/WebLibraryNew/WebLibrary/WebLibraryApp/Frontend/node_modules/@taiga-ui/cdk/fesm2022/taiga-ui-cdk-directives-focus-trap.mjs"],"sourcesContent":["import { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { inject, Directive } from '@angular/core';\nimport { tuiInjectElement, tuiIsHTMLElement, tuiContainsOrAfter } from '@taiga-ui/cdk/utils/dom';\nimport { tuiGetNativeFocused, tuiBlurNativeFocused, tuiGetClosestFocusable } from '@taiga-ui/cdk/utils/focus';\n\nclass TuiFocusTrap {\n    constructor() {\n        this.doc = inject(DOCUMENT);\n        this.el = tuiInjectElement();\n        this.activeElement = tuiGetNativeFocused(this.doc);\n        /**\n         * This would cause currently focused element to lose focus,\n         * but it might cause ExpressionChanged error due to potential HostBinding.\n         * Microtask keeps it in the same frame but allows change detection to run\n         */\n        void Promise.resolve().then(() => this.el.focus());\n    }\n    ngOnDestroy() {\n        tuiBlurNativeFocused(this.doc);\n        /**\n         * HostListeners are triggered even after ngOnDestroy\n         * {@link https://github.com/angular/angular/issues/38100}\n         * so we need to delay it but stay in the same sync cycle,\n         * therefore using Promise instead of setTimeout\n         */\n        // eslint-disable-next-line\n        Promise.resolve().then(() => {\n            if (tuiIsHTMLElement(this.activeElement)) {\n                this.activeElement.focus();\n            }\n        });\n    }\n    onFocusIn(node) {\n        if (!tuiContainsOrAfter(this.el, node)) {\n            tuiGetClosestFocusable({\n                initial: this.el,\n                root: this.el,\n            })?.focus();\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: TuiFocusTrap, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: TuiFocusTrap, isStandalone: true, selector: \"[tuiFocusTrap]\", host: { attributes: { \"tabIndex\": \"0\" }, listeners: { \"window:focusin.silent\": \"onFocusIn($event.target)\" } }, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: TuiFocusTrap, decorators: [{\n            type: Directive,\n            args: [{\n                    standalone: true,\n                    selector: '[tuiFocusTrap]',\n                    host: {\n                        tabIndex: '0',\n                        '(window:focusin.silent)': 'onFocusIn($event.target)',\n                    },\n                }]\n        }], ctorParameters: function () { return []; } });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TuiFocusTrap };\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,iBAAiB;AAC1C,OAAO,KAAKC,EAAE,MAAM,eAAe;AACnC,SAASC,MAAM,EAAEC,SAAS,QAAQ,eAAe;AACjD,SAASC,gBAAgB,EAAEC,gBAAgB,EAAEC,kBAAkB,QAAQ,yBAAyB;AAChG,SAASC,mBAAmB,EAAEC,oBAAoB,EAAEC,sBAAsB,QAAQ,2BAA2B;AAE7G,MAAMC,YAAY,CAAC;EACfC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,GAAG,GAAGV,MAAM,CAACF,QAAQ,CAAC;IAC3B,IAAI,CAACa,EAAE,GAAGT,gBAAgB,CAAC,CAAC;IAC5B,IAAI,CAACU,aAAa,GAAGP,mBAAmB,CAAC,IAAI,CAACK,GAAG,CAAC;IAClD;AACR;AACA;AACA;AACA;IACQ,KAAKG,OAAO,CAACC,OAAO,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM,IAAI,CAACJ,EAAE,CAACK,KAAK,CAAC,CAAC,CAAC;EACtD;EACAC,WAAWA,CAAA,EAAG;IACVX,oBAAoB,CAAC,IAAI,CAACI,GAAG,CAAC;IAC9B;AACR;AACA;AACA;AACA;AACA;IACQ;IACAG,OAAO,CAACC,OAAO,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM;MACzB,IAAIZ,gBAAgB,CAAC,IAAI,CAACS,aAAa,CAAC,EAAE;QACtC,IAAI,CAACA,aAAa,CAACI,KAAK,CAAC,CAAC;MAC9B;IACJ,CAAC,CAAC;EACN;EACAE,SAASA,CAACC,IAAI,EAAE;IACZ,IAAI,CAACf,kBAAkB,CAAC,IAAI,CAACO,EAAE,EAAEQ,IAAI,CAAC,EAAE;MACpCZ,sBAAsB,CAAC;QACnBa,OAAO,EAAE,IAAI,CAACT,EAAE;QAChBU,IAAI,EAAE,IAAI,CAACV;MACf,CAAC,CAAC,EAAEK,KAAK,CAAC,CAAC;IACf;EACJ;EACA;IAAS,IAAI,CAACM,IAAI,YAAAC,qBAAAC,iBAAA;MAAA,YAAAA,iBAAA,IAAyFhB,YAAY;IAAA,CAAmD;EAAE;EAC5K;IAAS,IAAI,CAACiB,IAAI,kBAD+E1B,EAAE,CAAA2B,iBAAA;MAAAC,IAAA,EACJnB,YAAY;MAAAoB,SAAA;MAAAC,SAAA,eAAoF,GAAG;MAAAC,YAAA,WAAAC,0BAAAC,EAAA,EAAAC,GAAA;QAAA,IAAAD,EAAA;UADjGjC,EAAE,CAAAmC,UAAA,4BAAAC,+CAAAC,MAAA;YAAA,OACJH,GAAA,CAAAf,SAAA,CAAAkB,MAAA,CAAAC,MAAuB,CAAC;UAAA,UADtBtC,EAAE,CAAAuC,eACO,CAAC;QAAA;MAAA;MAAAC,UAAA;IAAA,EAAgL;EAAE;AACjS;AACA;EAAA,QAAAC,SAAA,oBAAAA,SAAA,KAHqGzC,EAAE,CAAA0C,iBAAA,CAGXjC,YAAY,EAAc,CAAC;IAC3GmB,IAAI,EAAE1B,SAAS;IACfyC,IAAI,EAAE,CAAC;MACCH,UAAU,EAAE,IAAI;MAChBI,QAAQ,EAAE,gBAAgB;MAC1BC,IAAI,EAAE;QACFC,QAAQ,EAAE,GAAG;QACb,yBAAyB,EAAE;MAC/B;IACJ,CAAC;EACT,CAAC,CAAC,EAAkB,YAAY;IAAE,OAAO,EAAE;EAAE,CAAC;AAAA;;AAEtD;AACA;AACA;;AAEA,SAASrC,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}