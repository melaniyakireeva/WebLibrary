{"ast":null,"code":"import { tuiClamp } from '@taiga-ui/cdk/utils/math';\nimport { tuiIsPresent } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { inject, ElementRef } from '@angular/core';\nfunction tuiContainsOrAfter(current, node) {\n  try {\n    return current.contains(node) || !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING);\n  } catch {\n    return false;\n  }\n}\nfunction tuiIsInput(element) {\n  return element.matches('input');\n}\nfunction tuiIsTextarea(element) {\n  return element.matches('textarea');\n}\nfunction tuiIsTextfield(element) {\n  return tuiIsInput(element) || tuiIsTextarea(element);\n}\nfunction tuiIsElement(node) {\n  return !!node && 'nodeType' in node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction tuiIsHTMLElement(node) {\n  const defaultView = node?.ownerDocument.defaultView;\n  return !!node && !!defaultView && node instanceof defaultView.HTMLElement;\n}\nfunction tuiIsTextNode(node) {\n  return node.nodeType === Node.TEXT_NODE;\n}\nfunction tuiIsInputEvent(event) {\n  return 'data' in event && 'inputType' in event;\n}\n\n/**\n * Gets actual target from open Shadow DOM if event happened within it\n */\nfunction tuiGetActualTarget(event) {\n  return event.composedPath()[0];\n}\nconst DEFAULT_FORMAT = 'text/plain';\n/**\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\nfunction tuiGetClipboardDataText(event, format = DEFAULT_FORMAT) {\n  return 'clipboardData' in event && event.clipboardData !== null ? event.clipboardData.getData(format) || event.clipboardData.getData(DEFAULT_FORMAT) : event.target.ownerDocument.defaultView.clipboardData.getData('text');\n}\nfunction tuiGetDocumentOrShadowRoot(node) {\n  return 'getRootNode' in node && node.isConnected ? node.getRootNode() : node.ownerDocument;\n}\n\n/**\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n * ```ts\n * function tuiGetElementObscures(element: Element): readonly [Element, Element, Element, Element] | [] | null\n * ```\n */\nfunction tuiGetElementObscures(element) {\n  const {\n    ownerDocument\n  } = element;\n  if (!ownerDocument?.defaultView || !element.getBoundingClientRect) {\n    return null;\n  }\n  const {\n    innerWidth,\n    innerHeight\n  } = ownerDocument.defaultView;\n  const doc = tuiGetDocumentOrShadowRoot(element);\n  const rect = element.getBoundingClientRect();\n  if (rect.width === 0 && rect.height === 0) {\n    return null;\n  }\n  const left = tuiClamp(Math.round(rect.left) + 2, 0, innerWidth);\n  const top = tuiClamp(Math.round(rect.top) + 2, 0, innerHeight);\n  const right = tuiClamp(Math.round(rect.right) - 2, 0, innerWidth);\n  const bottom = tuiClamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n  const horizontalMiddle = tuiClamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n  const verticalMiddle = tuiClamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n  const elements = [doc.elementFromPoint(horizontalMiddle, top), doc.elementFromPoint(horizontalMiddle, bottom), doc.elementFromPoint(left, verticalMiddle), doc.elementFromPoint(right, verticalMiddle)];\n  const nonNull = elements.filter(tuiIsPresent);\n  if (!nonNull.length) {\n    return [];\n  }\n  const filtered = nonNull.filter(el => !element.contains(el) && !el.contains(element));\n  return filtered.length === 4 ? filtered : null;\n}\n\n/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\n/**\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\nfunction tuiGetElementOffset(host, element) {\n  ngDevMode && console.assert(host.contains(element), 'Host must contain element');\n  let {\n    offsetTop,\n    offsetLeft,\n    offsetParent\n  } = element;\n  while (tuiIsHTMLElement(offsetParent) && offsetParent !== host) {\n    offsetTop += offsetParent.offsetTop;\n    offsetLeft += offsetParent.offsetLeft;\n    offsetParent = offsetParent.offsetParent;\n  }\n  return {\n    offsetTop,\n    offsetLeft\n  };\n}\nfunction tuiGetElementPoint(x, y, element) {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = element.getBoundingClientRect();\n  return [tuiClamp(x - left, 0, width) / width, tuiClamp(y - top, 0, height) / height];\n}\n\n/**\n * @description:\n * cross browser way to get selected text\n *\n * History:\n * BUG - window.getSelection() fails when text selected in a form field\n * https://bugzilla.mozilla.org/show_bug.cgi?id=85686\n */\nfunction tuiGetSelectedText({\n  getSelection,\n  document\n}) {\n  return document.activeElement && tuiIsTextfield(document.activeElement) ? document.activeElement.value.slice(document.activeElement.selectionStart || 0, document.activeElement.selectionEnd || 0) : getSelection()?.toString() || null;\n}\nfunction tuiInjectElement() {\n  return inject(ElementRef).nativeElement;\n}\nfunction tuiIsCurrentTarget({\n  target,\n  currentTarget\n}) {\n  return target === currentTarget;\n}\nfunction tuiIsElementEditable(element) {\n  return tuiIsTextfield(element) && !element.readOnly || !!element.isContentEditable;\n}\n\n/**\n * Checks if an app is running inside <iframe /> tag\n */\nfunction tuiIsInsideIframe(win) {\n  return win.parent !== win;\n}\n\n/**\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\nfunction tuiIsNodeIn(node, selector) {\n  return tuiIsTextNode(node) ? !!node.parentElement?.closest(selector) : tuiIsElement(node) && !!node.closest(selector);\n}\nfunction tuiPointToClientRect(x = 0, y = 0) {\n  const rect = {\n    x,\n    y,\n    left: x,\n    right: x,\n    top: y,\n    bottom: y,\n    width: 0,\n    height: 0\n  };\n  return {\n    ...rect,\n    toJSON: () => rect\n  };\n}\nfunction tuiRetargetedBoundaryCrossing(event) {\n  // firefox\n  if ('explicitOriginalTarget' in event) {\n    return event?.explicitOriginalTarget !== event.target;\n  }\n  // chrome\n  if ('pointerId' in event) {\n    return event.pointerId === -1;\n  }\n  // safari\n  if ('detail' in event && 'webkitForce' in event) {\n    return event?.detail === 0;\n  }\n  return false;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiContainsOrAfter, tuiGetActualTarget, tuiGetClipboardDataText, tuiGetDocumentOrShadowRoot, tuiGetElementObscures, tuiGetElementOffset, tuiGetElementPoint, tuiGetSelectedText, tuiInjectElement, tuiIsCurrentTarget, tuiIsElement, tuiIsElementEditable, tuiIsHTMLElement, tuiIsInput, tuiIsInputEvent, tuiIsInsideIframe, tuiIsNodeIn, tuiIsTextNode, tuiIsTextarea, tuiIsTextfield, tuiPointToClientRect, tuiRetargetedBoundaryCrossing };","map":{"version":3,"names":["tuiClamp","tuiIsPresent","inject","ElementRef","tuiContainsOrAfter","current","node","contains","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","tuiIsInput","element","matches","tuiIsTextarea","tuiIsTextfield","tuiIsElement","nodeType","ELEMENT_NODE","tuiIsHTMLElement","defaultView","ownerDocument","HTMLElement","tuiIsTextNode","TEXT_NODE","tuiIsInputEvent","event","tuiGetActualTarget","composedPath","DEFAULT_FORMAT","tuiGetClipboardDataText","format","clipboardData","getData","target","tuiGetDocumentOrShadowRoot","isConnected","getRootNode","tuiGetElementObscures","getBoundingClientRect","innerWidth","innerHeight","doc","rect","width","height","left","Math","round","top","right","bottom","horizontalMiddle","verticalMiddle","elements","elementFromPoint","nonNull","filter","length","filtered","el","tuiGetElementOffset","host","ngDevMode","console","assert","offsetTop","offsetLeft","offsetParent","tuiGetElementPoint","x","y","tuiGetSelectedText","getSelection","document","activeElement","value","slice","selectionStart","selectionEnd","toString","tuiInjectElement","nativeElement","tuiIsCurrentTarget","currentTarget","tuiIsElementEditable","readOnly","isContentEditable","tuiIsInsideIframe","win","parent","tuiIsNodeIn","selector","parentElement","closest","tuiPointToClientRect","toJSON","tuiRetargetedBoundaryCrossing","explicitOriginalTarget","pointerId","detail"],"sources":["C:/Users/Asus-PC/Downloads/WebLibraryNew/WebLibrary/WebLibraryApp/Frontend/node_modules/@taiga-ui/cdk/fesm2022/taiga-ui-cdk-utils-dom.mjs"],"sourcesContent":["import { tuiClamp } from '@taiga-ui/cdk/utils/math';\nimport { tuiIsPresent } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { inject, ElementRef } from '@angular/core';\n\nfunction tuiContainsOrAfter(current, node) {\n    try {\n        return (current.contains(node) ||\n            !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING));\n    }\n    catch {\n        return false;\n    }\n}\n\nfunction tuiIsInput(element) {\n    return element.matches('input');\n}\nfunction tuiIsTextarea(element) {\n    return element.matches('textarea');\n}\nfunction tuiIsTextfield(element) {\n    return tuiIsInput(element) || tuiIsTextarea(element);\n}\nfunction tuiIsElement(node) {\n    return !!node && 'nodeType' in node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction tuiIsHTMLElement(node) {\n    const defaultView = node?.ownerDocument.defaultView;\n    return !!node && !!defaultView && node instanceof defaultView.HTMLElement;\n}\nfunction tuiIsTextNode(node) {\n    return node.nodeType === Node.TEXT_NODE;\n}\n\nfunction tuiIsInputEvent(event) {\n    return 'data' in event && 'inputType' in event;\n}\n\n/**\n * Gets actual target from open Shadow DOM if event happened within it\n */\nfunction tuiGetActualTarget(event) {\n    return event.composedPath()[0];\n}\n\nconst DEFAULT_FORMAT = 'text/plain';\n/**\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\nfunction tuiGetClipboardDataText(event, format = DEFAULT_FORMAT) {\n    return 'clipboardData' in event && event.clipboardData !== null\n        ? event.clipboardData.getData(format) ||\n            event.clipboardData.getData(DEFAULT_FORMAT)\n        : event.target.ownerDocument.defaultView.clipboardData.getData('text');\n}\n\nfunction tuiGetDocumentOrShadowRoot(node) {\n    return 'getRootNode' in node && node.isConnected\n        ? node.getRootNode()\n        : node.ownerDocument;\n}\n\n/**\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n * ```ts\n * function tuiGetElementObscures(element: Element): readonly [Element, Element, Element, Element] | [] | null\n * ```\n */\nfunction tuiGetElementObscures(element) {\n    const { ownerDocument } = element;\n    if (!ownerDocument?.defaultView || !element.getBoundingClientRect) {\n        return null;\n    }\n    const { innerWidth, innerHeight } = ownerDocument.defaultView;\n    const doc = tuiGetDocumentOrShadowRoot(element);\n    const rect = element.getBoundingClientRect();\n    if (rect.width === 0 && rect.height === 0) {\n        return null;\n    }\n    const left = tuiClamp(Math.round(rect.left) + 2, 0, innerWidth);\n    const top = tuiClamp(Math.round(rect.top) + 2, 0, innerHeight);\n    const right = tuiClamp(Math.round(rect.right) - 2, 0, innerWidth);\n    const bottom = tuiClamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n    const horizontalMiddle = tuiClamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n    const verticalMiddle = tuiClamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n    const elements = [\n        doc.elementFromPoint(horizontalMiddle, top),\n        doc.elementFromPoint(horizontalMiddle, bottom),\n        doc.elementFromPoint(left, verticalMiddle),\n        doc.elementFromPoint(right, verticalMiddle),\n    ];\n    const nonNull = elements.filter(tuiIsPresent);\n    if (!nonNull.length) {\n        return [];\n    }\n    const filtered = nonNull.filter((el) => !element.contains(el) && !el.contains(element));\n    return filtered.length === 4\n        ? filtered\n        : null;\n}\n\n/// <reference types=\"@taiga-ui/tsconfig/ng-dev-mode\" />\n/**\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\nfunction tuiGetElementOffset(host, element) {\n    ngDevMode && console.assert(host.contains(element), 'Host must contain element');\n    let { offsetTop, offsetLeft, offsetParent } = element;\n    while (tuiIsHTMLElement(offsetParent) && offsetParent !== host) {\n        offsetTop += offsetParent.offsetTop;\n        offsetLeft += offsetParent.offsetLeft;\n        offsetParent = offsetParent.offsetParent;\n    }\n    return { offsetTop, offsetLeft };\n}\n\nfunction tuiGetElementPoint(x, y, element) {\n    const { left, top, width, height } = element.getBoundingClientRect();\n    return [tuiClamp(x - left, 0, width) / width, tuiClamp(y - top, 0, height) / height];\n}\n\n/**\n * @description:\n * cross browser way to get selected text\n *\n * History:\n * BUG - window.getSelection() fails when text selected in a form field\n * https://bugzilla.mozilla.org/show_bug.cgi?id=85686\n */\nfunction tuiGetSelectedText({ getSelection, document }) {\n    return document.activeElement && tuiIsTextfield(document.activeElement)\n        ? document.activeElement.value.slice(document.activeElement.selectionStart || 0, document.activeElement.selectionEnd || 0)\n        : getSelection()?.toString() || null;\n}\n\nfunction tuiInjectElement() {\n    return inject(ElementRef).nativeElement;\n}\n\nfunction tuiIsCurrentTarget({ target, currentTarget }) {\n    return target === currentTarget;\n}\n\nfunction tuiIsElementEditable(element) {\n    return (tuiIsTextfield(element) && !element.readOnly) || !!element.isContentEditable;\n}\n\n/**\n * Checks if an app is running inside <iframe /> tag\n */\nfunction tuiIsInsideIframe(win) {\n    return win.parent !== win;\n}\n\n/**\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\nfunction tuiIsNodeIn(node, selector) {\n    return tuiIsTextNode(node)\n        ? !!node.parentElement?.closest(selector)\n        : tuiIsElement(node) && !!node.closest(selector);\n}\n\nfunction tuiPointToClientRect(x = 0, y = 0) {\n    const rect = {\n        x,\n        y,\n        left: x,\n        right: x,\n        top: y,\n        bottom: y,\n        width: 0,\n        height: 0,\n    };\n    return {\n        ...rect,\n        toJSON: () => rect,\n    };\n}\n\nfunction tuiRetargetedBoundaryCrossing(event) {\n    // firefox\n    if ('explicitOriginalTarget' in event) {\n        return event?.explicitOriginalTarget !== event.target;\n    }\n    // chrome\n    if ('pointerId' in event) {\n        return event.pointerId === -1;\n    }\n    // safari\n    if ('detail' in event && 'webkitForce' in event) {\n        return event?.detail === 0;\n    }\n    return false;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiContainsOrAfter, tuiGetActualTarget, tuiGetClipboardDataText, tuiGetDocumentOrShadowRoot, tuiGetElementObscures, tuiGetElementOffset, tuiGetElementPoint, tuiGetSelectedText, tuiInjectElement, tuiIsCurrentTarget, tuiIsElement, tuiIsElementEditable, tuiIsHTMLElement, tuiIsInput, tuiIsInputEvent, tuiIsInsideIframe, tuiIsNodeIn, tuiIsTextNode, tuiIsTextarea, tuiIsTextfield, tuiPointToClientRect, tuiRetargetedBoundaryCrossing };\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,0BAA0B;AACnD,SAASC,YAAY,QAAQ,mCAAmC;AAChE,SAASC,MAAM,EAAEC,UAAU,QAAQ,eAAe;AAElD,SAASC,kBAAkBA,CAACC,OAAO,EAAEC,IAAI,EAAE;EACvC,IAAI;IACA,OAAQD,OAAO,CAACE,QAAQ,CAACD,IAAI,CAAC,IAC1B,CAAC,EAAEA,IAAI,CAACE,uBAAuB,CAACH,OAAO,CAAC,GAAGI,IAAI,CAACC,2BAA2B,CAAC;EACpF,CAAC,CACD,MAAM;IACF,OAAO,KAAK;EAChB;AACJ;AAEA,SAASC,UAAUA,CAACC,OAAO,EAAE;EACzB,OAAOA,OAAO,CAACC,OAAO,CAAC,OAAO,CAAC;AACnC;AACA,SAASC,aAAaA,CAACF,OAAO,EAAE;EAC5B,OAAOA,OAAO,CAACC,OAAO,CAAC,UAAU,CAAC;AACtC;AACA,SAASE,cAAcA,CAACH,OAAO,EAAE;EAC7B,OAAOD,UAAU,CAACC,OAAO,CAAC,IAAIE,aAAa,CAACF,OAAO,CAAC;AACxD;AACA,SAASI,YAAYA,CAACV,IAAI,EAAE;EACxB,OAAO,CAAC,CAACA,IAAI,IAAI,UAAU,IAAIA,IAAI,IAAIA,IAAI,CAACW,QAAQ,KAAKR,IAAI,CAACS,YAAY;AAC9E;AACA,SAASC,gBAAgBA,CAACb,IAAI,EAAE;EAC5B,MAAMc,WAAW,GAAGd,IAAI,EAAEe,aAAa,CAACD,WAAW;EACnD,OAAO,CAAC,CAACd,IAAI,IAAI,CAAC,CAACc,WAAW,IAAId,IAAI,YAAYc,WAAW,CAACE,WAAW;AAC7E;AACA,SAASC,aAAaA,CAACjB,IAAI,EAAE;EACzB,OAAOA,IAAI,CAACW,QAAQ,KAAKR,IAAI,CAACe,SAAS;AAC3C;AAEA,SAASC,eAAeA,CAACC,KAAK,EAAE;EAC5B,OAAO,MAAM,IAAIA,KAAK,IAAI,WAAW,IAAIA,KAAK;AAClD;;AAEA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACD,KAAK,EAAE;EAC/B,OAAOA,KAAK,CAACE,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC;AAEA,MAAMC,cAAc,GAAG,YAAY;AACnC;AACA;AACA;AACA,SAASC,uBAAuBA,CAACJ,KAAK,EAAEK,MAAM,GAAGF,cAAc,EAAE;EAC7D,OAAO,eAAe,IAAIH,KAAK,IAAIA,KAAK,CAACM,aAAa,KAAK,IAAI,GACzDN,KAAK,CAACM,aAAa,CAACC,OAAO,CAACF,MAAM,CAAC,IACjCL,KAAK,CAACM,aAAa,CAACC,OAAO,CAACJ,cAAc,CAAC,GAC7CH,KAAK,CAACQ,MAAM,CAACb,aAAa,CAACD,WAAW,CAACY,aAAa,CAACC,OAAO,CAAC,MAAM,CAAC;AAC9E;AAEA,SAASE,0BAA0BA,CAAC7B,IAAI,EAAE;EACtC,OAAO,aAAa,IAAIA,IAAI,IAAIA,IAAI,CAAC8B,WAAW,GAC1C9B,IAAI,CAAC+B,WAAW,CAAC,CAAC,GAClB/B,IAAI,CAACe,aAAa;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiB,qBAAqBA,CAAC1B,OAAO,EAAE;EACpC,MAAM;IAAES;EAAc,CAAC,GAAGT,OAAO;EACjC,IAAI,CAACS,aAAa,EAAED,WAAW,IAAI,CAACR,OAAO,CAAC2B,qBAAqB,EAAE;IAC/D,OAAO,IAAI;EACf;EACA,MAAM;IAAEC,UAAU;IAAEC;EAAY,CAAC,GAAGpB,aAAa,CAACD,WAAW;EAC7D,MAAMsB,GAAG,GAAGP,0BAA0B,CAACvB,OAAO,CAAC;EAC/C,MAAM+B,IAAI,GAAG/B,OAAO,CAAC2B,qBAAqB,CAAC,CAAC;EAC5C,IAAII,IAAI,CAACC,KAAK,KAAK,CAAC,IAAID,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;IACvC,OAAO,IAAI;EACf;EACA,MAAMC,IAAI,GAAG9C,QAAQ,CAAC+C,IAAI,CAACC,KAAK,CAACL,IAAI,CAACG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAEN,UAAU,CAAC;EAC/D,MAAMS,GAAG,GAAGjD,QAAQ,CAAC+C,IAAI,CAACC,KAAK,CAACL,IAAI,CAACM,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,EAAER,WAAW,CAAC;EAC9D,MAAMS,KAAK,GAAGlD,QAAQ,CAAC+C,IAAI,CAACC,KAAK,CAACL,IAAI,CAACO,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,EAAEV,UAAU,CAAC;EACjE,MAAMW,MAAM,GAAGnD,QAAQ,CAAC+C,IAAI,CAACC,KAAK,CAACL,IAAI,CAACQ,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,EAAEV,WAAW,CAAC;EACpE,MAAMW,gBAAgB,GAAGpD,QAAQ,CAAC+C,IAAI,CAACC,KAAK,CAACL,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,EAAEJ,UAAU,CAAC;EACxF,MAAMa,cAAc,GAAGrD,QAAQ,CAAC+C,IAAI,CAACC,KAAK,CAACL,IAAI,CAACM,GAAG,GAAGN,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAEJ,WAAW,CAAC;EACvF,MAAMa,QAAQ,GAAG,CACbZ,GAAG,CAACa,gBAAgB,CAACH,gBAAgB,EAAEH,GAAG,CAAC,EAC3CP,GAAG,CAACa,gBAAgB,CAACH,gBAAgB,EAAED,MAAM,CAAC,EAC9CT,GAAG,CAACa,gBAAgB,CAACT,IAAI,EAAEO,cAAc,CAAC,EAC1CX,GAAG,CAACa,gBAAgB,CAACL,KAAK,EAAEG,cAAc,CAAC,CAC9C;EACD,MAAMG,OAAO,GAAGF,QAAQ,CAACG,MAAM,CAACxD,YAAY,CAAC;EAC7C,IAAI,CAACuD,OAAO,CAACE,MAAM,EAAE;IACjB,OAAO,EAAE;EACb;EACA,MAAMC,QAAQ,GAAGH,OAAO,CAACC,MAAM,CAAEG,EAAE,IAAK,CAAChD,OAAO,CAACL,QAAQ,CAACqD,EAAE,CAAC,IAAI,CAACA,EAAE,CAACrD,QAAQ,CAACK,OAAO,CAAC,CAAC;EACvF,OAAO+C,QAAQ,CAACD,MAAM,KAAK,CAAC,GACtBC,QAAQ,GACR,IAAI;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,mBAAmBA,CAACC,IAAI,EAAElD,OAAO,EAAE;EACxCmD,SAAS,IAAIC,OAAO,CAACC,MAAM,CAACH,IAAI,CAACvD,QAAQ,CAACK,OAAO,CAAC,EAAE,2BAA2B,CAAC;EAChF,IAAI;IAAEsD,SAAS;IAAEC,UAAU;IAAEC;EAAa,CAAC,GAAGxD,OAAO;EACrD,OAAOO,gBAAgB,CAACiD,YAAY,CAAC,IAAIA,YAAY,KAAKN,IAAI,EAAE;IAC5DI,SAAS,IAAIE,YAAY,CAACF,SAAS;IACnCC,UAAU,IAAIC,YAAY,CAACD,UAAU;IACrCC,YAAY,GAAGA,YAAY,CAACA,YAAY;EAC5C;EACA,OAAO;IAAEF,SAAS;IAAEC;EAAW,CAAC;AACpC;AAEA,SAASE,kBAAkBA,CAACC,CAAC,EAAEC,CAAC,EAAE3D,OAAO,EAAE;EACvC,MAAM;IAAEkC,IAAI;IAAEG,GAAG;IAAEL,KAAK;IAAEC;EAAO,CAAC,GAAGjC,OAAO,CAAC2B,qBAAqB,CAAC,CAAC;EACpE,OAAO,CAACvC,QAAQ,CAACsE,CAAC,GAAGxB,IAAI,EAAE,CAAC,EAAEF,KAAK,CAAC,GAAGA,KAAK,EAAE5C,QAAQ,CAACuE,CAAC,GAAGtB,GAAG,EAAE,CAAC,EAAEJ,MAAM,CAAC,GAAGA,MAAM,CAAC;AACxF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2B,kBAAkBA,CAAC;EAAEC,YAAY;EAAEC;AAAS,CAAC,EAAE;EACpD,OAAOA,QAAQ,CAACC,aAAa,IAAI5D,cAAc,CAAC2D,QAAQ,CAACC,aAAa,CAAC,GACjED,QAAQ,CAACC,aAAa,CAACC,KAAK,CAACC,KAAK,CAACH,QAAQ,CAACC,aAAa,CAACG,cAAc,IAAI,CAAC,EAAEJ,QAAQ,CAACC,aAAa,CAACI,YAAY,IAAI,CAAC,CAAC,GACxHN,YAAY,CAAC,CAAC,EAAEO,QAAQ,CAAC,CAAC,IAAI,IAAI;AAC5C;AAEA,SAASC,gBAAgBA,CAAA,EAAG;EACxB,OAAO/E,MAAM,CAACC,UAAU,CAAC,CAAC+E,aAAa;AAC3C;AAEA,SAASC,kBAAkBA,CAAC;EAAEjD,MAAM;EAAEkD;AAAc,CAAC,EAAE;EACnD,OAAOlD,MAAM,KAAKkD,aAAa;AACnC;AAEA,SAASC,oBAAoBA,CAACzE,OAAO,EAAE;EACnC,OAAQG,cAAc,CAACH,OAAO,CAAC,IAAI,CAACA,OAAO,CAAC0E,QAAQ,IAAK,CAAC,CAAC1E,OAAO,CAAC2E,iBAAiB;AACxF;;AAEA;AACA;AACA;AACA,SAASC,iBAAiBA,CAACC,GAAG,EAAE;EAC5B,OAAOA,GAAG,CAACC,MAAM,KAAKD,GAAG;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,WAAWA,CAACrF,IAAI,EAAEsF,QAAQ,EAAE;EACjC,OAAOrE,aAAa,CAACjB,IAAI,CAAC,GACpB,CAAC,CAACA,IAAI,CAACuF,aAAa,EAAEC,OAAO,CAACF,QAAQ,CAAC,GACvC5E,YAAY,CAACV,IAAI,CAAC,IAAI,CAAC,CAACA,IAAI,CAACwF,OAAO,CAACF,QAAQ,CAAC;AACxD;AAEA,SAASG,oBAAoBA,CAACzB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAE;EACxC,MAAM5B,IAAI,GAAG;IACT2B,CAAC;IACDC,CAAC;IACDzB,IAAI,EAAEwB,CAAC;IACPpB,KAAK,EAAEoB,CAAC;IACRrB,GAAG,EAAEsB,CAAC;IACNpB,MAAM,EAAEoB,CAAC;IACT3B,KAAK,EAAE,CAAC;IACRC,MAAM,EAAE;EACZ,CAAC;EACD,OAAO;IACH,GAAGF,IAAI;IACPqD,MAAM,EAAEA,CAAA,KAAMrD;EAClB,CAAC;AACL;AAEA,SAASsD,6BAA6BA,CAACvE,KAAK,EAAE;EAC1C;EACA,IAAI,wBAAwB,IAAIA,KAAK,EAAE;IACnC,OAAOA,KAAK,EAAEwE,sBAAsB,KAAKxE,KAAK,CAACQ,MAAM;EACzD;EACA;EACA,IAAI,WAAW,IAAIR,KAAK,EAAE;IACtB,OAAOA,KAAK,CAACyE,SAAS,KAAK,CAAC,CAAC;EACjC;EACA;EACA,IAAI,QAAQ,IAAIzE,KAAK,IAAI,aAAa,IAAIA,KAAK,EAAE;IAC7C,OAAOA,KAAK,EAAE0E,MAAM,KAAK,CAAC;EAC9B;EACA,OAAO,KAAK;AAChB;;AAEA;AACA;AACA;;AAEA,SAAShG,kBAAkB,EAAEuB,kBAAkB,EAAEG,uBAAuB,EAAEK,0BAA0B,EAAEG,qBAAqB,EAAEuB,mBAAmB,EAAEQ,kBAAkB,EAAEG,kBAAkB,EAAES,gBAAgB,EAAEE,kBAAkB,EAAEnE,YAAY,EAAEqE,oBAAoB,EAAElE,gBAAgB,EAAER,UAAU,EAAEc,eAAe,EAAE+D,iBAAiB,EAAEG,WAAW,EAAEpE,aAAa,EAAET,aAAa,EAAEC,cAAc,EAAEgF,oBAAoB,EAAEE,6BAA6B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}