{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// This is a legacy function.\n// Use `findNumbers()` instead.\nimport { PLUS_CHARS, VALID_PUNCTUATION, VALID_DIGITS, WHITESPACE } from '../constants.js';\nimport parse from '../parse.js';\nimport { VALID_PHONE_NUMBER_WITH_EXTENSION } from '../helpers/isViablePhoneNumber.js';\nimport createExtensionPattern from '../helpers/extension/createExtensionPattern.js';\nimport parsePreCandidate from '../findNumbers/parsePreCandidate.js';\nimport isValidPreCandidate from '../findNumbers/isValidPreCandidate.js';\nimport isValidCandidate from '../findNumbers/isValidCandidate.js';\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\n\nexport var EXTN_PATTERNS_FOR_PARSING = createExtensionPattern('parsing');\nvar WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+');\nvar PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$'); // // Regular expression for getting opening brackets for a valid number\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\n\nvar VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/;\nexport default function findPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n  var search = new PhoneNumberSearch(text, options, metadata);\n  var phones = [];\n  while (search.hasNext()) {\n    phones.push(search.next());\n  }\n  return phones;\n}\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\n\nexport function searchPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n  var search = new PhoneNumberSearch(text, options, metadata);\n  return _defineProperty({}, Symbol.iterator, function () {\n    return {\n      next: function next() {\n        if (search.hasNext()) {\n          return {\n            done: false,\n            value: search.next()\n          };\n        }\n        return {\n          done: true\n        };\n      }\n    };\n  });\n}\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\n\nexport var PhoneNumberSearch = /*#__PURE__*/function () {\n  function PhoneNumberSearch(text, options, metadata) {\n    _classCallCheck(this, PhoneNumberSearch);\n    this.text = text; // If assigning the `{}` default value is moved to the arguments above,\n    // code coverage would decrease for some weird reason.\n\n    this.options = options || {};\n    this.metadata = metadata; // Iteration tristate.\n\n    this.state = 'NOT_READY';\n    this.regexp = new RegExp(VALID_PHONE_NUMBER_WITH_EXTENSION, 'ig');\n  }\n  _createClass(PhoneNumberSearch, [{\n    key: \"find\",\n    value: function find() {\n      var matches = this.regexp.exec(this.text);\n      if (!matches) {\n        return;\n      }\n      var number = matches[0];\n      var startsAt = matches.index;\n      number = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '');\n      startsAt += matches[0].length - number.length; // Fixes not parsing numbers with whitespace in the end.\n      // Also fixes not parsing numbers with opening parentheses in the end.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/252\n\n      number = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '');\n      number = parsePreCandidate(number);\n      var result = this.parseCandidate(number, startsAt);\n      if (result) {\n        return result;\n      } // Tail recursion.\n      // Try the next one if this one is not a valid phone number.\n\n      return this.find();\n    }\n  }, {\n    key: \"parseCandidate\",\n    value: function parseCandidate(number, startsAt) {\n      if (!isValidPreCandidate(number, startsAt, this.text)) {\n        return;\n      } // Don't parse phone numbers which are non-phone numbers\n      // due to being part of something else (e.g. a UUID).\n      // https://github.com/catamphetamine/libphonenumber-js/issues/213\n      // Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\n\n      if (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {\n        return;\n      } // // Prepend any opening brackets left behind by the\n      // // `PHONE_NUMBER_START_PATTERN` regexp.\n      // const text_before_number = text.slice(this.searching_from, startsAt)\n      // const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\n      // if (full_number_starts_at >= 0)\n      // {\n      // \tnumber   = text_before_number.slice(full_number_starts_at) + number\n      // \tstartsAt = full_number_starts_at\n      // }\n      //\n      // this.searching_from = matches.lastIndex\n\n      var result = parse(number, this.options, this.metadata);\n      if (!result.phone) {\n        return;\n      }\n      result.startsAt = startsAt;\n      result.endsAt = startsAt + number.length;\n      return result;\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext() {\n      if (this.state === 'NOT_READY') {\n        this.last_match = this.find();\n        if (this.last_match) {\n          this.state = 'READY';\n        } else {\n          this.state = 'DONE';\n        }\n      }\n      return this.state === 'READY';\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      // Check the state and find the next match as a side-effect if necessary.\n      if (!this.hasNext()) {\n        throw new Error('No next element');\n      } // Don't retain that memory any longer than necessary.\n\n      var result = this.last_match;\n      this.last_match = null;\n      this.state = 'NOT_READY';\n      return result;\n    }\n  }]);\n  return PhoneNumberSearch;\n}();","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","PLUS_CHARS","VALID_PUNCTUATION","VALID_DIGITS","WHITESPACE","parse","VALID_PHONE_NUMBER_WITH_EXTENSION","createExtensionPattern","parsePreCandidate","isValidPreCandidate","isValidCandidate","EXTN_PATTERNS_FOR_PARSING","WHITESPACE_IN_THE_BEGINNING_PATTERN","RegExp","PUNCTUATION_IN_THE_END_PATTERN","VALID_PRECEDING_CHARACTER_PATTERN","findPhoneNumbers","text","options","metadata","undefined","search","PhoneNumberSearch","phones","hasNext","push","next","searchPhoneNumbers","Symbol","iterator","done","state","regexp","find","matches","exec","number","startsAt","index","replace","result","parseCandidate","extended","phone","endsAt","last_match","Error"],"sources":["C:/Users/Asus-PC/Downloads/WebLibraryNew/WebLibrary/WebLibraryApp/Frontend/node_modules/libphonenumber-js/es6/legacy/findPhoneNumbersInitialImplementation.js"],"sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// This is a legacy function.\n// Use `findNumbers()` instead.\nimport { PLUS_CHARS, VALID_PUNCTUATION, VALID_DIGITS, WHITESPACE } from '../constants.js';\nimport parse from '../parse.js';\nimport { VALID_PHONE_NUMBER_WITH_EXTENSION } from '../helpers/isViablePhoneNumber.js';\nimport createExtensionPattern from '../helpers/extension/createExtensionPattern.js';\nimport parsePreCandidate from '../findNumbers/parsePreCandidate.js';\nimport isValidPreCandidate from '../findNumbers/isValidPreCandidate.js';\nimport isValidCandidate from '../findNumbers/isValidCandidate.js';\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\n\nexport var EXTN_PATTERNS_FOR_PARSING = createExtensionPattern('parsing');\nvar WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+');\nvar PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$'); // // Regular expression for getting opening brackets for a valid number\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\n\nvar VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/;\nexport default function findPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n\n  var search = new PhoneNumberSearch(text, options, metadata);\n  var phones = [];\n\n  while (search.hasNext()) {\n    phones.push(search.next());\n  }\n\n  return phones;\n}\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\n\nexport function searchPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n\n  var search = new PhoneNumberSearch(text, options, metadata);\n  return _defineProperty({}, Symbol.iterator, function () {\n    return {\n      next: function next() {\n        if (search.hasNext()) {\n          return {\n            done: false,\n            value: search.next()\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  });\n}\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\n\nexport var PhoneNumberSearch = /*#__PURE__*/function () {\n  function PhoneNumberSearch(text, options, metadata) {\n    _classCallCheck(this, PhoneNumberSearch);\n\n    this.text = text; // If assigning the `{}` default value is moved to the arguments above,\n    // code coverage would decrease for some weird reason.\n\n    this.options = options || {};\n    this.metadata = metadata; // Iteration tristate.\n\n    this.state = 'NOT_READY';\n    this.regexp = new RegExp(VALID_PHONE_NUMBER_WITH_EXTENSION, 'ig');\n  }\n\n  _createClass(PhoneNumberSearch, [{\n    key: \"find\",\n    value: function find() {\n      var matches = this.regexp.exec(this.text);\n\n      if (!matches) {\n        return;\n      }\n\n      var number = matches[0];\n      var startsAt = matches.index;\n      number = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '');\n      startsAt += matches[0].length - number.length; // Fixes not parsing numbers with whitespace in the end.\n      // Also fixes not parsing numbers with opening parentheses in the end.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/252\n\n      number = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '');\n      number = parsePreCandidate(number);\n      var result = this.parseCandidate(number, startsAt);\n\n      if (result) {\n        return result;\n      } // Tail recursion.\n      // Try the next one if this one is not a valid phone number.\n\n\n      return this.find();\n    }\n  }, {\n    key: \"parseCandidate\",\n    value: function parseCandidate(number, startsAt) {\n      if (!isValidPreCandidate(number, startsAt, this.text)) {\n        return;\n      } // Don't parse phone numbers which are non-phone numbers\n      // due to being part of something else (e.g. a UUID).\n      // https://github.com/catamphetamine/libphonenumber-js/issues/213\n      // Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\n\n\n      if (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {\n        return;\n      } // // Prepend any opening brackets left behind by the\n      // // `PHONE_NUMBER_START_PATTERN` regexp.\n      // const text_before_number = text.slice(this.searching_from, startsAt)\n      // const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\n      // if (full_number_starts_at >= 0)\n      // {\n      // \tnumber   = text_before_number.slice(full_number_starts_at) + number\n      // \tstartsAt = full_number_starts_at\n      // }\n      //\n      // this.searching_from = matches.lastIndex\n\n\n      var result = parse(number, this.options, this.metadata);\n\n      if (!result.phone) {\n        return;\n      }\n\n      result.startsAt = startsAt;\n      result.endsAt = startsAt + number.length;\n      return result;\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext() {\n      if (this.state === 'NOT_READY') {\n        this.last_match = this.find();\n\n        if (this.last_match) {\n          this.state = 'READY';\n        } else {\n          this.state = 'DONE';\n        }\n      }\n\n      return this.state === 'READY';\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      // Check the state and find the next match as a side-effect if necessary.\n      if (!this.hasNext()) {\n        throw new Error('No next element');\n      } // Don't retain that memory any longer than necessary.\n\n\n      var result = this.last_match;\n      this.last_match = null;\n      this.state = 'NOT_READY';\n      return result;\n    }\n  }]);\n\n  return PhoneNumberSearch;\n}();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}