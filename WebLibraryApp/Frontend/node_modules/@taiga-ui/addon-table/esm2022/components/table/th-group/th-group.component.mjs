import { AsyncPipe, NgForOf, NgIf, NgTemplateOutlet } from '@angular/common';
import { ChangeDetectionStrategy, Component, ContentChild, ContentChildren, forwardRef, inject, } from '@angular/core';
import { EMPTY_QUERY } from '@taiga-ui/cdk/constants';
import { map, startWith } from 'rxjs';
import { TuiTableHead } from '../directives/head.directive';
import { TuiTableDirective } from '../directives/table.directive';
import { TUI_TABLE_PROVIDER } from '../providers/table.provider';
import { TuiTableTh } from '../th/th.component';
import * as i0 from "@angular/core";
class TuiTableThGroup {
    constructor() {
        this.heads = EMPTY_QUERY;
        this.heads$ = null;
        this.table = inject(forwardRef(() => TuiTableDirective));
    }
    ngAfterContentInit() {
        this.heads$ = this.heads.changes.pipe(startWith(null), map(() => this.heads.reduce((record, item) => ({ ...record, [item.tuiHead]: item }), {})));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiTableThGroup, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TuiTableThGroup, isStandalone: true, selector: "tr[tuiThGroup]", providers: [TUI_TABLE_PROVIDER], queries: [{ propertyName: "th", first: true, predicate: i0.forwardRef(function () { return TuiTableTh; }), descendants: true }, { propertyName: "heads", predicate: i0.forwardRef(function () { return TuiTableHead; }) }], ngImport: i0, template: "<ng-content />\n<ng-container *ngIf=\"heads$ | async as headings\">\n    <ng-container\n        *ngFor=\"let key of table.columns\"\n        [ngTemplateOutlet]=\"(headings[key] && headings[key].template) || plain\"\n        [ngTemplateOutletContext]=\"{$implicit: key}\"\n    />\n    <ng-template\n        #plain\n        let-key\n    >\n        <th\n            *ngIf=\"!th && !heads.length\"\n            tuiTh\n        >\n            {{ key.toString() }}\n        </th>\n    </ng-template>\n</ng-container>\n", dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "directive", type: NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: TuiTableTh, selector: "th[tuiTh]", inputs: ["sorter", "resizable", "sticky", "requiredSort"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { TuiTableThGroup };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiTableThGroup, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'tr[tuiThGroup]', imports: [AsyncPipe, NgForOf, NgIf, NgTemplateOutlet, TuiTableTh], changeDetection: ChangeDetectionStrategy.OnPush, providers: [TUI_TABLE_PROVIDER], template: "<ng-content />\n<ng-container *ngIf=\"heads$ | async as headings\">\n    <ng-container\n        *ngFor=\"let key of table.columns\"\n        [ngTemplateOutlet]=\"(headings[key] && headings[key].template) || plain\"\n        [ngTemplateOutletContext]=\"{$implicit: key}\"\n    />\n    <ng-template\n        #plain\n        let-key\n    >\n        <th\n            *ngIf=\"!th && !heads.length\"\n            tuiTh\n        >\n            {{ key.toString() }}\n        </th>\n    </ng-template>\n</ng-container>\n" }]
        }], propDecorators: { th: [{
                type: ContentChild,
                args: [forwardRef(() => TuiTableTh)]
            }], heads: [{
                type: ContentChildren,
                args: [forwardRef(() => TuiTableHead)]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGgtZ3JvdXAuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYWRkb24tdGFibGUvY29tcG9uZW50cy90YWJsZS90aC1ncm91cC90aC1ncm91cC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hZGRvbi10YWJsZS9jb21wb25lbnRzL3RhYmxlL3RoLWdyb3VwL3RoLWdyb3VwLnRlbXBsYXRlLmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFM0UsT0FBTyxFQUNILHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsWUFBWSxFQUNaLGVBQWUsRUFDZixVQUFVLEVBQ1YsTUFBTSxHQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUVwRCxPQUFPLEVBQUMsR0FBRyxFQUFFLFNBQVMsRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUVwQyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDMUQsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sK0JBQStCLENBQUM7QUFDaEUsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sNkJBQTZCLENBQUM7QUFDL0QsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLG9CQUFvQixDQUFDOztBQUU5QyxNQVFhLGVBQWU7SUFSNUI7UUFldUIsVUFBSyxHQUErQixXQUFXLENBQUM7UUFFekQsV0FBTSxHQUFvRCxJQUFJLENBQUM7UUFFdEQsVUFBSyxHQUFHLE1BQU0sQ0FDN0IsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLENBQ3RDLENBQUM7S0FhTDtJQVhVLGtCQUFrQjtRQUNyQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FDakMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUNmLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FDTCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FDYixDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxJQUFJLEVBQUMsQ0FBQyxFQUNyRCxFQUFzQyxDQUN6QyxDQUNKLENBQ0osQ0FBQztJQUNOLENBQUM7K0dBekJRLGVBQWU7bUdBQWYsZUFBZSw2REFGYixDQUFDLGtCQUFrQixDQUFDLDZGQUtBLFVBQVUsa0dBR1AsWUFBWSxpQ0NqQ2xELGlnQkFtQkEsdUNER2MsU0FBUyw4Q0FBRSxPQUFPLG1IQUFFLElBQUksNkZBQUUsZ0JBQWdCLG9KQUFFLFVBQVU7O1NBS3ZELGVBQWU7NEZBQWYsZUFBZTtrQkFSM0IsU0FBUztpQ0FDTSxJQUFJLFlBQ04sZ0JBQWdCLFdBQ2pCLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxDQUFDLG1CQUVoRCx1QkFBdUIsQ0FBQyxNQUFNLGFBQ3BDLENBQUMsa0JBQWtCLENBQUM7OEJBTVosRUFBRTtzQkFEcEIsWUFBWTt1QkFBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDO2dCQUl2QixLQUFLO3NCQUR2QixlQUFlO3VCQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0FzeW5jUGlwZSwgTmdGb3JPZiwgTmdJZiwgTmdUZW1wbGF0ZU91dGxldH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB0eXBlIHtBZnRlckNvbnRlbnRJbml0LCBRdWVyeUxpc3R9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBmb3J3YXJkUmVmLFxuICAgIGluamVjdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0VNUFRZX1FVRVJZfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2NvbnN0YW50cyc7XG5pbXBvcnQgdHlwZSB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge21hcCwgc3RhcnRXaXRofSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHtUdWlUYWJsZUhlYWR9IGZyb20gJy4uL2RpcmVjdGl2ZXMvaGVhZC5kaXJlY3RpdmUnO1xuaW1wb3J0IHtUdWlUYWJsZURpcmVjdGl2ZX0gZnJvbSAnLi4vZGlyZWN0aXZlcy90YWJsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHtUVUlfVEFCTEVfUFJPVklERVJ9IGZyb20gJy4uL3Byb3ZpZGVycy90YWJsZS5wcm92aWRlcic7XG5pbXBvcnQge1R1aVRhYmxlVGh9IGZyb20gJy4uL3RoL3RoLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgc2VsZWN0b3I6ICd0clt0dWlUaEdyb3VwXScsXG4gICAgaW1wb3J0czogW0FzeW5jUGlwZSwgTmdGb3JPZiwgTmdJZiwgTmdUZW1wbGF0ZU91dGxldCwgVHVpVGFibGVUaF0sXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RoLWdyb3VwLnRlbXBsYXRlLmh0bWwnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1RVSV9UQUJMRV9QUk9WSURFUl0sXG59KVxuZXhwb3J0IGNsYXNzIFR1aVRhYmxlVGhHcm91cDxUIGV4dGVuZHMgUGFydGlhbDxSZWNvcmQ8a2V5b2YgVCwgYW55Pj4+XG4gICAgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0XG57XG4gICAgQENvbnRlbnRDaGlsZChmb3J3YXJkUmVmKCgpID0+IFR1aVRhYmxlVGgpKVxuICAgIHByb3RlY3RlZCByZWFkb25seSB0aCE6IFR1aVRhYmxlVGg8VD47XG5cbiAgICBAQ29udGVudENoaWxkcmVuKGZvcndhcmRSZWYoKCkgPT4gVHVpVGFibGVIZWFkKSlcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgaGVhZHM6IFF1ZXJ5TGlzdDxUdWlUYWJsZUhlYWQ8VD4+ID0gRU1QVFlfUVVFUlk7XG5cbiAgICBwcm90ZWN0ZWQgaGVhZHMkOiBPYnNlcnZhYmxlPFJlY29yZDxhbnksIFR1aVRhYmxlSGVhZDxUPj4+IHwgbnVsbCA9IG51bGw7XG5cbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGFibGUgPSBpbmplY3Q8VHVpVGFibGVEaXJlY3RpdmU8VD4+KFxuICAgICAgICBmb3J3YXJkUmVmKCgpID0+IFR1aVRhYmxlRGlyZWN0aXZlKSxcbiAgICApO1xuXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oZWFkcyQgPSB0aGlzLmhlYWRzLmNoYW5nZXMucGlwZShcbiAgICAgICAgICAgIHN0YXJ0V2l0aChudWxsKSxcbiAgICAgICAgICAgIG1hcCgoKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZHMucmVkdWNlKFxuICAgICAgICAgICAgICAgICAgICAocmVjb3JkLCBpdGVtKSA9PiAoey4uLnJlY29yZCwgW2l0ZW0udHVpSGVhZF06IGl0ZW19KSxcbiAgICAgICAgICAgICAgICAgICAge30gYXMgUmVjb3JkPGtleW9mIFQsIFR1aVRhYmxlSGVhZDxUPj4sXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwiPG5nLWNvbnRlbnQgLz5cbjxuZy1jb250YWluZXIgKm5nSWY9XCJoZWFkcyQgfCBhc3luYyBhcyBoZWFkaW5nc1wiPlxuICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgKm5nRm9yPVwibGV0IGtleSBvZiB0YWJsZS5jb2x1bW5zXCJcbiAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiKGhlYWRpbmdzW2tleV0gJiYgaGVhZGluZ3Nba2V5XS50ZW1wbGF0ZSkgfHwgcGxhaW5cIlxuICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDoga2V5fVwiXG4gICAgLz5cbiAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgI3BsYWluXG4gICAgICAgIGxldC1rZXlcbiAgICA+XG4gICAgICAgIDx0aFxuICAgICAgICAgICAgKm5nSWY9XCIhdGggJiYgIWhlYWRzLmxlbmd0aFwiXG4gICAgICAgICAgICB0dWlUaFxuICAgICAgICA+XG4gICAgICAgICAgICB7eyBrZXkudG9TdHJpbmcoKSB9fVxuICAgICAgICA8L3RoPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLWNvbnRhaW5lcj5cbiJdfQ==