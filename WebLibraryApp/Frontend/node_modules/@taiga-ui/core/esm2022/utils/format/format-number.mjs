import { CHAR_HYPHEN } from '@taiga-ui/cdk/constants';
import { tuiRoundWith } from '@taiga-ui/cdk/utils/math';
import { TUI_DEFAULT_NUMBER_FORMAT } from '@taiga-ui/core/tokens';
import { tuiGetFractionPartPadded } from './get-fractional-part-padded';
/**
 * Formats number adding a thousand separators and correct decimal separator
 * padding decimal part with zeroes to given length
 *
 * @param value the input number
 * @param settings See {@link TuiNumberFormatSettings}
 * @return the formatted string
 */
export function tuiFormatNumber(value, settings = {}) {
    const { precision, decimalSeparator, thousandSeparator, decimalMode, rounding } = {
        ...TUI_DEFAULT_NUMBER_FORMAT,
        decimalMode: 'always',
        precision: Infinity,
        ...settings,
    };
    const rounded = Number.isFinite(precision)
        ? tuiRoundWith({ value, precision, method: rounding })
        : value;
    const integerPartString = String(Math.floor(Math.abs(rounded)));
    let fractionPartPadded = tuiGetFractionPartPadded(rounded, precision);
    const hasFraction = Number(fractionPartPadded) > 0;
    if (Number.isFinite(precision)) {
        if (decimalMode === 'always' || (hasFraction && decimalMode === 'pad')) {
            const zeroPaddingSize = Math.max(precision - fractionPartPadded.length, 0);
            const zeroPartString = '0'.repeat(zeroPaddingSize);
            fractionPartPadded = `${fractionPartPadded}${zeroPartString}`;
        }
        else {
            fractionPartPadded = fractionPartPadded.replace(/0*$/, '');
        }
    }
    const remainder = integerPartString.length % 3;
    const sign = value < 0 ? CHAR_HYPHEN : '';
    let result = sign + integerPartString.charAt(0);
    for (let i = 1; i < integerPartString.length; i++) {
        if (i % 3 === remainder && integerPartString.length > 3) {
            result += thousandSeparator;
        }
        result += integerPartString.charAt(i);
    }
    return fractionPartPadded ? result + decimalSeparator + fractionPartPadded : result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0LW51bWJlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUvdXRpbHMvZm9ybWF0L2Zvcm1hdC1udW1iZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUV0RCxPQUFPLEVBQUMseUJBQXlCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUVoRSxPQUFPLEVBQUMsd0JBQXdCLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQUV0RTs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLGVBQWUsQ0FDM0IsS0FBYSxFQUNiLFdBQTZDLEVBQUU7SUFFL0MsTUFBTSxFQUFDLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFDLEdBQUc7UUFDNUUsR0FBRyx5QkFBeUI7UUFDNUIsV0FBVyxFQUFFLFFBQVE7UUFDckIsU0FBUyxFQUFFLFFBQVE7UUFDbkIsR0FBRyxRQUFRO0tBQ2QsQ0FBQztJQUVGLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO1FBQ3RDLENBQUMsQ0FBQyxZQUFZLENBQUMsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUMsQ0FBQztRQUNwRCxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ1osTUFBTSxpQkFBaUIsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVoRSxJQUFJLGtCQUFrQixHQUFHLHdCQUF3QixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN0RSxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFbkQsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1FBQzVCLElBQUksV0FBVyxLQUFLLFFBQVEsSUFBSSxDQUFDLFdBQVcsSUFBSSxXQUFXLEtBQUssS0FBSyxDQUFDLEVBQUU7WUFDcEUsTUFBTSxlQUFlLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FDcEMsU0FBUyxHQUFHLGtCQUFrQixDQUFDLE1BQU0sRUFDckMsQ0FBQyxDQUNKLENBQUM7WUFDRixNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBRW5ELGtCQUFrQixHQUFHLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxFQUFFLENBQUM7U0FDakU7YUFBTTtZQUNILGtCQUFrQixHQUFHLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDOUQ7S0FDSjtJQUVELE1BQU0sU0FBUyxHQUFHLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDL0MsTUFBTSxJQUFJLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDMUMsSUFBSSxNQUFNLEdBQUcsSUFBSSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVoRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQy9DLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxTQUFTLElBQUksaUJBQWlCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNyRCxNQUFNLElBQUksaUJBQWlCLENBQUM7U0FDL0I7UUFFRCxNQUFNLElBQUksaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3pDO0lBRUQsT0FBTyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDeEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q0hBUl9IWVBIRU59IGZyb20gJ0B0YWlnYS11aS9jZGsvY29uc3RhbnRzJztcbmltcG9ydCB7dHVpUm91bmRXaXRofSBmcm9tICdAdGFpZ2EtdWkvY2RrL3V0aWxzL21hdGgnO1xuaW1wb3J0IHR5cGUge1R1aU51bWJlckZvcm1hdFNldHRpbmdzfSBmcm9tICdAdGFpZ2EtdWkvY29yZS90b2tlbnMnO1xuaW1wb3J0IHtUVUlfREVGQVVMVF9OVU1CRVJfRk9STUFUfSBmcm9tICdAdGFpZ2EtdWkvY29yZS90b2tlbnMnO1xuXG5pbXBvcnQge3R1aUdldEZyYWN0aW9uUGFydFBhZGRlZH0gZnJvbSAnLi9nZXQtZnJhY3Rpb25hbC1wYXJ0LXBhZGRlZCc7XG5cbi8qKlxuICogRm9ybWF0cyBudW1iZXIgYWRkaW5nIGEgdGhvdXNhbmQgc2VwYXJhdG9ycyBhbmQgY29ycmVjdCBkZWNpbWFsIHNlcGFyYXRvclxuICogcGFkZGluZyBkZWNpbWFsIHBhcnQgd2l0aCB6ZXJvZXMgdG8gZ2l2ZW4gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSBpbnB1dCBudW1iZXJcbiAqIEBwYXJhbSBzZXR0aW5ncyBTZWUge0BsaW5rIFR1aU51bWJlckZvcm1hdFNldHRpbmdzfVxuICogQHJldHVybiB0aGUgZm9ybWF0dGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHVpRm9ybWF0TnVtYmVyKFxuICAgIHZhbHVlOiBudW1iZXIsXG4gICAgc2V0dGluZ3M6IFBhcnRpYWw8VHVpTnVtYmVyRm9ybWF0U2V0dGluZ3M+ID0ge30sXG4pOiBzdHJpbmcge1xuICAgIGNvbnN0IHtwcmVjaXNpb24sIGRlY2ltYWxTZXBhcmF0b3IsIHRob3VzYW5kU2VwYXJhdG9yLCBkZWNpbWFsTW9kZSwgcm91bmRpbmd9ID0ge1xuICAgICAgICAuLi5UVUlfREVGQVVMVF9OVU1CRVJfRk9STUFULFxuICAgICAgICBkZWNpbWFsTW9kZTogJ2Fsd2F5cycsXG4gICAgICAgIHByZWNpc2lvbjogSW5maW5pdHksXG4gICAgICAgIC4uLnNldHRpbmdzLFxuICAgIH07XG5cbiAgICBjb25zdCByb3VuZGVkID0gTnVtYmVyLmlzRmluaXRlKHByZWNpc2lvbilcbiAgICAgICAgPyB0dWlSb3VuZFdpdGgoe3ZhbHVlLCBwcmVjaXNpb24sIG1ldGhvZDogcm91bmRpbmd9KVxuICAgICAgICA6IHZhbHVlO1xuICAgIGNvbnN0IGludGVnZXJQYXJ0U3RyaW5nID0gU3RyaW5nKE1hdGguZmxvb3IoTWF0aC5hYnMocm91bmRlZCkpKTtcblxuICAgIGxldCBmcmFjdGlvblBhcnRQYWRkZWQgPSB0dWlHZXRGcmFjdGlvblBhcnRQYWRkZWQocm91bmRlZCwgcHJlY2lzaW9uKTtcbiAgICBjb25zdCBoYXNGcmFjdGlvbiA9IE51bWJlcihmcmFjdGlvblBhcnRQYWRkZWQpID4gMDtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocHJlY2lzaW9uKSkge1xuICAgICAgICBpZiAoZGVjaW1hbE1vZGUgPT09ICdhbHdheXMnIHx8IChoYXNGcmFjdGlvbiAmJiBkZWNpbWFsTW9kZSA9PT0gJ3BhZCcpKSB7XG4gICAgICAgICAgICBjb25zdCB6ZXJvUGFkZGluZ1NpemU6IG51bWJlciA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbiAtIGZyYWN0aW9uUGFydFBhZGRlZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCB6ZXJvUGFydFN0cmluZyA9ICcwJy5yZXBlYXQoemVyb1BhZGRpbmdTaXplKTtcblxuICAgICAgICAgICAgZnJhY3Rpb25QYXJ0UGFkZGVkID0gYCR7ZnJhY3Rpb25QYXJ0UGFkZGVkfSR7emVyb1BhcnRTdHJpbmd9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWN0aW9uUGFydFBhZGRlZCA9IGZyYWN0aW9uUGFydFBhZGRlZC5yZXBsYWNlKC8wKiQvLCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZW1haW5kZXIgPSBpbnRlZ2VyUGFydFN0cmluZy5sZW5ndGggJSAzO1xuICAgIGNvbnN0IHNpZ24gPSB2YWx1ZSA8IDAgPyBDSEFSX0hZUEhFTiA6ICcnO1xuICAgIGxldCByZXN1bHQgPSBzaWduICsgaW50ZWdlclBhcnRTdHJpbmcuY2hhckF0KDApO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnRlZ2VyUGFydFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAlIDMgPT09IHJlbWFpbmRlciAmJiBpbnRlZ2VyUGFydFN0cmluZy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gaW50ZWdlclBhcnRTdHJpbmcuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFjdGlvblBhcnRQYWRkZWQgPyByZXN1bHQgKyBkZWNpbWFsU2VwYXJhdG9yICsgZnJhY3Rpb25QYXJ0UGFkZGVkIDogcmVzdWx0O1xufVxuIl19